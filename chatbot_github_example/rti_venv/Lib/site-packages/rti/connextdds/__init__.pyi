import rti.connextdds
import typing
import builtins
import datetime

class DynamicType():
    def __eq__(self, arg0: rti.connextdds.DynamicType) -> bool: 
        """
        Compare DynamicType objects for equality.
        """
    def __ne__(self, arg0: rti.connextdds.DynamicType) -> bool: 
        """
        Compare DynamicType objects for inequality.
        """
    def __str__(self) -> str: 
        """
        DynamicData value to string.
        """
    def is_aggregation_type(self) -> bool: 
        """
        Determines if this DynamicType is an aggregation type.
        """
    def is_collection_type(self) -> bool: 
        """
        Determins if this DynamicType is a CollectionType.
        """
    def is_constructed_type(self) -> bool: 
        """
        Determines if this DynamicType is a constructed type.
        """
    def is_keyed(self) -> bool: 
        """
        Determines if this DynamicType has a key.
        """
    def is_primitive_type(self) -> bool: 
        """
        Determines if this DynamicType is a PrimitiveType
        """
    def print_idl(self, index: int = 0) -> None: 
        """
        Prints the IDL representation of this type to the standard output.
        """
    def to_string(self, format: rti.connextdds.DynamicTypePrintFormatProperty = DynamicTypePrintFormatProperty()) -> str: 
        """
        Convert DynamicType to string with print format.
        """
    @builtins.property
    def kind(self) -> TypeKind:
        """
        Get the type kind.

        :type: TypeKind
        """
    @builtins.property
    def name(self) -> str:
        """
        Gets the name.

        :type: str
        """
    __hash__: NoneType
    pass
class ACTMember(DynamicType):
    def __eq__(self, arg0: rti.connextdds.ACTMember) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __getitem__(self, arg0: str) -> rti.connextdds.Member: ...
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Member: ...
    def __ne__(self, arg0: rti.connextdds.ACTMember) -> bool: 
        """
        Test for inequality.
        """
    def cdr_serialized_sample_max_size(self, arg0: int) -> int: 
        """
        Gets the maximum serialized size of samples of this type.
        """
    def cdr_serialized_sample_min_size(self, arg0: int) -> int: 
        """
        Gets the minimum serialized size of samples of this type.
        """
    def extensibility_kind(self) -> rti.connextdds.ExtensibilityKind: 
        """
        Gets the extensibility kind.
        """
    def find_member_by_name(self, arg0: str) -> int: 
        """
        Obtains the member index from its name.
        """
    @typing.overload
    def member(self, arg0: int) -> rti.connextdds.Member: 
        """
        Gets a member by its index.
        """
    @typing.overload
    def member(self, arg0: str) -> rti.connextdds.Member: 
        """
        Gets a member by its name.
        """
    def members(self) -> rti.connextdds.MemberSeq: 
        """
        Gets a copy of all the members
        """
    @builtins.property
    def member_count(self) -> int:
        """
        Gets the number of members.

        :type: int
        """
    INVALID_INDEX: int
    __hash__: NoneType
    pass
class ACTUnionMember(DynamicType):
    def __eq__(self, arg0: rti.connextdds.ACTUnionMember) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __getitem__(self, arg0: str) -> rti.connextdds.UnionMember: ...
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.UnionMember: ...
    def __ne__(self, arg0: rti.connextdds.ACTUnionMember) -> bool: 
        """
        Test for inequality.
        """
    def cdr_serialized_sample_max_size(self, arg0: int) -> int: 
        """
        Gets the maximum serialized size of samples of this type.
        """
    def cdr_serialized_sample_min_size(self, arg0: int) -> int: 
        """
        Gets the minimum serialized size of samples of this type.
        """
    def extensibility_kind(self) -> rti.connextdds.ExtensibilityKind: 
        """
        Gets the extensibility kind.
        """
    def find_member_by_name(self, arg0: str) -> int: 
        """
        Obtains the member index from its name.
        """
    @typing.overload
    def member(self, arg0: int) -> rti.connextdds.UnionMember: 
        """
        Gets a member by its index.
        """
    @typing.overload
    def member(self, arg0: str) -> rti.connextdds.UnionMember: 
        """
        Gets a member by its name.
        """
    def members(self) -> rti.connextdds.UnionMemberSeq: 
        """
        Gets a copy of all the members
        """
    @builtins.property
    def member_count(self) -> int:
        """
        Gets the number of members.

        :type: int
        """
    INVALID_INDEX: int
    __hash__: NoneType
    pass
class AckResponseData():
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty ack response.
        """
    @typing.overload
    def __init__(self, sequence: rti.connextdds.Uint8Seq) -> None: 
        """
        Create an instance with a byte sequence.
        """
    @builtins.property
    def value(self) -> Uint8Seq:
        """
        Gets the subscription handle of the acknowledging DataReader

        :type: Uint8Seq
        """
    @value.setter
    def value(self, arg1: Uint8Seq) -> None:
        """
        Gets the subscription handle of the acknowledging DataReader
        """
    pass
class AcknowledgmentInfo():
    @builtins.property
    def cookie(self) -> Cookie:
        """
        Cookie value of the acknowledgment.

        :type: Cookie
        """
    @builtins.property
    def response_data(self) -> AckResponseData:
        """
        User data payload of application-level acknowledgment.

        :type: AckResponseData
        """
    @builtins.property
    def sample_identity(self) -> SampleIdentity:
        """
        Get the identity of the sample being acknowledged.

        :type: SampleIdentity
        """
    @builtins.property
    def subscription_handle(self) -> InstanceHandle:
        """
        Gets the subscription handle of the acknowledging DataReader

        :type: InstanceHandle
        """
    @builtins.property
    def valid_response_data(self) -> bool:
        """
        Flag indicating validity of the use response data in the acknowledgment.

        :type: bool
        """
    pass
class AcknowledgmentKind():
    class AcknowledgmentKind():
        """
        Members:

          PROTOCOL : Samples are acknowledged by RTPS protocol.

        Samples are acknowledged according to the Real-Time Publish-Subscribe (RTPS) interoperability protocol.

          APPLICATION_AUTO : Samples are acknowledged automatically after a subscribing application has accessed them.

        The DataReader automatically acknowledges a sample after it has been taken and the loan returned.

          APPLICATION_ORDERED : Samples up to a specified sequence number are acknowledged.

          APPLICATION_EXPLICIT : Samples are acknowledged after the subscribing application explicitly calls acknowledge on the samples.

        Samples received by a DataReader are explicitly acknowledged by the subscribing application, after it calls either DataReader.acknowledge_all or DataReader.acknowledge_sample.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        APPLICATION_AUTO: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind
        APPLICATION_EXPLICIT: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind
        APPLICATION_ORDERED: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind
        PROTOCOL: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.AcknowledgmentKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.AcknowledgmentKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.AcknowledgmentKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.AcknowledgmentKind.AcknowledgmentKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.AcknowledgmentKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.AcknowledgmentKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.AcknowledgmentKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> AcknowledgmentKind.AcknowledgmentKind:
        """
        Retrieves the actual enumerated value.

        :type: AcknowledgmentKind.AcknowledgmentKind
        """
    APPLICATION_AUTO: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind
    APPLICATION_EXPLICIT: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind
    APPLICATION_ORDERED: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind
    PROTOCOL: rti.connextdds.AcknowledgmentKind.AcknowledgmentKind
    __hash__: NoneType
    pass
class ActivityContextMask():
    def __and__(self, arg0: rti.connextdds.ActivityContextMask) -> rti.connextdds.ActivityContextMask: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.ActivityContextMask) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.ActivityContextMask) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.ActivityContextMask) -> rti.connextdds.ActivityContextMask: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.ActivityContextMask: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an ActivityContextMask with no bits set.
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.ActivityContextMask) -> rti.connextdds.ActivityContextMask: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.ActivityContextMask: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.ActivityContextMask) -> rti.connextdds.ActivityContextMask: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.ActivityContextMask: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.ActivityContextMask) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.ActivityContextMask) -> rti.connextdds.ActivityContextMask: 
        """
        Bitwise logical OR of masks.
        """
    def __repr__(self) -> str: 
        """
        Convert mask to string.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.ActivityContextMask: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: 
        """
        Convert mask to string.
        """
    def __xor__(self, arg0: rti.connextdds.ActivityContextMask) -> rti.connextdds.ActivityContextMask: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.ActivityContextMask: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.ActivityContextMask: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.ActivityContextMask: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.ActivityContextMask: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.ActivityContextMask: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.ActivityContextMask: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ALL: rti.connextdds.ActivityContextMask
    DEFAULT: rti.connextdds.ActivityContextMask
    DOMAIN_ID: rti.connextdds.ActivityContextMask
    ENTITY_KIND: rti.connextdds.ActivityContextMask
    ENTITY_NAME: rti.connextdds.ActivityContextMask
    GUID_PREFIX: rti.connextdds.ActivityContextMask
    NONE: rti.connextdds.ActivityContextMask
    TOPIC: rti.connextdds.ActivityContextMask
    TYPE: rti.connextdds.ActivityContextMask
    __hash__: NoneType
    pass
class AliasType(DynamicType):
    """
    Represents a typedef.
    """
    def __eq__(self, arg0: rti.connextdds.AliasType) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, name: str, type_name: rti.connextdds.DynamicType, is_pointer: bool = False) -> None: 
        """
        Creates an alias with a name and a related type.
        """
    def __ne__(self, arg0: rti.connextdds.AliasType) -> bool: 
        """
        Test for inequality.
        """
    def related_type(self) -> rti.connextdds.DynamicType: 
        """
        Gets the related type.
        """
    def resolve(self) -> rti.connextdds.DynamicType: 
        """
        Resolves an AliasType recursively to get the final underlying type.
        """
    @staticmethod
    def resolve_type(alias_type: rti.connextdds.DynamicType) -> rti.connextdds.DynamicType: 
        """
        Resolves an AliasType recursively to get the final underlying type.
        """
    @builtins.property
    def is_pointer(self) -> bool:
        """
        Gets whether this alias makes related_type a pointer

        :type: bool
        """
    __hash__: NoneType
    pass
class AllocationSettings():
    def __eq__(self, arg0: rti.connextdds.AllocationSettings) -> bool: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an instance with an initial, max and incremental count set to zero.
        """
    @typing.overload
    def __init__(self, initial_count: int, max_count: int, incremental_count: int) -> None: 
        """
        Creates an instance with the given initial, maximum and incremental values.
        """
    def __ne__(self, arg0: rti.connextdds.AllocationSettings) -> bool: ...
    @builtins.property
    def incremental_count(self) -> int:
        """
        Incremental count of resources.

        :type: int
        """
    @incremental_count.setter
    def incremental_count(self, arg1: int) -> None:
        """
        Incremental count of resources.
        """
    @builtins.property
    def initial_count(self) -> int:
        """
        Initial count of resources.

        :type: int
        """
    @initial_count.setter
    def initial_count(self, arg1: int) -> None:
        """
        Initial count of resources.
        """
    @builtins.property
    def max_count(self) -> int:
        """
        Max count of resources.

        :type: int
        """
    @max_count.setter
    def max_count(self, arg1: int) -> None:
        """
        Max count of resources.
        """
    AUTO_COUNT: int
    __hash__: NoneType
    pass
class Exception(BaseException):
    pass
class IAnyDataReader():
    def __eq__(self, arg0: rti.connextdds.IAnyDataReader) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.IAnyDataReader) -> bool: 
        """
        Test for inequality.
        """
    def close(self) -> None: 
        """
        Close this DataReader.
        """
    def retain(self) -> None: 
        """
        Retain this DataReader.
        """
    @builtins.property
    def qos(self) -> DataReaderQos:
        """
        The QoS for this AnyDataReader.

        This property's getter returns a deep copy.

        :type: DataReaderQos
        """
    @qos.setter
    def qos(self, arg1: DataReaderQos) -> None:
        """
        The QoS for this AnyDataReader.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def subscriber(self) -> Subscriber:
        """
        The Publisher for this AnyDataReader.

        :type: Subscriber
        """
    @builtins.property
    def topic_name(self) -> str:
        """
        The Topic name for this AnyDataReader.

        :type: str
        """
    @builtins.property
    def type_name(self) -> str:
        """
        The type name for this AnyDataReader.

        :type: str
        """
    __hash__: NoneType
    pass
class AnyDataReaderListener():
    def __init__(self) -> None: ...
    def on_data_available(self, arg0: rti.connextdds.AnyDataReader) -> None: 
        """
        Data available callback.
        """
    def on_liveliness_changed(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
        """
        Liveliness changed callback.
        """
    def on_requested_deadline_missed(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
        """
        Requested deadline missed callback.
        """
    def on_requested_incompatible_qos(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
        """
        Requested incompatible QoS callback.
        """
    def on_sample_lost(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
        """
        Sample lost callback.
        """
    def on_sample_rejected(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
        """
        Sample rejected callback.
        """
    def on_subscription_matched(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
        """
        Subscription matched callback.
        """
    pass
class AnyDataReaderSeq():
    def __add__(self, arg0: rti.connextdds.AnyDataReaderSeq) -> rti.connextdds.AnyDataReaderSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.AnyDataReader) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.AnyDataReaderSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.AnyDataReaderSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.AnyDataReader: ...
    def __iadd__(self, arg0: rti.connextdds.AnyDataReaderSeq) -> rti.connextdds.AnyDataReaderSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.AnyDataReaderSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.AnyDataReaderSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.AnyDataReader]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.AnyDataReaderSeq: ...
    def __ne__(self, arg0: rti.connextdds.AnyDataReaderSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.AnyDataReaderSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.AnyDataReader) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.AnyDataReaderSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.AnyDataReader) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.AnyDataReader) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.AnyDataReaderSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.AnyDataReader) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.AnyDataReader: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.AnyDataReader: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.AnyDataReader) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class IAnyDataWriter():
    def __eq__(self, arg0: rti.connextdds.IAnyDataWriter) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.IAnyDataWriter) -> bool: 
        """
        Test for inequality.
        """
    def close(self) -> None: 
        """
        Close this DataWriter.
        """
    def retain(self) -> None: 
        """
        Retain this DataWriter.
        """
    def wait_for_acknowledgments(self, timeout: rti.connextdds.Duration) -> None: 
        """
        Wait for acknowledgments from subscribers.
        """
    @builtins.property
    def publisher(self) -> Publisher:
        """
        The Publisher for this AnyDataWriter.

        :type: Publisher
        """
    @builtins.property
    def qos(self) -> DataWriterQos:
        """
        The QoS for this AnyDataWriter.

        This property's getter returns a deep copy.

        :type: DataWriterQos
        """
    @qos.setter
    def qos(self, arg1: DataWriterQos) -> None:
        """
        The QoS for this AnyDataWriter.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def topic_name(self) -> str:
        """
        The Topic name for this AnyDataWriter.

        :type: str
        """
    @builtins.property
    def type_name(self) -> str:
        """
        The type name for this AnyDataWriter.

        :type: str
        """
    __hash__: NoneType
    pass
class AnyDataWriterListener():
    def __init__(self) -> None: ...
    def on_application_acknowledgment(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
        """
        On application acknowledgment callback
        """
    def on_instance_replaced(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
        """
        On instance replaced callback.
        """
    def on_liveliness_lost(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
        """
        Liveliness lost callback.
        """
    def on_offered_deadline_missed(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
        """
        Offered deadline missed callback.
        """
    def on_offered_incompatible_qos(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
        """
        Offered incompatible QoS callback.
        """
    def on_publication_matched(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
        """
        Publication matched callback.
        """
    def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
        """
        Reliable reader activity changed callback.
        """
    def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
        """
        Reliable writer cache changed callback.
        """
    def on_service_request_accepted(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
        """
        On service request accepted callback.
        """
    pass
class AnyDataWriterSeq():
    def __add__(self, arg0: rti.connextdds.AnyDataWriterSeq) -> rti.connextdds.AnyDataWriterSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.AnyDataWriter) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.AnyDataWriterSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.AnyDataWriterSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.AnyDataWriter: ...
    def __iadd__(self, arg0: rti.connextdds.AnyDataWriterSeq) -> rti.connextdds.AnyDataWriterSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.AnyDataWriterSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.AnyDataWriterSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.AnyDataWriter]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.AnyDataWriterSeq: ...
    def __ne__(self, arg0: rti.connextdds.AnyDataWriterSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.AnyDataWriterSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.AnyDataWriter) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.AnyDataWriterSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.AnyDataWriter) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.AnyDataWriter) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.AnyDataWriterSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.AnyDataWriter) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.AnyDataWriter: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.AnyDataWriter: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.AnyDataWriter) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class IAnyTopic():
    def __eq__(self, arg0: rti.connextdds.IAnyTopic) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.IAnyTopic) -> bool: 
        """
        Test for inequality.
        """
    def close(self) -> None: 
        """
        Close this Topic.
        """
    @builtins.property
    def name(self) -> str:
        """
        The Topic name for this AnyTopic.

        :type: str
        """
    @builtins.property
    def qos(self) -> TopicQos:
        """
        The QoS for this AnyTopic.

        This property's getter returns a deep copy.

        :type: TopicQos
        """
    @qos.setter
    def qos(self, arg1: TopicQos) -> None:
        """
        The QoS for this AnyTopic.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def type_name(self) -> str:
        """
        The type name for this AnyTopic.

        :type: str
        """
    __hash__: NoneType
    pass
class AnyTopicListener():
    def __init__(self) -> None: ...
    def on_inconsistent_topic(self, arg0: rti.connextdds.AnyTopic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
        """
        Inconsistent topic callback.
        """
    pass
class AnyTopicSeq():
    def __add__(self, arg0: rti.connextdds.AnyTopicSeq) -> rti.connextdds.AnyTopicSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.AnyTopic) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.AnyTopicSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.AnyTopicSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.AnyTopic: ...
    def __iadd__(self, arg0: rti.connextdds.AnyTopicSeq) -> rti.connextdds.AnyTopicSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.AnyTopicSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.AnyTopicSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.AnyTopic]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.AnyTopicSeq: ...
    def __ne__(self, arg0: rti.connextdds.AnyTopicSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.AnyTopicSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.AnyTopic) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.AnyTopicSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.AnyTopic) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.AnyTopic) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.AnyTopicSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.AnyTopic) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.AnyTopic: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.AnyTopic: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.AnyTopic) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class CollectionType(DynamicType):
    def __eq__(self, arg0: rti.connextdds.CollectionType) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.CollectionType) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def content_type(self) -> object:
        """
        Gets the type of elements of this collection.

        :type: object
        """
    __hash__: NoneType
    pass
class AsynchronousPublisher():
    def __eq__(self, arg0: rti.connextdds.AsynchronousPublisher) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default AsynchronousPublisher QoS policy.
        """
    def __ne__(self, arg0: rti.connextdds.AsynchronousPublisher) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    def enabled(enable_async_batch: bool = False) -> rti.connextdds.AsynchronousPublisher: 
        """
        Create an AsynchronousPublisher QoS policy with asynchronous write (and optionally asynchronous batch flushing) enabled.
        """
    @builtins.property
    def asynchronous_batch_thread(self) -> ThreadSettings:
        """
        Get/set the settings associated with the asynchronous batch flush thread.

        :type: ThreadSettings
        """
    @asynchronous_batch_thread.setter
    def asynchronous_batch_thread(self, arg1: ThreadSettings) -> None:
        """
        Get/set the settings associated with the asynchronous batch flush thread.
        """
    @builtins.property
    def disable_asynchronous_batch(self) -> bool:
        """
        Get/set the asynchronous batch flushing capability for this policy.

        :type: bool
        """
    @disable_asynchronous_batch.setter
    def disable_asynchronous_batch(self, arg1: bool) -> None:
        """
        Get/set the asynchronous batch flushing capability for this policy.
        """
    @builtins.property
    def disable_asynchronous_write(self) -> bool:
        """
        Get/set the asynchronous write capability for this policy.

        :type: bool
        """
    @disable_asynchronous_write.setter
    def disable_asynchronous_write(self, arg1: bool) -> None:
        """
        Get/set the asynchronous write capability for this policy.
        """
    @builtins.property
    def disable_topic_query_publication(self) -> bool:
        """
        Get/set the topic query publication capability for this policy.

        :type: bool
        """
    @disable_topic_query_publication.setter
    def disable_topic_query_publication(self, arg1: bool) -> None:
        """
        Get/set the topic query publication capability for this policy.
        """
    @builtins.property
    def thread(self) -> ThreadSettings:
        """
        Get/set the settings associated with the asynchronous publisher thread.

        :type: ThreadSettings
        """
    @thread.setter
    def thread(self, arg1: ThreadSettings) -> None:
        """
        Get/set the settings associated with the asynchronous publisher thread.
        """
    @builtins.property
    def topic_query_publication_thread(self) -> ThreadSettings:
        """
        Get/set the settings associated with the topic query publication thread.

        :type: ThreadSettings
        """
    @topic_query_publication_thread.setter
    def topic_query_publication_thread(self, arg1: ThreadSettings) -> None:
        """
        Get/set the settings associated with the topic query publication thread.
        """
    __hash__: NoneType
    disabled: rti.connextdds.AsynchronousPublisher
    pass
class Availability():
    def __eq__(self, arg0: rti.connextdds.Availability) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default Availability QoS policy.
        """
    @typing.overload
    def __init__(self, enable_required_subscriptions: bool, data_waiting_time: rti.connextdds.Duration, endpoint_waiting_time: rti.connextdds.Duration, required_endpount_groups: rti.connextdds.EndpointGroupVector) -> None: 
        """
        Create an Availability QoS policy with the provided parameters.
        """
    def __ne__(self, arg0: rti.connextdds.Availability) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def enable_required_subscriptions(self) -> bool:
        """
        Get/set the status of required subscriptions for this policy.

        :type: bool
        """
    @enable_required_subscriptions.setter
    def enable_required_subscriptions(self, arg1: bool) -> None:
        """
        Get/set the status of required subscriptions for this policy.
        """
    @builtins.property
    def max_data_availability_waiting_time(self) -> Duration:
        """
        Get/set the amount of time to wait before delivering a sample to the application without having received some of the previous samples.

        :type: Duration
        """
    @max_data_availability_waiting_time.setter
    def max_data_availability_waiting_time(self, arg1: Duration) -> None:
        """
        Get/set the amount of time to wait before delivering a sample to the application without having received some of the previous samples.
        """
    @builtins.property
    def max_endpoint_availability_waiting_time(self) -> Duration:
        """
        Get/set the amount of time to wait to discover DataWriters providing samples for the same data source (virtual GUID).

        :type: Duration
        """
    @max_endpoint_availability_waiting_time.setter
    def max_endpoint_availability_waiting_time(self, arg1: Duration) -> None:
        """
        Get/set the amount of time to wait to discover DataWriters providing samples for the same data source (virtual GUID).
        """
    @builtins.property
    def required_matched_endpoint_groups(self) -> EndpointGroupSeq:
        """
        Get/set a copy of the required endpoint groups.

        :type: EndpointGroupSeq
        """
    @required_matched_endpoint_groups.setter
    def required_matched_endpoint_groups(self, arg1: EndpointGroupSeq) -> None:
        """
        Get/set a copy of the required endpoint groups.
        """
    __hash__: NoneType
    pass
class Batch():
    def __eq__(self, arg0: rti.connextdds.Batch) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a Batch QoS policy with the default settings (disabled).
        """
    def __ne__(self, arg0: rti.connextdds.Batch) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    def enabled_with_max_data_bytes(max_data_bytes: int) -> rti.connextdds.Batch: 
        """
        Create a Batch policy with batching enabled that will flush based on the cummulative size of serialized samples.
        """
    @staticmethod
    def enabled_with_max_samples(max_samples: int) -> rti.connextdds.Batch: 
        """
        Create a Batch policy with batching enabled that will flush based on the number of samples written to the batch.
        """
    @builtins.property
    def enable(self) -> bool:
        """
        Get/set boolean that specifies whether batching is enabled.

        :type: bool
        """
    @enable.setter
    def enable(self, arg1: bool) -> None:
        """
        Get/set boolean that specifies whether batching is enabled.
        """
    @builtins.property
    def max_data_bytes(self) -> int:
        """
        Get/set the maximum cummulative size of serialized samples in a batch. When this limit is reached the batch will be flushed.

        :type: int
        """
    @max_data_bytes.setter
    def max_data_bytes(self, arg1: int) -> None:
        """
        Get/set the maximum cummulative size of serialized samples in a batch. When this limit is reached the batch will be flushed.
        """
    @builtins.property
    def max_flush_delay(self) -> Duration:
        """
        Get/set the maximum delay to flush a batch, measured from the time the first sample in the batch is written.

        :type: Duration
        """
    @max_flush_delay.setter
    def max_flush_delay(self, arg1: Duration) -> None:
        """
        Get/set the maximum delay to flush a batch, measured from the time the first sample in the batch is written.
        """
    @builtins.property
    def max_samples(self) -> int:
        """
        Get/set the maximum number of serialized samples in a batch. When this limit is reached the batch will be flushed.

        :type: int
        """
    @max_samples.setter
    def max_samples(self, arg1: int) -> None:
        """
        Get/set the maximum number of serialized samples in a batch. When this limit is reached the batch will be flushed.
        """
    @builtins.property
    def source_timestamp_resolution(self) -> Duration:
        """
        Get/set the timestamp resolution of the samples in the batch.

        :type: Duration
        """
    @source_timestamp_resolution.setter
    def source_timestamp_resolution(self, arg1: Duration) -> None:
        """
        Get/set the timestamp resolution of the samples in the batch.
        """
    @builtins.property
    def thread_safe_write(self) -> bool:
        """
        Get/set boolean that specifies whether batch writes must be thread safe.

        :type: bool
        """
    @thread_safe_write.setter
    def thread_safe_write(self, arg1: bool) -> None:
        """
        Get/set boolean that specifies whether batch writes must be thread safe.
        """
    __hash__: NoneType
    disabled: rti.connextdds.Batch
    enabled: rti.connextdds.Batch
    pass
class BoolSeq():
    def __add__(self, arg0: rti.connextdds.BoolSeq) -> rti.connextdds.BoolSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: bool) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.BoolSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.BoolSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> bool: ...
    def __iadd__(self, arg0: rti.connextdds.BoolSeq) -> rti.connextdds.BoolSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.BoolSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.BoolSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[bool]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.BoolSeq: ...
    def __ne__(self, arg0: rti.connextdds.BoolSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.BoolSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: bool) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.BoolSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: bool) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: bool) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.BoolSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: bool) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> bool: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> bool: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: bool) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class BoolType(DynamicType):
    def __eq__(self, arg0: rti.connextdds.BoolType) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for BoolType
        """
    def __ne__(self, arg0: rti.connextdds.BoolType) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class BuiltinProfiles():
    baseline: str
    baseline_5_0_0: str
    baseline_5_1_0: str
    baseline_5_2_0: str
    baseline_5_3_0: str
    baseline_6_0_0: str
    generic_auto_tuning: str
    generic_best_effort: str
    generic_common: str
    generic_connext_micro_compatibility: str
    generic_connext_micro_compatibility_2_4_3: str
    generic_connext_micro_compatibility_2_4_9: str
    generic_keep_last_reliable: str
    generic_keep_last_reliable_large_data: str
    generic_keep_last_reliable_large_data_fast_flow: str
    generic_keep_last_reliable_large_data_medium_flow: str
    generic_keep_last_reliable_large_data_slow_flow: str
    generic_keep_last_reliable_persistent: str
    generic_keep_last_reliable_transient: str
    generic_keep_last_reliable_transient_local: str
    generic_minimal_memory_footprint: str
    generic_monitoring2: str
    generic_monitoring_common: str
    generic_other_dds_vendor_compatibility: str
    generic_participant_large_data: str
    generic_participant_large_data_monitoring: str
    generic_security: str
    generic_strict_reliable: str
    generic_strict_reliable_high_throughput: str
    generic_strict_reliable_large_data: str
    generic_strict_reliable_large_data_fast_flow: str
    generic_strict_reliable_large_data_medium_flow: str
    generic_strict_reliable_large_data_slow_flow: str
    generic_strict_reliable_low_latency: str
    library_name: str
    pattern_alarm_event: str
    pattern_alarm_status: str
    pattern_event: str
    pattern_last_value_cache: str
    pattern_periodic_data: str
    pattern_reliable_streaming: str
    pattern_rpc: str
    pattern_status: str
    pattern_streaming: str
    pass
class BuiltinTopicKey():
    def __eq__(self, arg0: rti.connextdds.BuiltinTopicKey) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates a key whose value is all zeros.
        """
    def __ne__(self, arg0: rti.connextdds.BuiltinTopicKey) -> bool: 
        """
        Test for inequality.
        """
    def __repr__(self) -> str: 
        """
        Returns a string representation of the key.
        """
    @builtins.property
    def value(self) -> Uint32Seq:
        """
        Returns a copy of the four integers that represent the key.

        :type: Uint32Seq
        """
    __hash__: NoneType
    pass
class BuiltinTopicReaderResourceLimits():
    def __eq__(self, arg0: rti.connextdds.BuiltinTopicReaderResourceLimits) -> bool: ...
    def __init__(self) -> None: 
        """
        Create a policy with default settings.
        """
    def __ne__(self, arg0: rti.connextdds.BuiltinTopicReaderResourceLimits) -> bool: ...
    @builtins.property
    def disable_fragmentation_support(self) -> bool:
        """
        Determines whether the DataReader can receive fragmented samples.

        :type: bool
        """
    @disable_fragmentation_support.setter
    def disable_fragmentation_support(self, arg1: bool) -> None:
        """
        Determines whether the DataReader can receive fragmented samples.
        """
    @builtins.property
    def dynamically_allocate_fragmented_samples(self) -> bool:
        """
        Determines whether the DataReader pre-allocates storage for storing fragmented samples.

        :type: bool
        """
    @dynamically_allocate_fragmented_samples.setter
    def dynamically_allocate_fragmented_samples(self, arg1: bool) -> None:
        """
        Determines whether the DataReader pre-allocates storage for storing fragmented samples.
        """
    @builtins.property
    def initial_fragmented_samples(self) -> int:
        """
        The initial number of samples for which a DataReader may store fragments.

        :type: int
        """
    @initial_fragmented_samples.setter
    def initial_fragmented_samples(self, arg1: int) -> None:
        """
        The initial number of samples for which a DataReader may store fragments.
        """
    @builtins.property
    def initial_infos(self) -> int:
        """
        Initial number of sample infos.

        :type: int
        """
    @initial_infos.setter
    def initial_infos(self, arg1: int) -> None:
        """
        Initial number of sample infos.
        """
    @builtins.property
    def initial_outstanding_reads(self) -> int:
        """
        The initial number of outstanding calls to read/take (or one of their variants) on the same DataReader for which memory has not been returned by calling LoanedSamples.return_loan().

        :type: int
        """
    @initial_outstanding_reads.setter
    def initial_outstanding_reads(self, arg1: int) -> None:
        """
        The initial number of outstanding calls to read/take (or one of their variants) on the same DataReader for which memory has not been returned by calling LoanedSamples.return_loan().
        """
    @builtins.property
    def initial_samples(self) -> int:
        """
        Initial number of samples

        :type: int
        """
    @initial_samples.setter
    def initial_samples(self, arg1: int) -> None:
        """
        Initial number of samples
        """
    @builtins.property
    def max_fragmented_samples(self) -> int:
        """
        The maximum number of samples for which the DataReader may store fragments at a given point in time.

        :type: int
        """
    @max_fragmented_samples.setter
    def max_fragmented_samples(self, arg1: int) -> None:
        """
        The maximum number of samples for which the DataReader may store fragments at a given point in time.
        """
    @builtins.property
    def max_fragmented_samples_per_remote_writer(self) -> int:
        """
        The maximum number of samples per remote writer for which a built-in topic reader may store fragments.

        :type: int
        """
    @max_fragmented_samples_per_remote_writer.setter
    def max_fragmented_samples_per_remote_writer(self, arg1: int) -> None:
        """
        The maximum number of samples per remote writer for which a built-in topic reader may store fragments.
        """
    @builtins.property
    def max_fragments_per_sample(self) -> int:
        """
        Maximum number of fragments for a single sample.

        :type: int
        """
    @max_fragments_per_sample.setter
    def max_fragments_per_sample(self, arg1: int) -> None:
        """
        Maximum number of fragments for a single sample.
        """
    @builtins.property
    def max_infos(self) -> int:
        """
        Maximum number of sample infos.

        :type: int
        """
    @max_infos.setter
    def max_infos(self, arg1: int) -> None:
        """
        Maximum number of sample infos.
        """
    @builtins.property
    def max_outstanding_reads(self) -> int:
        """
        The max number of outstanding calls to read/take (or one of their variants) on the same DataReader for which memory has not been returned by calling LoanedSamples.return_loan().

        :type: int
        """
    @max_outstanding_reads.setter
    def max_outstanding_reads(self, arg1: int) -> None:
        """
        The max number of outstanding calls to read/take (or one of their variants) on the same DataReader for which memory has not been returned by calling LoanedSamples.return_loan().
        """
    @builtins.property
    def max_samples(self) -> int:
        """
        Maximum number of samples

        :type: int
        """
    @max_samples.setter
    def max_samples(self, arg1: int) -> None:
        """
        Maximum number of samples
        """
    @builtins.property
    def max_samples_per_read(self) -> int:
        """
        The maximum number of data samples that the application can receive from the middleware in a single call to DataReader.read() or DataReader.take(). If more data exists in the middleware, the application will need to issue multiple read/take calls.

        :type: int
        """
    @max_samples_per_read.setter
    def max_samples_per_read(self, arg1: int) -> None:
        """
        The maximum number of data samples that the application can receive from the middleware in a single call to DataReader.read() or DataReader.take(). If more data exists in the middleware, the application will need to issue multiple read/take calls.
        """
    __hash__: NoneType
    pass
class ByteVector():
    """
    A DDS standard container with functionality similar to a C++ vector.
    """
    def __eq__(self, arg0: rti.connextdds.ByteVector) -> bool: 
        """
        Compare ByteVectors for equality.
        """
    def __getitem__(self, arg0: int) -> int: 
        """
        Get the value at the specified index.
        """
    @typing.overload
    def __init__(self, buffer: Buffer) -> None: 
        """
        Create a ByteVector from another Python buffer.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty ByteVector
        """
    @typing.overload
    def __init__(self, size: int) -> None: 
        """
        Create a ByteVector with a preallocated size.
        """
    @typing.overload
    def __init__(self, vector: rti.connextdds.ByteVector) -> None: 
        """
        Create a copy from another ByteVector.
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, list: rti.connextdds.Uint8Seq) -> None: 
        """
        Create a ByteVector from a list of values.
        """
    def __iter__(self) -> typing.Iterator[int]: 
        """
        Iterate over the contents of the vector.
        """
    def __len__(self) -> int: 
        """
        Get the length of the ByteVector.
        """
    def __ne__(self, arg0: rti.connextdds.ByteVector) -> bool: 
        """
        Compare ByteVectors for inequality.
        """
    def __setitem__(self, arg0: int, arg1: int) -> None: 
        """
        Set the value at the specified index.
        """
    def clear(self) -> None: 
        """
        Resize ByteVector to 0.
        """
    def resize(self, size: int) -> None: 
        """
        Resize ByteVector.
        """
    __hash__: NoneType
    pass
class CdrPaddingKind():
    class CdrPaddingKind():
        """
        Members:

          ZERO : Set padding bytes to zero during CDR serialization.

          NOT_SET : Don't set padding bytes to any value.

          AUTO : Set the value automatically, depending on the Entity.

        When set on a DomainParticipant the default behavior is NOT_SET

        When set on a DataWriter or DataReader the behavior is to inherit the value from the DomainParticipant.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        AUTO: rti.connextdds.CdrPaddingKind.CdrPaddingKind
        NOT_SET: rti.connextdds.CdrPaddingKind.CdrPaddingKind
        ZERO: rti.connextdds.CdrPaddingKind.CdrPaddingKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.CdrPaddingKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.CdrPaddingKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.CdrPaddingKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.CdrPaddingKind.CdrPaddingKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.CdrPaddingKind.CdrPaddingKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.CdrPaddingKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.CdrPaddingKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.CdrPaddingKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> CdrPaddingKind.CdrPaddingKind:
        """
        Retrieves the actual enumerated value.

        :type: CdrPaddingKind.CdrPaddingKind
        """
    AUTO: rti.connextdds.CdrPaddingKind.CdrPaddingKind
    NOT_SET: rti.connextdds.CdrPaddingKind.CdrPaddingKind
    ZERO: rti.connextdds.CdrPaddingKind.CdrPaddingKind
    __hash__: NoneType
    pass
class ChannelSettings():
    def __eq__(self, arg0: rti.connextdds.ChannelSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, multicast_settings: rti.connextdds.TransportMulticastSettingsSeq, filter_expression: str, priority: int) -> None: 
        """
        Creates an instance with the specified multicast settings, filter expression and priority.
        """
    def __ne__(self, arg0: rti.connextdds.ChannelSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def filter_expression(self) -> str:
        """
        A logical expression used to determine the data that will be published in the channel.

        :type: str
        """
    @filter_expression.setter
    def filter_expression(self, arg1: str) -> None:
        """
        A logical expression used to determine the data that will be published in the channel.
        """
    @builtins.property
    def multicast_settings(self) -> TransportMulticastSettingsSeq:
        """
        A sequence of TransportMulticastSettings used to configure the multicast addresses associated with a channel.

        :type: TransportMulticastSettingsSeq
        """
    @multicast_settings.setter
    def multicast_settings(self, arg1: TransportMulticastSettingsSeq) -> None:
        """
        A sequence of TransportMulticastSettings used to configure the multicast addresses associated with a channel.
        """
    @builtins.property
    def priority(self) -> int:
        """
        Publication priority.

        :type: int
        """
    @priority.setter
    def priority(self, arg1: int) -> None:
        """
        Publication priority.
        """
    __hash__: NoneType
    pass
class ChannelSettingsSeq():
    def __add__(self, arg0: rti.connextdds.ChannelSettingsSeq) -> rti.connextdds.ChannelSettingsSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.ChannelSettings) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.ChannelSettingsSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.ChannelSettingsSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.ChannelSettings: ...
    def __iadd__(self, arg0: rti.connextdds.ChannelSettingsSeq) -> rti.connextdds.ChannelSettingsSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.ChannelSettingsSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ChannelSettingsSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.ChannelSettings]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.ChannelSettingsSeq: ...
    def __ne__(self, arg0: rti.connextdds.ChannelSettingsSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.ChannelSettingsSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.ChannelSettings) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.ChannelSettingsSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.ChannelSettings) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.ChannelSettings) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.ChannelSettingsSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.ChannelSettings) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.ChannelSettings: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.ChannelSettings: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.ChannelSettings) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class CharSeq():
    def __add__(self, arg0: rti.connextdds.CharSeq) -> rti.connextdds.CharSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: str) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.CharSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.CharSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> str: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.CharSeq) -> rti.connextdds.CharSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.CharSeq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.CharSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.CharSeq: ...
    def __ne__(self, arg0: rti.connextdds.CharSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.CharSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: str) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.CharSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: str) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: str) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.CharSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: str) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> str: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> str: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: str) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class CharType(DynamicType):
    def __eq__(self, arg0: rti.connextdds.CharType) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for CharType
        """
    def __ne__(self, arg0: rti.connextdds.CharType) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class CoherentAccess():
    def __enter__(self) -> rti.connextdds.CoherentAccess: 
        """
        Start a context managed coherent access block.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
        """
        End a context managed coherent access block.
        """
    def __init__(self, subscriber: rti.connextdds.Subscriber) -> None: 
        """
        Creating a CoherentAccess object indicates that the application is about to access the data samples in any of the DataReader objects attached to the provided Subscriber.
        """
    def end(self) -> None: 
        """
        Explicitly indicate that the application has finished accessing the data samples in DataReader objects managed by the Subscriber.
        """
    pass
class CoherentSet():
    def __enter__(self) -> rti.connextdds.CoherentSet: 
        """
        Context manage the CoherentSet.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    def __init__(self, publisher: rti.connextdds.Publisher) -> None: 
        """
        Creating a CoherentSet object indicates that the application will begin a coherent set of modifications using DataWriter objects attached to the Publisher.
        """
    def end(self) -> None: 
        """
        Explicitly terminate a coherent set initiated by the CoherentSet constructor.
        """
    pass
class CoherentSetInfo():
    def __eq__(self, arg0: rti.connextdds.CoherentSetInfo) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default CoherentSetInfo.
        """
    @typing.overload
    def __init__(self, group_guid: rti.connextdds.Guid, coherent_set_sequence_number: rti.connextdds.SequenceNumber, group_coherent_set_sequence_number: rti.connextdds.SequenceNumber, incomplete_coherent_set: bool) -> None: 
        """
        Create a CoherentSetInfo with the specified parameters.
        """
    def __ne__(self, arg0: rti.connextdds.CoherentSetInfo) -> bool: 
        """
        Test for inequality.
        """
    def __str__(self) -> str: 
        """
        Convert CoherentSetInfo to str.
        """
    @builtins.property
    def coherent_set_sequence_number(self) -> SequenceNumber:
        """
        The coherent set sequence number that identifies a sample as part of a DataWriter coherent set.

        :type: SequenceNumber
        """
    @coherent_set_sequence_number.setter
    def coherent_set_sequence_number(self, arg1: SequenceNumber) -> None:
        """
        The coherent set sequence number that identifies a sample as part of a DataWriter coherent set.
        """
    @builtins.property
    def group_coherent_set_sequence_number(self) -> SequenceNumber:
        """
        The group coherent set sequence number that identifies a sample as part of a group coherent set.

        :type: SequenceNumber
        """
    @group_coherent_set_sequence_number.setter
    def group_coherent_set_sequence_number(self, arg1: SequenceNumber) -> None:
        """
        The group coherent set sequence number that identifies a sample as part of a group coherent set.
        """
    @builtins.property
    def group_guid(self) -> Guid:
        """
        Coherent set group.

        :type: Guid
        """
    @group_guid.setter
    def group_guid(self, arg1: Guid) -> None:
        """
        Coherent set group.
        """
    @builtins.property
    def incomplete_coherent_set(self) -> bool:
        """
        The incomplete coherent set status.

        :type: bool
        """
    @incomplete_coherent_set.setter
    def incomplete_coherent_set(self, arg1: bool) -> None:
        """
        The incomplete coherent set status.
        """
    UNKNOWN: rti.connextdds.CoherentSetInfo
    __hash__: NoneType
    pass
class ArrayType(CollectionType, DynamicType):
    def __eq__(self, arg0: rti.connextdds.ArrayType) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, data_type: rti.connextdds.DynamicType, dimension: int) -> None: 
        """
        Creates a unidimensional array.
        """
    @typing.overload
    def __init__(self, data_type: rti.connextdds.DynamicType, dimensions: rti.connextdds.Int32Seq) -> None: 
        """
        Create a multidimensional array.
        """
    def __ne__(self, arg0: rti.connextdds.ArrayType) -> bool: 
        """
        Test for inequality.
        """
    def dimension(self, index: int) -> int: 
        """
        Returns the size of the ith dimension
        """
    @builtins.property
    def dimension_count(self) -> int:
        """
        Number of dimensions.

        :type: int
        """
    @builtins.property
    def total_element_count(self) -> int:
        """
        Total element count across all dimensions.

        :type: int
        """
    __hash__: NoneType
    pass
class CompressionIdMask():
    def __and__(self, arg0: rti.connextdds.CompressionIdMask) -> rti.connextdds.CompressionIdMask: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.CompressionIdMask) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.CompressionIdMask) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.CompressionIdMask) -> rti.connextdds.CompressionIdMask: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.CompressionIdMask: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a CompressionIdMask with no bits set.
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.CompressionIdMask) -> rti.connextdds.CompressionIdMask: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.CompressionIdMask: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.CompressionIdMask) -> rti.connextdds.CompressionIdMask: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.CompressionIdMask: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.CompressionIdMask) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.CompressionIdMask) -> rti.connextdds.CompressionIdMask: 
        """
        Bitwise logical OR of masks.
        """
    def __repr__(self) -> str: 
        """
        Convert mask to string.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.CompressionIdMask: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: 
        """
        Convert mask to string.
        """
    def __xor__(self, arg0: rti.connextdds.CompressionIdMask) -> rti.connextdds.CompressionIdMask: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.CompressionIdMask: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.CompressionIdMask: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.CompressionIdMask: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.CompressionIdMask: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.CompressionIdMask: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.CompressionIdMask: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ALL: rti.connextdds.CompressionIdMask
    BZIP2: rti.connextdds.CompressionIdMask
    DEFAULT_PUBLICATION: rti.connextdds.CompressionIdMask
    DEFAULT_SUBSCRIPTION: rti.connextdds.CompressionIdMask
    LZ4: rti.connextdds.CompressionIdMask
    NONE: rti.connextdds.CompressionIdMask
    ZLIB: rti.connextdds.CompressionIdMask
    __hash__: NoneType
    pass
class CompressionSettings():
    def __eq__(self, arg0: rti.connextdds.CompressionSettings) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a CompressionSettings object with default settings.
        """
    @typing.overload
    def __init__(self, compression_ids: rti.connextdds.CompressionIdMask) -> None: 
        """
        Creates an instance with the given compression_ids.
        """
    @typing.overload
    def __init__(self, compression_ids: rti.connextdds.CompressionIdMask, writer_compression_level: int, writer_compression_threshold: int) -> None: 
        """
        Creates an instance with the given compression_ids,  writer_compression_level and writer_compression_threshold.
        """
    def __ne__(self, arg0: rti.connextdds.CompressionSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def compression_ids(self) -> CompressionIdMask:
        """
        Compression ID settings.

        :type: CompressionIdMask
        """
    @compression_ids.setter
    def compression_ids(self, arg1: CompressionIdMask) -> None:
        """
        Compression ID settings.
        """
    @builtins.property
    def writer_compression_level(self) -> int:
        """
        Writer compression level.

        :type: int
        """
    @writer_compression_level.setter
    def writer_compression_level(self, arg1: int) -> None:
        """
        Writer compression level.
        """
    @builtins.property
    def writer_compression_threshold(self) -> int:
        """
        Writer compression threshold

        :type: int
        """
    @writer_compression_threshold.setter
    def writer_compression_threshold(self, arg1: int) -> None:
        """
        Writer compression threshold
        """
    COMPRESSION_LEVEL_BEST_COMPRESSION: int
    COMPRESSION_LEVEL_BEST_SPEED: int
    COMPRESSION_LEVEL_DEFAULT: int
    __hash__: NoneType
    pass
class ICondition():
    def __eq__(self, arg0: rti.connextdds.ICondition) -> bool: 
        """
        Compare Condition objects for equality.
        """
    def __ne__(self, arg0: rti.connextdds.ICondition) -> bool: 
        """
        Compare Condition objects for inequality.
        """
    def dispatch(self) -> None: 
        """
        Dispatches the functions registered with the condition.
        """
    @builtins.property
    def trigger_value(self) -> bool:
        """
        The trigger value of the condition.

        :type: bool
        """
    __hash__: NoneType
    pass
class ConditionSeq():
    def __add__(self, arg0: rti.connextdds.ConditionSeq) -> rti.connextdds.ConditionSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.Condition) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.ConditionSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.ConditionSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Condition: ...
    def __iadd__(self, arg0: rti.connextdds.ConditionSeq) -> rti.connextdds.ConditionSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.ConditionSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ConditionSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.Condition]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.ConditionSeq: ...
    def __ne__(self, arg0: rti.connextdds.ConditionSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.ConditionSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Condition) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.ConditionSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.Condition) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.Condition) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.ConditionSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.Condition) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.Condition: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.Condition: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.Condition) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class ContentFilterBase():
    pass
class ContentFilterProperty():
    def __eq__(self, arg0: rti.connextdds.ContentFilterProperty) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.ContentFilterProperty) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def content_filter_topic_name(self) -> StringSeq:
        """
        The ContentFilteredTopic filter parameters.

        :type: StringSeq
        """
    @builtins.property
    def filter_class_name(self) -> typing.Optional[str]:
        """
        Identifies the filter class this filter belongs to.

        :type: typing.Optional[str]
        """
    @builtins.property
    def filter_expression(self) -> typing.Optional[str]:
        """
        The filter expression.

        :type: typing.Optional[str]
        """
    @builtins.property
    def related_topic_name(self) -> typing.Optional[str]:
        """
        The name of the ContentFilteredTopic's related Topic.

        :type: typing.Optional[str]
        """
    __hash__: NoneType
    pass
class IEntity():
    """
    This is the abstract base class for all the DDS objects that support QoS policies, a listener and a status condition.
    """
    def __eq__(self, arg0: rti.connextdds.IEntity) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.IEntity) -> bool: 
        """
        Test for inequality.
        """
    def close(self) -> None: 
        """
        Forces the destruction of this entity.
        """
    def enable(self) -> None: 
        """
        Enables this entity (if it was created disabled).
        """
    def lock(self) -> rti.connextdds.EntityLock: 
        """
        Locks the entity and returns a Context Manager.
        """
    def retain(self) -> None: 
        """
        Disables the automatic destruction of this entity.
        """
    def unretain(self) -> None: 
        """
        Decrement the retention count.
        """
    @builtins.property
    def closed(self) -> bool:
        """
        Returns a boolean indicating if this Entity is closed.

        :type: bool
        """
    @builtins.property
    def enabled(self) -> bool:
        """
        Returns a boolean indicating if this Entity is enabled.

        :type: bool
        """
    @builtins.property
    def instance_handle(self) -> InstanceHandle:
        """
        The instance handle that represents this entity.

        :type: InstanceHandle
        """
    @builtins.property
    def status_changes(self) -> StatusMask:
        """
        The list of communication statuses that are triggered.

        :type: StatusMask
        """
    @builtins.property
    def use_count(self) -> int:
        """
        Returns the internal use count value for this Entity.

        :type: int
        """
    __hash__: NoneType
    pass
class ContentFilteredTopicSeq():
    def __add__(self, arg0: list[rti.connextdds.ContentFilteredTopic]) -> list[rti.connextdds.ContentFilteredTopic]: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.ContentFilteredTopic) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: list[rti.connextdds.ContentFilteredTopic]) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> list[rti.connextdds.ContentFilteredTopic]: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.ContentFilteredTopic: ...
    def __iadd__(self, arg0: list[rti.connextdds.ContentFilteredTopic]) -> list[rti.connextdds.ContentFilteredTopic]: ...
    def __imul__(self, arg0: int) -> list[rti.connextdds.ContentFilteredTopic]: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: list[rti.connextdds.ContentFilteredTopic]) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.ContentFilteredTopic]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> list[rti.connextdds.ContentFilteredTopic]: ...
    def __ne__(self, arg0: list[rti.connextdds.ContentFilteredTopic]) -> bool: ...
    def __rmul__(self, arg0: int) -> list[rti.connextdds.ContentFilteredTopic]: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.ContentFilteredTopic) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: list[rti.connextdds.ContentFilteredTopic]) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.ContentFilteredTopic) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.ContentFilteredTopic) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: list[rti.connextdds.ContentFilteredTopic]) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.ContentFilteredTopic) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.ContentFilteredTopic: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.ContentFilteredTopic: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.ContentFilteredTopic) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class Cookie():
    """
    Unique identifier for a written data sample in the form of a sequence of bytes.
    """
    def __eq__(self, arg0: rti.connextdds.Cookie) -> bool: 
        """
        Compare Cookies for equality
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an empty Cookie.
        """
    @typing.overload
    def __init__(self, bytes: rti.connextdds.ByteVector) -> None: 
        """
        Cookie from bytes.
        """
    def __ne__(self, arg0: rti.connextdds.Cookie) -> bool: 
        """
        Compare Cookies for inequality
        """
    @builtins.property
    def value(self) -> Uint8Seq:
        """
        Retrieve the bytes of the Cookie's contents.

        :type: Uint8Seq
        """
    __hash__: NoneType
    pass
class CookieSeq():
    def __add__(self, arg0: rti.connextdds.CookieSeq) -> rti.connextdds.CookieSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.Cookie) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.CookieSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.CookieSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Cookie: ...
    def __iadd__(self, arg0: rti.connextdds.CookieSeq) -> rti.connextdds.CookieSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.CookieSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.CookieSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.Cookie]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.CookieSeq: ...
    def __ne__(self, arg0: rti.connextdds.CookieSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.CookieSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Cookie) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.CookieSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.Cookie) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.Cookie) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.CookieSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.Cookie) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.Cookie: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.Cookie: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.Cookie) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class CookieVector():
    """
    A DDS standard container with functionality similar to a C++ vector.
    """
    def __eq__(self, arg0: rti.connextdds.CookieVector) -> bool: 
        """
        Compare CookieVectors for equality.
        """
    def __getitem__(self, arg0: int) -> rti.connextdds.Cookie: 
        """
        Get the value at the specified index.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty CookieVector
        """
    @typing.overload
    def __init__(self, size: int) -> None: 
        """
        Create a CookieVector with a preallocated size.
        """
    @typing.overload
    def __init__(self, vector: rti.connextdds.CookieVector) -> None: 
        """
        Create a copy from another CookieVector.
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, list: rti.connextdds.CookieSeq) -> None: 
        """
        Create a CookieVector from a list of values.
        """
    def __iter__(self) -> typing.Iterator[rti.connextdds.Cookie]: 
        """
        Iterate over the contents of the vector.
        """
    def __len__(self) -> int: 
        """
        Get the length of the CookieVector.
        """
    def __ne__(self, arg0: rti.connextdds.CookieVector) -> bool: 
        """
        Compare CookieVectors for inequality.
        """
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Cookie) -> None: 
        """
        Set the value at the specified index.
        """
    def clear(self) -> None: 
        """
        Resize CookieVector to 0.
        """
    def resize(self, size: int) -> None: 
        """
        Resize CookieVector.
        """
    __hash__: NoneType
    pass
class IDataReader(IEntity, IAnyDataReader):
    pass
class DataReaderCacheStatus():
    @builtins.property
    def alive_instance_count(self) -> int:
        """
        The number of instances in the DataReader's queue with an instance state equal to InstanceState.ALIVE.

        :type: int
        """
    @builtins.property
    def alive_instance_count_peak(self) -> int:
        """
        The highest value of DataReaderCacheStatus.alive_instance_count over the lifetime of the DataReader.

        :type: int
        """
    @builtins.property
    def compressed_sample_count(self) -> int:
        """
        The number of received compressed samples.

        :type: int
        """
    @builtins.property
    def content_filter_dropped_sample_count(self) -> int:
        """
        The number of user samples filtered by the DataReader due to Content-Filtered Topics.

        :type: int
        """
    @builtins.property
    def detached_instance_count(self) -> int:
        """
        The number of instances in the DataReader's queue with an instance state equal to InstanceState.NOT_ALIVE_DISPOSED.

        :type: int
        """
    @builtins.property
    def detached_instance_count_peak(self) -> int:
        """
        The highest value of DataReaderCacheStatus.detached_instance_count over the lifetime of the DataReader.

        :type: int
        """
    @builtins.property
    def disposed_instance_count(self) -> int:
        """
        The number of instances in the DataReader's queue with an instance state equal to InstanceState.NOT_ALIVE_DISPOSED.

        :type: int
        """
    @builtins.property
    def disposed_instance_count_peak(self) -> int:
        """
        The number of minimal instance states currently being maintained in the DataReader's queue.

        :type: int
        """
    @builtins.property
    def expired_dropped_sample_count(self) -> int:
        """
        The number of samples expired by the DataReader due to Lifespan QoS or the autopurge sample delays.

        :type: int
        """
    @builtins.property
    def no_writers_instance_count(self) -> int:
        """
        The number of instances in the DataReader's queue with an instance state equal to InstanceState.NOT_ALIVE_NO_WRITERS.

        :type: int
        """
    @builtins.property
    def no_writers_instance_count_peak(self) -> int:
        """
        The highest value of DataReaderCacheStatus.no_writers_instance_count over the lifetime of the DataReader.

        :type: int
        """
    @builtins.property
    def old_source_timestamp_dropped_sample_count(self) -> int:
        """
        The number of samples dropped as a result of receiving a sample older than the last one, using DestinationOrderKind.BY_SOURCE_TIMESTAMP.

        :type: int
        """
    @builtins.property
    def ownership_dropped_sample_count(self) -> int:
        """
        The number of samples dropped as a result of receiving a sample from a DataWriter with a lower strength, using Exclusive Ownership.

        :type: int
        """
    @builtins.property
    def replaced_dropped_sample_count(self) -> int:
        """
        The number of samples replaced by the DataReader due to HistoryKind.KEEP_LAST replacement.

        :type: int
        """
    @builtins.property
    def sample_count(self) -> int:
        """
        The number of samples in the DataReader's queue.

        :type: int
        """
    @builtins.property
    def sample_count_peak(self) -> int:
        """
        The highest number of samples in the DataReader's queue over the lifetime of the reader.

        :type: int
        """
    @builtins.property
    def time_based_filter_dropped_sample_count(self) -> int:
        """
        The number of user samples filtered by the DataReader due to TimeBasedFilter QoS.

        :type: int
        """
    @builtins.property
    def tolerance_source_timestamp_dropped_sample_count(self) -> int:
        """
        The number of samples dropped as a result of receiving a sample in the future, using DestinationOrderKind.BY_SOURCE_TIMESTAMP.

        :type: int
        """
    @builtins.property
    def total_samples_dropped_by_instance_replacement(self) -> int:
        """
        The number of samples with sample state SampleState.NOT_READ that were dropped when removing an instance due to instance replacement. See DataReaderResourceLimits.instance_replacement for more details about when instances are replaced.

        :type: int
        """
    @builtins.property
    def virtual_duplicate_dropped_sample_count(self) -> int:
        """
        The number of virtual duplicate samples dropped by the DataReader. A sample is a virtual duplicate if it has the same identity (Virtual Writer GUID and Virtual Sequence Number) as a previously received sample.

        :type: int
        """
    @builtins.property
    def writer_removed_batch_sample_dropped_sample_count(self) -> int:
        """
        The number of batch samples received by the DataReader that were marked as removed by the DataWriter.

        :type: int
        """
    pass
class DataReaderInstanceRemovalKind():
    class DataReaderInstanceRemovalKind():
        """
        Members:

          NO_INSTANCE : No instance can be removed.

          EMPTY_INSTANCES : Only empty instances can be removed

          FULLY_PROCESSED_INSTANCES : Only fully-processed instances can be removed.

          ANY_INSTANCE : Any instance can be removed.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        ANY_INSTANCE: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
        EMPTY_INSTANCES: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
        FULLY_PROCESSED_INSTANCES: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
        NO_INSTANCE: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.DataReaderInstanceRemovalKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.DataReaderInstanceRemovalKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.DataReaderInstanceRemovalKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.DataReaderInstanceRemovalKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.DataReaderInstanceRemovalKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.DataReaderInstanceRemovalKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind:
        """
        Retrieves the actual enumerated value.

        :type: DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
        """
    ANY_INSTANCE: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
    EMPTY_INSTANCES: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
    FULLY_PROCESSED_INSTANCES: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
    NO_INSTANCE: rti.connextdds.DataReaderInstanceRemovalKind.DataReaderInstanceRemovalKind
    __hash__: NoneType
    pass
class DataReaderListener():
    def __init__(self) -> None: ...
    def on_data_available(self, arg0: rti.connextdds.DataReader) -> None: 
        """
        Data available callback.
        """
    def on_liveliness_changed(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
        """
        Liveliness changed callback.
        """
    def on_requested_deadline_missed(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
        """
        Requested deadline missed callback.
        """
    def on_requested_incompatible_qos(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
        """
        Requested incompatible QoS callback.
        """
    def on_sample_lost(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
        """
        Sample lost callback.
        """
    def on_sample_rejected(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
        """
        Sample rejected callback.
        """
    def on_subscription_matched(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
        """
        Subscription matched callback.
        """
    pass
class DataReaderProtocol():
    def __eq__(self, arg0: rti.connextdds.DataReaderProtocol) -> bool: 
        """
        Compare for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default DataReaderProtocol policy.
        """
    def __ne__(self, arg0: rti.connextdds.DataReaderProtocol) -> bool: 
        """
        Compare for inequality.
        """
    @builtins.property
    def disable_positive_acks(self) -> bool:
        """
        Get/set the boolean for whether the reader will use send positive acknowledgments.

        :type: bool
        """
    @disable_positive_acks.setter
    def disable_positive_acks(self, arg1: bool) -> None:
        """
        Get/set the boolean for whether the reader will use send positive acknowledgments.
        """
    @builtins.property
    def expects_inline_qos(self) -> bool:
        """
        Get/set the boolean for whether the reader will expect inline QoS with each sample.

        :type: bool
        """
    @expects_inline_qos.setter
    def expects_inline_qos(self, arg1: bool) -> None:
        """
        Get/set the boolean for whether the reader will expect inline QoS with each sample.
        """
    @builtins.property
    def propagate_dispose_of_unregistered_instances(self) -> bool:
        """
        Get/set the boolean for whether an instance can move to the not_alive_disposed state without being in the alive state.

        :type: bool
        """
    @propagate_dispose_of_unregistered_instances.setter
    def propagate_dispose_of_unregistered_instances(self, arg1: bool) -> None:
        """
        Get/set the boolean for whether an instance can move to the not_alive_disposed state without being in the alive state.
        """
    @builtins.property
    def propagate_unregister_of_disposed_instances(self) -> bool:
        """
        Get/set the boolean for whether an instance can move to the not_alive_no_writers state without being in the alive state.

        :type: bool
        """
    @propagate_unregister_of_disposed_instances.setter
    def propagate_unregister_of_disposed_instances(self, arg1: bool) -> None:
        """
        Get/set the boolean for whether an instance can move to the not_alive_no_writers state without being in the alive state.
        """
    @builtins.property
    def rtps_object_id(self) -> int:
        """
        Get/set the RTPS object ID.

        :type: int
        """
    @rtps_object_id.setter
    def rtps_object_id(self, arg1: int) -> None:
        """
        Get/set the RTPS object ID.
        """
    @builtins.property
    def rtps_reliable_reader(self) -> RtpsReliableReaderProtocol:
        """
        Get/set the reliable reader protocol settings.

        :type: RtpsReliableReaderProtocol
        """
    @rtps_reliable_reader.setter
    def rtps_reliable_reader(self, arg1: RtpsReliableReaderProtocol) -> None:
        """
        Get/set the reliable reader protocol settings.
        """
    @builtins.property
    def virtual_guid(self) -> Guid:
        """
        Get/set a copy of the virtual GUID.

        :type: Guid
        """
    @virtual_guid.setter
    def virtual_guid(self, arg1: Guid) -> None:
        """
        Get/set a copy of the virtual GUID.
        """
    __hash__: NoneType
    pass
class DataReaderProtocolStatus():
    """
    Information about the DataReader's protocol status.
    """
    @builtins.property
    def dropped_fragment_count(self) -> int:
        """
        The number of DATA_FRAG messages that have been dropped by a DataReader.

        :type: int
        """
    @builtins.property
    def duplicate_sample_bytes(self) -> EventCount64:
        """
        The number of bytes of sample data from a remote DataWriter received, not for the first time, by a local DataReader.

        :type: EventCount64
        """
    @builtins.property
    def duplicate_sample_count(self) -> EventCount64:
        """
        The number of samples from a remote DataWriter received, not for the first time, by a local DataReader.

        :type: EventCount64
        """
    @builtins.property
    def first_available_sample_sequence_number(self) -> SequenceNumber:
        """
        Sequence number of the first available sample in a matched DataWriters reliability queue.

        :type: SequenceNumber
        """
    @builtins.property
    def last_available_sample_sequence_number(self) -> SequenceNumber:
        """
        Sequence number of the last available sample in a matched Datawriter's reliability queue.

        :type: SequenceNumber
        """
    @builtins.property
    def last_committed_sample_sequence_number(self) -> SequenceNumber:
        """
        Sequence number of the newest sample received from the matched DataWriter committed to the DataReader's queue.

        :type: SequenceNumber
        """
    @builtins.property
    def out_of_range_rejected_sample_count(self) -> int:
        """
        The number of samples dropped by the DataReader due to received window is full and the sample is out-of-order.

        :type: int
        """
    @builtins.property
    def reassembled_sample_count(self) -> int:
        """
        The number of fragmented samples that have been reassembled by a DataReader.

        :type: int
        """
    @builtins.property
    def received_fragment_count(self) -> int:
        """
        The number of DATA_FRAG messages that have been received by this DataReader.

        :type: int
        """
    @builtins.property
    def received_gap_bytes(self) -> EventCount64:
        """
        The number of bytes of GAP data received from remote DataWriter to this DataReader.

        :type: EventCount64
        """
    @builtins.property
    def received_gap_count(self) -> EventCount64:
        """
        The number of GAPs received from remote DataWriter to this DataReader.

        :type: EventCount64
        """
    @builtins.property
    def received_heartbeat_bytes(self) -> EventCount64:
        """
        The number of bytes of Heartbeat data from a remote DataWriter received by a local DataReader.

        :type: EventCount64
        """
    @builtins.property
    def received_heartbeat_count(self) -> EventCount64:
        """
        The number of Heartbeats from a remote DataWriter received by a local DataReader.

        :type: EventCount64
        """
    @builtins.property
    def received_sample_bytes(self) -> EventCount64:
        """
        The number of bytes from samples received by a DataReader.

        :type: EventCount64
        """
    @builtins.property
    def received_sample_count(self) -> EventCount64:
        """
        The number of samples received by a DataReader.

        :type: EventCount64
        """
    @builtins.property
    def rejected_sample_count(self) -> EventCount64:
        """
        The number of times samples were rejected due to exceptions in the receive path.

        :type: EventCount64
        """
    @builtins.property
    def sent_ack_bytes(self) -> EventCount64:
        """
        The number of bytes of ACK data sent from a local DataReader to a matching remote DataWriter.

        :type: EventCount64
        """
    @builtins.property
    def sent_ack_count(self) -> EventCount64:
        """
        The number of ACKs sent from a local DataReader to a matching remote DataWriter.

        :type: EventCount64
        """
    @builtins.property
    def sent_nack_bytes(self) -> EventCount64:
        """
        The number of bytes of NACK data sent from a local DataReader to a matching remote DataWriter.

        :type: EventCount64
        """
    @builtins.property
    def sent_nack_count(self) -> EventCount64:
        """
        The number of NACKs sent from a local DataReader to a matching remote DataWriter.

        :type: EventCount64
        """
    @builtins.property
    def sent_nack_fragment_bytes(self) -> int:
        """
        The number of NACK fragment bytes that have been sent from a DataReader to a DataWriter.

        :type: int
        """
    @builtins.property
    def sent_nack_fragment_count(self) -> int:
        """
        The number of NACK fragments that have been sent from a DataReader to a DataWriter.

        :type: int
        """
    @builtins.property
    def uncommitted_sample_count(self) -> int:
        """
        Number of received samples that are not yet available to be read or taken, due to being received out of order.

        :type: int
        """
    pass
class DataReaderQos():
    def __eq__(self, arg0: rti.connextdds.DataReaderQos) -> bool: 
        """
        Test for equality
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a DataReaderQos with the default value for each policy.
        """
    @typing.overload
    def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
        """
        Create a DataReaderQos with settings equivalent to those of the provided DataReader.
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.DataReaderQos) -> None: 
        """
        Create a copy of a DataReaderQos object.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Durability) -> rti.connextdds.DataReaderQos: 
        """
        Set the DurabilityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Deadline) -> rti.connextdds.DataReaderQos: 
        """
        Set the DeadlineQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.LatencyBudget) -> rti.connextdds.DataReaderQos: 
        """
        Set the LatencyBudgetQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Liveliness) -> rti.connextdds.DataReaderQos: 
        """
        Set the LivelinessQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Reliability) -> rti.connextdds.DataReaderQos: 
        """
        Set the ReliabilityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DestinationOrder) -> rti.connextdds.DataReaderQos: 
        """
        Set the DestinationOrderQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.History) -> rti.connextdds.DataReaderQos: 
        """
        Set the HistoryQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.ResourceLimits) -> rti.connextdds.DataReaderQos: 
        """
        Set the ResourceLimitsQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.UserData) -> rti.connextdds.DataReaderQos: 
        """
        Set the UserDataQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Ownership) -> rti.connextdds.DataReaderQos: 
        """
        Set the OwnershipQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TimeBasedFilter) -> rti.connextdds.DataReaderQos: 
        """
        Set the TimeBasedFilterQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.ReaderDataLifecycle) -> rti.connextdds.DataReaderQos: 
        """
        Set the ReaderDataLifecycleQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportPriority) -> rti.connextdds.DataReaderQos: 
        """
        Set the TransportPriorityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TypeConsistencyEnforcement) -> rti.connextdds.DataReaderQos: 
        """
        Set the TypeConsistencyEnforcementQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataReaderResourceLimits) -> rti.connextdds.DataReaderQos: 
        """
        Set the DataReaderResourceLimitsQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataReaderProtocol) -> rti.connextdds.DataReaderQos: 
        """
        Set the DataReaderProtocolQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportSelection) -> rti.connextdds.DataReaderQos: 
        """
        Set the TransportSelectionQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportUnicast) -> rti.connextdds.DataReaderQos: 
        """
        Set the TransportUnicastQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportMulticast) -> rti.connextdds.DataReaderQos: 
        """
        Set the TransportMulticastQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Property) -> rti.connextdds.DataReaderQos: 
        """
        Set the PropertyQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Service) -> rti.connextdds.DataReaderQos: 
        """
        Set the ServiceQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Availability) -> rti.connextdds.DataReaderQos: 
        """
        Set the AvailabilityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.DataReaderQos: 
        """
        Set the EntityNameQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TypeSupport) -> rti.connextdds.DataReaderQos: 
        """
        Set the TypeSupportQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataRepresentation) -> rti.connextdds.DataReaderQos: 
        """
        Set the DataRepresentationQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataTag) -> rti.connextdds.DataReaderQos: 
        """
        Set the DataTagQoS.
        """
    def __ne__(self, arg0: rti.connextdds.DataReaderQos) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Durability) -> rti.connextdds.DataReaderQos: 
        """
        Get the DurabilityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Deadline) -> rti.connextdds.DataReaderQos: 
        """
        Get the DeadlineQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.LatencyBudget) -> rti.connextdds.DataReaderQos: 
        """
        Get the LatencyBudgetQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Liveliness) -> rti.connextdds.DataReaderQos: 
        """
        Get the LivelinessQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Reliability) -> rti.connextdds.DataReaderQos: 
        """
        Get the ReliabilityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DestinationOrder) -> rti.connextdds.DataReaderQos: 
        """
        Get the DestinationOrderQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.History) -> rti.connextdds.DataReaderQos: 
        """
        Get the HistoryQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.ResourceLimits) -> rti.connextdds.DataReaderQos: 
        """
        Get the ResourceLimitsQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.UserData) -> rti.connextdds.DataReaderQos: 
        """
        Get the UserDataQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Ownership) -> rti.connextdds.DataReaderQos: 
        """
        Get the OwnershipQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TimeBasedFilter) -> rti.connextdds.DataReaderQos: 
        """
        Get the TimeBasedFilterQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.ReaderDataLifecycle) -> rti.connextdds.DataReaderQos: 
        """
        Get the ReaderDataLifecycleQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportPriority) -> rti.connextdds.DataReaderQos: 
        """
        Get the TransportPriorityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TypeConsistencyEnforcement) -> rti.connextdds.DataReaderQos: 
        """
        Get the TypeConsistencyEnforcementQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataReaderResourceLimits) -> rti.connextdds.DataReaderQos: 
        """
        Get the DataReaderResourceLimitsQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataReaderProtocol) -> rti.connextdds.DataReaderQos: 
        """
        Get the DataReaderProtocolQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportSelection) -> rti.connextdds.DataReaderQos: 
        """
        Get the TransportSelectionQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportUnicast) -> rti.connextdds.DataReaderQos: 
        """
        Get the TransportUnicastQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportMulticast) -> rti.connextdds.DataReaderQos: 
        """
        Get the TransportMulticastQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Property) -> rti.connextdds.DataReaderQos: 
        """
        Get the PropertyQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Service) -> rti.connextdds.DataReaderQos: 
        """
        Get the ServiceQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Availability) -> rti.connextdds.DataReaderQos: 
        """
        Get the AvailabilityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.DataReaderQos: 
        """
        Get the EntityNameQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TypeSupport) -> rti.connextdds.DataReaderQos: 
        """
        Get the TypeSupportQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataRepresentation) -> rti.connextdds.DataReaderQos: 
        """
        Get the DataRepresentationQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataTag) -> rti.connextdds.DataReaderQos: 
        """
        Get the DataTagQoS.
        """
    def __str__(self) -> str: ...
    def to_string(self, format: rti.connextdds.QosPrintFormat = QosPrintFormat(), base: typing.Optional[rti.connextdds.DataReaderQos] = None, print_all: bool = False) -> str: 
        """
        Convert QoS to string based on params.
        """
    @builtins.property
    def availability(self) -> Availability:
        """
        Get/set Availability QoS.

        :type: Availability
        """
    @availability.setter
    def availability(self, arg1: Availability) -> None:
        """
        Get/set Availability QoS.
        """
    @builtins.property
    def data_reader_protocol(self) -> DataReaderProtocol:
        """
        (Deprecated) use protocol instead

        :type: DataReaderProtocol
        """
    @data_reader_protocol.setter
    def data_reader_protocol(self, arg1: DataReaderProtocol) -> None:
        """
        (Deprecated) use protocol instead
        """
    @builtins.property
    def data_reader_resource_limits(self) -> DataReaderResourceLimits:
        """
        (Deprecated) use reader_resource_limits instead

        :type: DataReaderResourceLimits
        """
    @data_reader_resource_limits.setter
    def data_reader_resource_limits(self, arg1: DataReaderResourceLimits) -> None:
        """
        (Deprecated) use reader_resource_limits instead
        """
    @builtins.property
    def data_representation(self) -> DataRepresentation:
        """
        Get/set DataRepresentation QoS.

        :type: DataRepresentation
        """
    @data_representation.setter
    def data_representation(self, arg1: DataRepresentation) -> None:
        """
        Get/set DataRepresentation QoS.
        """
    @builtins.property
    def data_tag(self) -> DataTag:
        """
        Get/set DataTag QoS.

        :type: DataTag
        """
    @data_tag.setter
    def data_tag(self, arg1: DataTag) -> None:
        """
        Get/set DataTag QoS.
        """
    @builtins.property
    def deadline(self) -> Deadline:
        """
        Get/set Deadline QoS.

        :type: Deadline
        """
    @deadline.setter
    def deadline(self, arg1: Deadline) -> None:
        """
        Get/set Deadline QoS.
        """
    @builtins.property
    def destination_order(self) -> DestinationOrder:
        """
        Get/set DestinationOrder QoS.

        :type: DestinationOrder
        """
    @destination_order.setter
    def destination_order(self, arg1: DestinationOrder) -> None:
        """
        Get/set DestinationOrder QoS.
        """
    @builtins.property
    def durability(self) -> Durability:
        """
        Get/set Durability QoS.

        :type: Durability
        """
    @durability.setter
    def durability(self, arg1: Durability) -> None:
        """
        Get/set Durability QoS.
        """
    @builtins.property
    def entity_name(self) -> EntityName:
        """
        Get/set EntityName QoS.

        :type: EntityName
        """
    @entity_name.setter
    def entity_name(self, arg1: EntityName) -> None:
        """
        Get/set EntityName QoS.
        """
    @builtins.property
    def history(self) -> History:
        """
        Get/set History QoS.

        :type: History
        """
    @history.setter
    def history(self, arg1: History) -> None:
        """
        Get/set History QoS.
        """
    @builtins.property
    def latency_budget(self) -> LatencyBudget:
        """
        Get/set LatencyBudget QoS.

        :type: LatencyBudget
        """
    @latency_budget.setter
    def latency_budget(self, arg1: LatencyBudget) -> None:
        """
        Get/set LatencyBudget QoS.
        """
    @builtins.property
    def liveliness(self) -> Liveliness:
        """
        Get/set Liveliness QoS.

        :type: Liveliness
        """
    @liveliness.setter
    def liveliness(self, arg1: Liveliness) -> None:
        """
        Get/set Liveliness QoS.
        """
    @builtins.property
    def ownership(self) -> Ownership:
        """
        Get/set Ownership QoS.

        :type: Ownership
        """
    @ownership.setter
    def ownership(self, arg1: Ownership) -> None:
        """
        Get/set Ownership QoS.
        """
    @builtins.property
    def property(self) -> Property:
        """
        Get/set Property QoS.

        :type: Property
        """
    @property.setter
    def property(self, arg1: Property) -> None:
        """
        Get/set Property QoS.
        """
    @builtins.property
    def protocol(self) -> DataReaderProtocol:
        """
        Get/set DataReaderProtocol QoS.

        :type: DataReaderProtocol
        """
    @protocol.setter
    def protocol(self, arg1: DataReaderProtocol) -> None:
        """
        Get/set DataReaderProtocol QoS.
        """
    @builtins.property
    def reader_data_lifecycle(self) -> ReaderDataLifecycle:
        """
        Get/set ReaderDataLifecycle QoS.

        :type: ReaderDataLifecycle
        """
    @reader_data_lifecycle.setter
    def reader_data_lifecycle(self, arg1: ReaderDataLifecycle) -> None:
        """
        Get/set ReaderDataLifecycle QoS.
        """
    @builtins.property
    def reader_resource_limits(self) -> DataReaderResourceLimits:
        """
        Get/set DataReaderResourceLimits QoS.

        :type: DataReaderResourceLimits
        """
    @reader_resource_limits.setter
    def reader_resource_limits(self, arg1: DataReaderResourceLimits) -> None:
        """
        Get/set DataReaderResourceLimits QoS.
        """
    @builtins.property
    def reliability(self) -> Reliability:
        """
        Get/set Reliability QoS.

        :type: Reliability
        """
    @reliability.setter
    def reliability(self, arg1: Reliability) -> None:
        """
        Get/set Reliability QoS.
        """
    @builtins.property
    def resource_limits(self) -> ResourceLimits:
        """
        Get/set ResourceLimits QoS.

        :type: ResourceLimits
        """
    @resource_limits.setter
    def resource_limits(self, arg1: ResourceLimits) -> None:
        """
        Get/set ResourceLimits QoS.
        """
    @builtins.property
    def service(self) -> Service:
        """
        Get/set Service QoS.

        :type: Service
        """
    @service.setter
    def service(self, arg1: Service) -> None:
        """
        Get/set Service QoS.
        """
    @builtins.property
    def time_based_filter(self) -> TimeBasedFilter:
        """
        Get/set TimeBasedFilter QoS.

        :type: TimeBasedFilter
        """
    @time_based_filter.setter
    def time_based_filter(self, arg1: TimeBasedFilter) -> None:
        """
        Get/set TimeBasedFilter QoS.
        """
    @builtins.property
    def transport_multicast(self) -> TransportMulticast:
        """
        Get/set TransportMulticast QoS.

        :type: TransportMulticast
        """
    @transport_multicast.setter
    def transport_multicast(self, arg1: TransportMulticast) -> None:
        """
        Get/set TransportMulticast QoS.
        """
    @builtins.property
    def transport_priority(self) -> TransportPriority:
        """
        Get/set TransportPriority QoS.

        :type: TransportPriority
        """
    @transport_priority.setter
    def transport_priority(self, arg1: TransportPriority) -> None:
        """
        Get/set TransportPriority QoS.
        """
    @builtins.property
    def transport_selection(self) -> TransportSelection:
        """
        Get/set TransportSelection QoS.

        :type: TransportSelection
        """
    @transport_selection.setter
    def transport_selection(self, arg1: TransportSelection) -> None:
        """
        Get/set TransportSelection QoS.
        """
    @builtins.property
    def transport_unicast(self) -> TransportUnicast:
        """
        Get/set TransportUnicast QoS.

        :type: TransportUnicast
        """
    @transport_unicast.setter
    def transport_unicast(self, arg1: TransportUnicast) -> None:
        """
        Get/set TransportUnicast QoS.
        """
    @builtins.property
    def type_consistency(self) -> TypeConsistencyEnforcement:
        """
        Get/set TypeConsistencyEnforcement QoS.

        :type: TypeConsistencyEnforcement
        """
    @type_consistency.setter
    def type_consistency(self, arg1: TypeConsistencyEnforcement) -> None:
        """
        Get/set TypeConsistencyEnforcement QoS.
        """
    @builtins.property
    def type_consistency_enforcement(self) -> TypeConsistencyEnforcement:
        """
        (Deprecated) use type_consistency instead

        :type: TypeConsistencyEnforcement
        """
    @type_consistency_enforcement.setter
    def type_consistency_enforcement(self, arg1: TypeConsistencyEnforcement) -> None:
        """
        (Deprecated) use type_consistency instead
        """
    @builtins.property
    def type_support(self) -> TypeSupport:
        """
        Get/set TypeSupport QoS.

        :type: TypeSupport
        """
    @type_support.setter
    def type_support(self, arg1: TypeSupport) -> None:
        """
        Get/set TypeSupport QoS.
        """
    @builtins.property
    def user_data(self) -> UserData:
        """
        Get/set UserData QoS.

        :type: UserData
        """
    @user_data.setter
    def user_data(self, arg1: UserData) -> None:
        """
        Get/set UserData QoS.
        """
    __hash__: NoneType
    pass
class DataReaderResourceLimits():
    def __eq__(self, arg0: rti.connextdds.DataReaderResourceLimits) -> bool: ...
    def __init__(self) -> None: 
        """
        Create a default DataReaderResourceLimits policy with default settings.
        """
    def __ne__(self, arg0: rti.connextdds.DataReaderResourceLimits) -> bool: ...
    @builtins.property
    def autopurge_remote_not_alive_writer_delay(self) -> Duration:
        """
        Maximum duration for which the DataReader will maintain information regarding a DataWriter once the DataWriter has become not alive.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @autopurge_remote_not_alive_writer_delay.setter
    def autopurge_remote_not_alive_writer_delay(self, arg1: Duration) -> None:
        """
        Maximum duration for which the DataReader will maintain information regarding a DataWriter once the DataWriter has become not alive.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def autopurge_remote_virtual_writer_delay(self) -> Duration:
        """
        Maximum duration for which the DataReader will maintain information regarding a virtual DataWriter once it has become not alive.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @autopurge_remote_virtual_writer_delay.setter
    def autopurge_remote_virtual_writer_delay(self, arg1: Duration) -> None:
        """
        Maximum duration for which the DataReader will maintain information regarding a virtual DataWriter once it has become not alive.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def disable_fragmentation_support(self) -> bool:
        """
        Determines whether the DataReader can receive fragmented samples.

        :type: bool
        """
    @disable_fragmentation_support.setter
    def disable_fragmentation_support(self, arg1: bool) -> None:
        """
        Determines whether the DataReader can receive fragmented samples.
        """
    @builtins.property
    def dynamically_allocate_fragmented_samples(self) -> bool:
        """
        Determines whether the DataReader pre-allocates storage for storing fragmented samples.

        :type: bool
        """
    @dynamically_allocate_fragmented_samples.setter
    def dynamically_allocate_fragmented_samples(self, arg1: bool) -> None:
        """
        Determines whether the DataReader pre-allocates storage for storing fragmented samples.
        """
    @builtins.property
    def initial_fragmented_samples(self) -> int:
        """
        The initial number of samples for which a DataReader may store fragments.

        :type: int
        """
    @initial_fragmented_samples.setter
    def initial_fragmented_samples(self, arg1: int) -> None:
        """
        The initial number of samples for which a DataReader may store fragments.
        """
    @builtins.property
    def initial_infos(self) -> int:
        """
        The initial number of info units that a DataReader can use to store SampleInfo.

        :type: int
        """
    @initial_infos.setter
    def initial_infos(self, arg1: int) -> None:
        """
        The initial number of info units that a DataReader can use to store SampleInfo.
        """
    @builtins.property
    def initial_outstanding_reads(self) -> int:
        """
        The initial number of outstanding calls to read/take (or one of their variants) on the same DataReader for which memory has not been returned by calling LoanedSamples.return_loan().

        :type: int
        """
    @initial_outstanding_reads.setter
    def initial_outstanding_reads(self, arg1: int) -> None:
        """
        The initial number of outstanding calls to read/take (or one of their variants) on the same DataReader for which memory has not been returned by calling LoanedSamples.return_loan().
        """
    @builtins.property
    def initial_remote_virtual_writers(self) -> int:
        """
        The initial number of remote virtual writers from which a DataReader may read, including all instances.

        :type: int
        """
    @initial_remote_virtual_writers.setter
    def initial_remote_virtual_writers(self, arg1: int) -> None:
        """
        The initial number of remote virtual writers from which a DataReader may read, including all instances.
        """
    @builtins.property
    def initial_remote_virtual_writers_per_instance(self) -> int:
        """
        The initial number of virtual remote writers that can be associated with an instance.

        :type: int
        """
    @initial_remote_virtual_writers_per_instance.setter
    def initial_remote_virtual_writers_per_instance(self, arg1: int) -> None:
        """
        The initial number of virtual remote writers that can be associated with an instance.
        """
    @builtins.property
    def initial_remote_writers(self) -> int:
        """
        The initial number of remote writers from which a DataReader may read, including all instances.

        :type: int
        """
    @initial_remote_writers.setter
    def initial_remote_writers(self, arg1: int) -> None:
        """
        The initial number of remote writers from which a DataReader may read, including all instances.
        """
    @builtins.property
    def initial_remote_writers_per_instance(self) -> int:
        """
        The initial number of remote writers from which a DataReader may read a single instance.

        :type: int
        """
    @initial_remote_writers_per_instance.setter
    def initial_remote_writers_per_instance(self, arg1: int) -> None:
        """
        The initial number of remote writers from which a DataReader may read a single instance.
        """
    @builtins.property
    def initial_topic_queries(self) -> int:
        """
        The initial number of TopicQueries allocated by a DataReader.

        :type: int
        """
    @initial_topic_queries.setter
    def initial_topic_queries(self, arg1: int) -> None:
        """
        The initial number of TopicQueries allocated by a DataReader.
        """
    @builtins.property
    def instance_replacement(self) -> DataReaderResourceLimitsInstanceReplacementSettings:
        """
        The instance replacement policy.

        :type: DataReaderResourceLimitsInstanceReplacementSettings
        """
    @instance_replacement.setter
    def instance_replacement(self, arg1: DataReaderResourceLimitsInstanceReplacementSettings) -> None:
        """
        The instance replacement policy.
        """
    @builtins.property
    def keep_minimum_state_for_instances(self) -> bool:
        """
        Whether or not keep a minimum instance state for up to DataReaderResourceLimits.max_total_instances.

        :type: bool
        """
    @keep_minimum_state_for_instances.setter
    def keep_minimum_state_for_instances(self, arg1: bool) -> None:
        """
        Whether or not keep a minimum instance state for up to DataReaderResourceLimits.max_total_instances.
        """
    @builtins.property
    def max_app_ack_response_length(self) -> int:
        """
        Maximum length of application-level acknowledgment response data.

        :type: int
        """
    @max_app_ack_response_length.setter
    def max_app_ack_response_length(self, arg1: int) -> None:
        """
        Maximum length of application-level acknowledgment response data.
        """
    @builtins.property
    def max_fragmented_samples(self) -> int:
        """
        The maximum number of samples for which the DataReader may store fragments at a given point in time.

        :type: int
        """
    @max_fragmented_samples.setter
    def max_fragmented_samples(self, arg1: int) -> None:
        """
        The maximum number of samples for which the DataReader may store fragments at a given point in time.
        """
    @builtins.property
    def max_fragmented_samples_per_remote_writer(self) -> int:
        """
        The maximum number of samples per remote writer for which a DataReader may store fragments.

        :type: int
        """
    @max_fragmented_samples_per_remote_writer.setter
    def max_fragmented_samples_per_remote_writer(self, arg1: int) -> None:
        """
        The maximum number of samples per remote writer for which a DataReader may store fragments.
        """
    @builtins.property
    def max_fragments_per_sample(self) -> int:
        """
        Maximum number of fragments for a single sample.

        :type: int
        """
    @max_fragments_per_sample.setter
    def max_fragments_per_sample(self, arg1: int) -> None:
        """
        Maximum number of fragments for a single sample.
        """
    @builtins.property
    def max_infos(self) -> int:
        """
        The maximum number of info units that a DataReader can use to store SampleInfo.

        :type: int
        """
    @max_infos.setter
    def max_infos(self, arg1: int) -> None:
        """
        The maximum number of info units that a DataReader can use to store SampleInfo.
        """
    @builtins.property
    def max_outstanding_reads(self) -> int:
        """
        The max number of outstanding calls to read/take (or one of their variants) on the same DataReader for which memory has not been returned by calling LoanedSamples.return_loan().

        :type: int
        """
    @max_outstanding_reads.setter
    def max_outstanding_reads(self, arg1: int) -> None:
        """
        The max number of outstanding calls to read/take (or one of their variants) on the same DataReader for which memory has not been returned by calling LoanedSamples.return_loan().
        """
    @builtins.property
    def max_query_condition_filters(self) -> int:
        """
        The maximum number of query condition filters a reader is allowed.

        :type: int
        """
    @max_query_condition_filters.setter
    def max_query_condition_filters(self, arg1: int) -> None:
        """
        The maximum number of query condition filters a reader is allowed.
        """
    @builtins.property
    def max_remote_virtual_writers(self) -> int:
        """
        The maximum number of remote virtual writers from which a DataReader may read, including all instances.

        :type: int
        """
    @max_remote_virtual_writers.setter
    def max_remote_virtual_writers(self, arg1: int) -> None:
        """
        The maximum number of remote virtual writers from which a DataReader may read, including all instances.
        """
    @builtins.property
    def max_remote_virtual_writers_per_instance(self) -> int:
        """
        The maximum number of virtual remote writers that can be associated with an instance.

        :type: int
        """
    @max_remote_virtual_writers_per_instance.setter
    def max_remote_virtual_writers_per_instance(self, arg1: int) -> None:
        """
        The maximum number of virtual remote writers that can be associated with an instance.
        """
    @builtins.property
    def max_remote_writers(self) -> int:
        """
        The maximum number of remote writers from which a DataReader may read, including all instances.

        :type: int
        """
    @max_remote_writers.setter
    def max_remote_writers(self, arg1: int) -> None:
        """
        The maximum number of remote writers from which a DataReader may read, including all instances.
        """
    @builtins.property
    def max_remote_writers_per_instance(self) -> int:
        """
        The maximum number of remote writers from which a DataReadermay read a single instance.

        :type: int
        """
    @max_remote_writers_per_instance.setter
    def max_remote_writers_per_instance(self, arg1: int) -> None:
        """
        The maximum number of remote writers from which a DataReadermay read a single instance.
        """
    @builtins.property
    def max_remote_writers_per_sample(self) -> int:
        """
        The maximum number of remote writers allowed to write the same sample.

        :type: int
        """
    @max_remote_writers_per_sample.setter
    def max_remote_writers_per_sample(self, arg1: int) -> None:
        """
        The maximum number of remote writers allowed to write the same sample.
        """
    @builtins.property
    def max_samples_per_read(self) -> int:
        """
        The maximum number of data samples that the application can receive from the middleware in a single call to DataReader.read() or DataReader.take(). If more data exists in the middleware, the application will need to issue multiple read/take calls.

        :type: int
        """
    @max_samples_per_read.setter
    def max_samples_per_read(self, arg1: int) -> None:
        """
        The maximum number of data samples that the application can receive from the middleware in a single call to DataReader.read() or DataReader.take(). If more data exists in the middleware, the application will need to issue multiple read/take calls.
        """
    @builtins.property
    def max_samples_per_remote_writer(self) -> int:
        """
        The maximum number of out-of-order samples from a given remote DataWriter that a DataReader may store when maintaining a reliable connection to the DataWriter.

        :type: int
        """
    @max_samples_per_remote_writer.setter
    def max_samples_per_remote_writer(self, arg1: int) -> None:
        """
        The maximum number of out-of-order samples from a given remote DataWriter that a DataReader may store when maintaining a reliable connection to the DataWriter.
        """
    @builtins.property
    def max_topic_queries(self) -> int:
        """
        The maximum number of TopicQueries allocated by a DataReader.

        :type: int
        """
    @max_topic_queries.setter
    def max_topic_queries(self, arg1: int) -> None:
        """
        The maximum number of TopicQueries allocated by a DataReader.
        """
    @builtins.property
    def max_total_instances(self) -> int:
        """
        Maximum number of instances for which a DataReader will keep state.

        :type: int
        """
    @max_total_instances.setter
    def max_total_instances(self, arg1: int) -> None:
        """
        Maximum number of instances for which a DataReader will keep state.
        """
    @builtins.property
    def shmem_ref_transfer_mode_attached_segment_allocation(self) -> AllocationSettings:
        """
        The initial number of TopicQueries allocated by a DataReader.

        :type: AllocationSettings
        """
    @shmem_ref_transfer_mode_attached_segment_allocation.setter
    def shmem_ref_transfer_mode_attached_segment_allocation(self, arg1: AllocationSettings) -> None:
        """
        The initial number of TopicQueries allocated by a DataReader.
        """
    AUTO_MAX_TOTAL_INSTANCES: int
    __hash__: NoneType
    pass
class DataReaderResourceLimitsInstanceReplacementSettings():
    def __eq__(self, arg0: rti.connextdds.DataReaderResourceLimitsInstanceReplacementSettings) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an instance with the default removal kind for each instance state.
        """
    @typing.overload
    def __init__(self, alive_instance_removal: rti.connextdds.DataReaderInstanceRemovalKind, disposed_instance_removal: rti.connextdds.DataReaderInstanceRemovalKind, no_writers_instance_removal: rti.connextdds.DataReaderInstanceRemovalKind) -> None: 
        """
        Creates an instance with the given DataReaderInstanceRemovalKind for alive, disposed and no_writers instances, respectively.
        """
    def __ne__(self, arg0: rti.connextdds.DataReaderResourceLimitsInstanceReplacementSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def alive_instance_removal(self) -> DataReaderInstanceRemovalKind:
        """
        The instance replacment policy for alive instances.

        :type: DataReaderInstanceRemovalKind
        """
    @alive_instance_removal.setter
    def alive_instance_removal(self, arg1: DataReaderInstanceRemovalKind) -> None:
        """
        The instance replacment policy for alive instances.
        """
    @builtins.property
    def disposed_instance_removal(self) -> DataReaderInstanceRemovalKind:
        """
        The instance replacment policy for disposed instances.

        :type: DataReaderInstanceRemovalKind
        """
    @disposed_instance_removal.setter
    def disposed_instance_removal(self, arg1: DataReaderInstanceRemovalKind) -> None:
        """
        The instance replacment policy for disposed instances.
        """
    @builtins.property
    def no_writers_instance_removal(self) -> DataReaderInstanceRemovalKind:
        """
        The instance replacment policy for not-alive-no-writer instances.

        :type: DataReaderInstanceRemovalKind
        """
    @no_writers_instance_removal.setter
    def no_writers_instance_removal(self, arg1: DataReaderInstanceRemovalKind) -> None:
        """
        The instance replacment policy for not-alive-no-writer instances.
        """
    __hash__: NoneType
    pass
class DataReaderSeq():
    def __add__(self, arg0: list[rti.connextdds.DataReader]) -> list[rti.connextdds.DataReader]: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.DataReader) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: list[rti.connextdds.DataReader]) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> list[rti.connextdds.DataReader]: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.DataReader: ...
    def __iadd__(self, arg0: list[rti.connextdds.DataReader]) -> list[rti.connextdds.DataReader]: ...
    def __imul__(self, arg0: int) -> list[rti.connextdds.DataReader]: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: list[rti.connextdds.DataReader]) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.DataReader]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> list[rti.connextdds.DataReader]: ...
    def __ne__(self, arg0: list[rti.connextdds.DataReader]) -> bool: ...
    def __rmul__(self, arg0: int) -> list[rti.connextdds.DataReader]: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.DataReader) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: list[rti.connextdds.DataReader]) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.DataReader) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.DataReader) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: list[rti.connextdds.DataReader]) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.DataReader) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.DataReader: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.DataReader: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.DataReader) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class DataRepresentation():
    def __eq__(self, arg0: rti.connextdds.DataRepresentation) -> bool: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an instance with one element, AUTO_ID.
        """
    @typing.overload
    def __init__(self, representations: rti.connextdds.Int16Seq) -> None: 
        """
        Creates an instance with a sequence of Data Representation IDs.
        """
    def __ne__(self, arg0: rti.connextdds.DataRepresentation) -> bool: ...
    @builtins.property
    def compression_settings(self) -> CompressionSettings:
        """
        The compression settings.

        :type: CompressionSettings
        """
    @compression_settings.setter
    def compression_settings(self, arg1: CompressionSettings) -> None:
        """
        The compression settings.
        """
    @builtins.property
    def value(self) -> Int16Seq:
        """
        A sequence of IDs representing the allowed data representations. 

        This property uses copy semantics. Changes to the sequence are not reflected in the policy unless the sequence is commited back to the policy object via the property's setter.

        :type: Int16Seq
        """
    @value.setter
    def value(self, arg1: Int16Seq) -> None:
        """
        A sequence of IDs representing the allowed data representations. 

        This property uses copy semantics. Changes to the sequence are not reflected in the policy unless the sequence is commited back to the policy object via the property's setter.
        """
    AUTO_ID: int
    XCDR: int
    XCDR2: int
    XML: int
    __hash__: NoneType
    pass
class DataState():
    def __eq__(self, arg0: rti.connextdds.DataState) -> bool: 
        """
        Compare DataState objects for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a DataState with InstanceState.any(), ViewState.any(), and SampleState.ANY
        """
    @typing.overload
    def __init__(self, sample_state: rti.connextdds.SampleState) -> None: 
        """
        Create a DataState with InstanceState.any(), ViewState.any(), and the provided SampleState.
        """
    @typing.overload
    def __init__(self, view_state: rti.connextdds.ViewState) -> None: 
        """
        Create a DataState with InstanceState.any(), SampleState.any(), and the provided ViewState.
        """
    @typing.overload
    def __init__(self, instance_state: rti.connextdds.InstanceState) -> None: 
        """
        Create a DataState with ViewState.any(), SampleState.any(), and the provided InstanceState.
        """
    @typing.overload
    def __init__(self, sample_state: rti.connextdds.SampleState, view_state: rti.connextdds.ViewState, instance_state: rti.connextdds.InstanceState) -> None: 
        """
        Create a DataState with the provided SampleState, ViewState, and InstanceState.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.SampleState) -> rti.connextdds.DataState: 
        """
        Set the SampleState for the DataState.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.ViewState) -> rti.connextdds.DataState: 
        """
        Set the ViewState for the DataState.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.InstanceState) -> rti.connextdds.DataState: 
        """
        Set the InstanceState for the DataState.
        """
    def __ne__(self, arg0: rti.connextdds.DataState) -> bool: 
        """
        Compare DataState objects for inequality.
        """
    def __repr__(self) -> str: ...
    @builtins.property
    def instance_state(self) -> InstanceState:
        """
        The InstanceState of the DataState.

        :type: InstanceState
        """
    @instance_state.setter
    def instance_state(self, arg1: InstanceState) -> None:
        """
        The InstanceState of the DataState.
        """
    @builtins.property
    def sample_state(self) -> SampleState:
        """
        The SampleState of the DataState.

        :type: SampleState
        """
    @sample_state.setter
    def sample_state(self, arg1: SampleState) -> None:
        """
        The SampleState of the DataState.
        """
    @builtins.property
    def view_state(self) -> ViewState:
        """
        The ViewState of the DataState.

        :type: ViewState
        """
    @view_state.setter
    def view_state(self, arg1: ViewState) -> None:
        """
        The ViewState of the DataState.
        """
    __hash__: NoneType
    any: rti.connextdds.DataState
    any_data: rti.connextdds.DataState
    new_data: rti.connextdds.DataState
    new_instance: rti.connextdds.DataState
    pass
class DataStateEx():
    def __eq__(self, arg0: rti.connextdds.DataStateEx) -> bool: 
        """
        Compare DataStateEx objects for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a DataStateEx with InstanceState.ANY, ViewState.ANY, SampleState.ANY, and StreamKind.ANY.
        """
    @typing.overload
    def __init__(self, stream_kind: rti.connextdds.StreamKind) -> None: 
        """
        Create a DataStateEx with InstanceState.ANY, ViewState.ANY, SampleState.ANY and the provided StreamKind.
        """
    @typing.overload
    def __init__(self, data_state: rti.connextdds.DataState) -> None: 
        """
        Create a DataStateEx with the provided SampleState, ViewState, InstanceState, and StreamKind.ANY
        """
    @typing.overload
    def __init__(self, data_state: rti.connextdds.DataState, stream_kind: rti.connextdds.StreamKind) -> None: 
        """
        Create a DataStateEx with the provided SampleState, ViewState, InstanceState, and StreamKind.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.StreamKind) -> rti.connextdds.DataStateEx: 
        """
        Set the StreamKind for the DataStateEx.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.SampleState) -> rti.connextdds.DataState: 
        """
        Set the SampleState for the DataState.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.ViewState) -> rti.connextdds.DataState: 
        """
        Set the ViewState for the DataState.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.InstanceState) -> rti.connextdds.DataState: 
        """
        Set the InstanceState for the DataState.
        """
    def __ne__(self, arg0: rti.connextdds.DataStateEx) -> bool: 
        """
        Compare DataStateEx objects for inequality.
        """
    @builtins.property
    def data_state(self) -> DataState:
        """
        Access the view, sample and instance states.

        :type: DataState
        """
    @builtins.property
    def instance_state(self) -> InstanceState:
        """
        The InstanceState of the DataStateEx.

        :type: InstanceState
        """
    @instance_state.setter
    def instance_state(self, arg1: InstanceState) -> None:
        """
        The InstanceState of the DataStateEx.
        """
    @builtins.property
    def sample_state(self) -> SampleState:
        """
        The SampleState of the DataStateEx.

        :type: SampleState
        """
    @sample_state.setter
    def sample_state(self, arg1: SampleState) -> None:
        """
        The SampleState of the DataStateEx.
        """
    @builtins.property
    def stream_kind(self) -> StreamKind:
        """
        The StreamKind.

        :type: StreamKind
        """
    @stream_kind.setter
    def stream_kind(self, arg1: StreamKind) -> None:
        """
        The StreamKind.
        """
    @builtins.property
    def view_state(self) -> ViewState:
        """
        The ViewState of the DataStateEx.

        :type: ViewState
        """
    @view_state.setter
    def view_state(self, arg1: ViewState) -> None:
        """
        The ViewState of the DataStateEx.
        """
    __hash__: NoneType
    any: rti.connextdds.DataState
    any_data: rti.connextdds.DataState
    new_data: rti.connextdds.DataState
    new_instance: rti.connextdds.DataState
    topic_queries: rti.connextdds.DataStateEx
    pass
class DataTag():
    def __contains__(self, arg0: str) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.DataTag) -> bool: 
        """
        Test for equality.
        """
    def __getitem__(self, arg0: str) -> typing.Optional[str]: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a policy with an empty sequence of tags.
        """
    @typing.overload
    def __init__(self, entries: rti.connextdds.StringPairSeq) -> None: 
        """
        Adds tags from a list.
        """
    @typing.overload
    def __init__(self, entries: dict) -> None: 
        """
        Adds tags from a dictionary.
        """
    def __len__(self) -> int: ...
    def __ne__(self, arg0: rti.connextdds.DataTag) -> bool: 
        """
        Test for inequality.
        """
    def __setitem__(self, arg0: str, arg1: str) -> None: ...
    def exists(self, key: str) -> bool: 
        """
        Returns true if a tag exists.
        """
    def get(self, key: str) -> str: 
        """
        Returns the value of a tag identified by a key if it exists.
        """
    def get_all(self) -> rti.connextdds.StringMap: 
        """
        Retrieves a copy of all the entries.
        """
    def remove(self, key: str) -> bool: 
        """
        Removes the tag identified by a key.
        """
    @typing.overload
    def set(self, entry_list: rti.connextdds.StringPairSeq) -> None: 
        """
        Adds or assigns tags from a list of string pairs.
        """
    @typing.overload
    def set(self, entry_map: dict) -> None: 
        """
        Adds or assigns tags from a dictionary.
        """
    @typing.overload
    def set(self, entry: tuple[str, str]) -> None: 
        """
        Adds or assigns a tag from a pair of strings.
        """
    @typing.overload
    def set(self, key: str, value: str) -> None: 
        """
        Adds or assigns a tag from a key string and a value string.
        """
    def size(self) -> int: 
        """
        Returns the number of tags.
        """
    def try_get(self, key: str) -> typing.Optional[str]: 
        """
        Returns the value of a tag identified by a key if it exists.
        """
    __hash__: NoneType
    pass
class DataWriter(IEntity, IAnyDataWriter):
    def __enter__(self) -> rti.connextdds.DataWriter: 
        """
        Enter a context for this DataWriter, to be cleaned up on exiting context
        """
    def __eq__(self, arg0: rti.connextdds.DataWriter) -> bool: 
        """
        Test for equality.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
        """
        Exit the context for this DataWriter, cleaning up resources.
        """
    @typing.overload
    def __init__(self, topic: rti.connextdds.Topic) -> None: 
        """
        Creates a DataWriter in the implicit publisher with default QoS.
        """
    @typing.overload
    def __init__(self, topic: rti.connextdds.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Creates a DataWriter in the implicit publisher with specific QoS and optionally a listener.
        """
    @typing.overload
    def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.Topic) -> None: 
        """
        Creates a DataWriter in a publisher with default QoS.
        """
    @typing.overload
    def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Creates a DataWriter in a publisher with specific QoS and optionally a listener.
        """
    @typing.overload
    def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
        """
        Create a typed DataWriter from an AnyDataWriter.
        """
    @typing.overload
    def __init__(self, entity: rti.connextdds.IEntity) -> None: 
        """
        Create a typed DataWriter from an Entity.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.DataWriter: 
        """
        Sets the DataWriterQos.
        """
    @typing.overload
    def __lshift__(self, arg0: tuple[object, rti.connextdds.Time]) -> rti.connextdds.DataWriter: 
        """
        Writes a paired sample with a timestamp.
        """
    @typing.overload
    def __lshift__(self, arg0: tuple[object, rti.connextdds.InstanceHandle]) -> rti.connextdds.DataWriter: 
        """
        Writes a paired sample with an instance handle.
        """
    @typing.overload
    def __lshift__(self, arg0: list[tuple[object, rti.connextdds.Time]]) -> rti.connextdds.DataWriter: 
        """
        Writes a sequence of pairs of samples with timestamps.
        """
    @typing.overload
    def __lshift__(self, arg0: list[object]) -> rti.connextdds.DataWriter: 
        """
        Writes a sequence of samples.
        """
    @typing.overload
    def __lshift__(self, arg0: object) -> rti.connextdds.DataWriter: 
        """
        Writes a sample.
        """
    def __ne__(self, arg0: rti.connextdds.DataWriter) -> bool: 
        """
        Test for inequality.
        """
    def __rshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.DataWriter: 
        """
        Get the DataWriterQos.
        """
    @staticmethod
    def _create_disabled(arg0: rti.connextdds.Publisher, arg1: rti.connextdds.Topic, arg2: rti.connextdds.DataWriterQos) -> rti.connextdds.DataWriter: ...
    def _set_related_reader_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
    def _wait_for_sample_acknowledgment(self, sample_id: rti.connextdds.SampleIdentity, timeout: rti.connextdds.Duration) -> None: 
        """
        Wait for a sample to be acknowledged by the application.
        """
    def assert_liveliness(self) -> None: 
        """
        Manually asserts the liveliness of the DataWriter.
        """
    def close(self) -> None: 
        """
        Close this DataWriter.
        """
    @typing.overload
    def dispose_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriter: 
        """
        Dispose an instance.
        """
    @typing.overload
    def dispose_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.DataWriter: 
        """
        Dispose an instance with a timestamp.
        """
    @typing.overload
    def dispose_instance(self, params: rti.connextdds.WriteParams) -> None: 
        """
        Dispose an instance with params.
        """
    @staticmethod
    def find_all_by_topic(publisher: rti.connextdds.Publisher, topic_name: str) -> list[rti.connextdds.DataWriter]: 
        """
        Retrieve all DataWriters for the given topic name in the publisher.
        """
    @staticmethod
    @typing.overload
    def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.DataWriter]: 
        """
        Find DataWriter in DomainParticipant with the provided name, returning the first found.
        """
    @staticmethod
    @typing.overload
    def find_by_name(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.DataWriter]: 
        """
        Find DataWriter in Publisher with the DataReader's name, returning the first found.
        """
    @staticmethod
    def find_by_topic(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.DataWriter]: 
        """
        Find DataWriter in publisher with a topic name, returning the first found.
        """
    def flush(self) -> None: 
        """
        Flushes the batch in progress in the context of thecalling thread.
        """
    def is_matched_subscription_active(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
        """
        A boolean indicating whether or not the matched subscription is active.
        """
    def is_sample_app_acknowledged(self, sample_id: rti.connextdds.SampleIdentity) -> bool: 
        """
        Indicates if a sample is considered application-acknowledged.
        """
    def key_value(self, handle: rti.connextdds.InstanceHandle) -> object: 
        """
        Retrieve the instance key that corresponds to an instance handle.
        """
    def lookup_instance(self, key_holder: object) -> rti.connextdds.InstanceHandle: 
        """
        Retrieve the instance handle that corresponds to an instance key_holder
        """
    def matched_subscription_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
        """
        Get the SubscriptionBuiltinTopicData for a subscription matched to this DataWriter.
        """
    @typing.overload
    def matched_subscription_datawriter_protocol_status(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriterProtocolStatus: 
        """
        Get a copy of the protocol status for this writer per a matched subscription handle.
        """
    @typing.overload
    def matched_subscription_datawriter_protocol_status(self, locator: rti.connextdds.Locator) -> rti.connextdds.DataWriterProtocolStatus: 
        """
        Get a copy of the protocol status for this writer per a matched subscription locator.
        """
    def matched_subscription_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
        """
        Get the ParticipantBuiltinTopicData for a subscription matched to this DataWriter.
        """
    @typing.overload
    def register_instance(self, key_holder: object) -> rti.connextdds.InstanceHandle: 
        """
        Informs RTI Connext that the application will be modifying a particular instance.
        """
    @typing.overload
    def register_instance(self, key_holder: object, timestamp: rti.connextdds.Time) -> rti.connextdds.InstanceHandle: 
        """
        Informs RTI Connext that the application will be modifying a particular instance and specified the timestamp.
        """
    @typing.overload
    def register_instance(self, key_holder: object, params: rti.connextdds.WriteParams) -> rti.connextdds.InstanceHandle: 
        """
        Registers instance with parameters.
        """
    def set_listener(self, listener: rti.connextdds.DataWriterListener, event_mask: rti.connextdds.StatusMask) -> None: 
        """
        Set the listener and event mask for the DataWriter.
        """
    @typing.overload
    def unregister_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriter: 
        """
        Unregister an instance.
        """
    @typing.overload
    def unregister_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.DataWriter: 
        """
        Unregister an instance with timestamp.
        """
    @typing.overload
    def unregister_instance(self, params: rti.connextdds.WriteParams) -> None: 
        """
        Unregister an instance with parameters.
        """
    def wait_for_acknowledgments(self, max_wait: rti.connextdds.Duration) -> None: 
        """
        Blocks the calling thread until all data written by a reliable DataWriter is acknowledged or until the timeout expires.
        """
    def wait_for_asynchronous_publishing(self, max_wait: rti.connextdds.Duration) -> None: 
        """
        This operation blocks the calling thread (up to max_wait) until all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.

        In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

        If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
        """
    def wait_for_asynchronous_publishing_async(self, max_wait: rti.connextdds.Duration) -> object: 
        """
        This function is awaitable until either a timeout of max_wait or all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.This function works with asyncio.

        In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

        If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
        """
    @typing.overload
    def write(self, samples: list[object]) -> None: 
        """
        Write a sequence of samples.
        """
    @typing.overload
    def write(self, samples: list[object], timestamp: rti.connextdds.Time) -> None: 
        """
        Write a sequence of samples with a timestamp.
        """
    @typing.overload
    def write(self, sample: object) -> None: 
        """
        Write a sample.
        """
    @typing.overload
    def write(self, sample: object, timestamp: rti.connextdds.Time) -> None: 
        """
        Write a sample with a specified timestamp.
        """
    @typing.overload
    def write(self, sample: object, handle: rti.connextdds.InstanceHandle) -> None: 
        """
        Write a sample with an instance handle.
        """
    @typing.overload
    def write(self, sample: object, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> None: 
        """
        Write a sample with an instance handle and specified timestamp.
        """
    @typing.overload
    def write(self, sample: object, params: rti.connextdds.WriteParams) -> None: 
        """
        Write with advanced parameters.
        """
    @builtins.property
    def _has_matched_subscriptions_with_related_writer(self) -> int:
        """
        :type: int
        """
    @builtins.property
    def datawriter_cache_status(self) -> DataWriterCacheStatus:
        """
        Get a copy of the cache status for this writer.

        :type: DataWriterCacheStatus
        """
    @builtins.property
    def datawriter_protocol_status(self) -> DataWriterProtocolStatus:
        """
        Get a copy of the protocol status for this writer.

        :type: DataWriterProtocolStatus
        """
    @builtins.property
    def listener(self) -> DataWriterListener:
        """
        Get the listener associated with the DataWriter or set the listener.

        :type: DataWriterListener
        """
    @listener.setter
    def listener(self, arg1: DataWriterListener) -> None:
        """
        Get the listener associated with the DataWriter or set the listener.
        """
    @builtins.property
    def liveliness_lost_status(self) -> LivelinessLostStatus:
        """
        Get a copy of the LivelinessLostStatus.

        :type: LivelinessLostStatus
        """
    @builtins.property
    def matched_subscriptions(self) -> InstanceHandleSeq:
        """
        Get a copy of the list of the currently matched subscription handles.

        :type: InstanceHandleSeq
        """
    @builtins.property
    def matched_subscriptions_locators(self) -> LocatorSeq:
        """
        The locators used to communicate with matched DataReaders.

        :type: LocatorSeq
        """
    @builtins.property
    def offered_deadline_missed_status(self) -> OfferedDeadlineMissedStatus:
        """
        Get a copy of the OfferedDeadlineMissedStatus.

        :type: OfferedDeadlineMissedStatus
        """
    @builtins.property
    def offered_incompatible_qos_status(self) -> OfferedIncompatibleQosStatus:
        """
        Get a copy of the OfferedIncompatibleQosStatus

        :type: OfferedIncompatibleQosStatus
        """
    @builtins.property
    def publication_matched_status(self) -> PublicationMatchedStatus:
        """
        Get a copy of the PublicationMatchedStatus

        :type: PublicationMatchedStatus
        """
    @builtins.property
    def publisher(self) -> Publisher:
        """
        Get the Publisher that owns this DataWriter.

        :type: Publisher
        """
    @builtins.property
    def qos(self) -> DataWriterQos:
        """
        The DataWriterQos for this DataWriter.This property's getter returns a deep copy.

        :type: DataWriterQos
        """
    @qos.setter
    def qos(self, arg1: DataWriterQos) -> None:
        """
        The DataWriterQos for this DataWriter.This property's getter returns a deep copy.
        """
    @builtins.property
    def reliable_reader_activity_changed_status(self) -> ReliableReaderActivityChangedStatus:
        """
        Get a copy of the reliable reader activity changed status for this writer.

        :type: ReliableReaderActivityChangedStatus
        """
    @builtins.property
    def reliable_writer_cache_changed_status(self) -> ReliableWriterCacheChangedStatus:
        """
        Get a copy of the reliable cache status for this writer.

        :type: ReliableWriterCacheChangedStatus
        """
    @builtins.property
    def service_request_accepted_status(self) -> ServiceRequestAcceptedStatus:
        """
        Get a copy of the service request accepted status for this writer.

        :type: ServiceRequestAcceptedStatus
        """
    @builtins.property
    def topic(self) -> Topic:
        """
        Get the Topic object associated with this DataWriter.

        :type: Topic
        """
    @builtins.property
    def topic_name(self) -> str:
        """
        Get the topic name associated with this DataWriter.

        :type: str
        """
    @builtins.property
    def type_name(self) -> str:
        """
        Get the type name for the topic object associated with this DataWriter.

        :type: str
        """
    __hash__: NoneType
    pass
class DataWriterCacheStatus():
    @builtins.property
    def alive_instance_count(self) -> int:
        """
        Number of alive instances in the DataWriter's queue.

        :type: int
        """
    @builtins.property
    def alive_instance_count_peak(self) -> int:
        """
        Highest number of alive instances in the writer's queue over the lifetime of the writer.

        :type: int
        """
    @builtins.property
    def disposed_instance_count(self) -> int:
        """
        Number of disposed instances in the DataWriter's queue.

        :type: int
        """
    @builtins.property
    def disposed_instance_count_peak(self) -> int:
        """
        Highest number of disposed instances in the writer's queue over the lifetime of the writer.

        :type: int
        """
    @builtins.property
    def sample_count(self) -> int:
        """
        Number of samples in the DataWriter's queue, including unregister and dispose samples.

        :type: int
        """
    @builtins.property
    def sample_count_peak(self) -> int:
        """
        Highest number of samples in the writer's queue over the lifetime of the writer.

        :type: int
        """
    @builtins.property
    def unregistered_instance_count(self) -> int:
        """
        Number of unregistered instances in the DataWriter's queue.

        :type: int
        """
    @builtins.property
    def unregistered_instance_count_peak(self) -> int:
        """
        Highest number of unregistered instances in the writer's queue over the lifetime of the writer.

        :type: int
        """
    pass
class DataWriterListener():
    def __init__(self) -> None: ...
    def on_application_acknowledgment(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
        """
        On application acknowledgment callback
        """
    def on_instance_replaced(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
        """
        On instance replaced callback.
        """
    def on_liveliness_lost(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
        """
        Liveliness lost callback.
        """
    def on_offered_deadline_missed(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
        """
        Offered deadline missed callback.
        """
    def on_offered_incompatible_qos(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
        """
        Offered incompatible QoS callback.
        """
    def on_publication_matched(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
        """
        Publication matched callback.
        """
    def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
        """
        Reliable reader activity changed callback.
        """
    def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
        """
        Reliable writer cache changed callback.
        """
    def on_service_request_accepted(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
        """
        On service request accepted callback.
        """
    pass
class DataWriterProtocol():
    def __eq__(self, arg0: rti.connextdds.DataWriterProtocol) -> bool: ...
    def __init__(self) -> None: 
        """
        Create a default DataWriterProtocol policy.
        """
    def __ne__(self, arg0: rti.connextdds.DataWriterProtocol) -> bool: ...
    @builtins.property
    def disable_inline_keyhash(self) -> bool:
        """
        Controls whether a keyhash is propagated on the wire with each sample.

        :type: bool
        """
    @disable_inline_keyhash.setter
    def disable_inline_keyhash(self, arg1: bool) -> None:
        """
        Controls whether a keyhash is propagated on the wire with each sample.
        """
    @builtins.property
    def disable_positive_acks(self) -> bool:
        """
        Controls whether the DataWriter expects positive acknowledgments from matched DataReaders.

        :type: bool
        """
    @disable_positive_acks.setter
    def disable_positive_acks(self, arg1: bool) -> None:
        """
        Controls whether the DataWriter expects positive acknowledgments from matched DataReaders.
        """
    @builtins.property
    def initial_virtual_sequence_number(self) -> SequenceNumber:
        """
        The initial virtual sequence number of the DataWriter.

        :type: SequenceNumber
        """
    @initial_virtual_sequence_number.setter
    def initial_virtual_sequence_number(self, arg1: SequenceNumber) -> None:
        """
        The initial virtual sequence number of the DataWriter.
        """
    @builtins.property
    def propagate_app_ack_with_no_response(self) -> bool:
        """
        Controls whether or not a DataWriter receives on_application_acknowledgment notifications with an empty or invalid response.

        :type: bool
        """
    @propagate_app_ack_with_no_response.setter
    def propagate_app_ack_with_no_response(self, arg1: bool) -> None:
        """
        Controls whether or not a DataWriter receives on_application_acknowledgment notifications with an empty or invalid response.
        """
    @builtins.property
    def push_on_write(self) -> bool:
        """
        Determines whether a sample is pushed on a call to write.

        :type: bool
        """
    @push_on_write.setter
    def push_on_write(self, arg1: bool) -> None:
        """
        Determines whether a sample is pushed on a call to write.
        """
    @builtins.property
    def rtps_object_id(self) -> int:
        """
        The RTPS object ID of the DataWriter.

        :type: int
        """
    @rtps_object_id.setter
    def rtps_object_id(self, arg1: int) -> None:
        """
        The RTPS object ID of the DataWriter.
        """
    @builtins.property
    def rtps_reliable_writer(self) -> RtpsReliableWriterProtocol:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated to a DataWriter. This parameter only has effect if both the writer and the matching reader are configured with ReliabilityKind.RELIABLE.

        :type: RtpsReliableWriterProtocol
        """
    @rtps_reliable_writer.setter
    def rtps_reliable_writer(self, arg1: RtpsReliableWriterProtocol) -> None:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated to a DataWriter. This parameter only has effect if both the writer and the matching reader are configured with ReliabilityKind.RELIABLE.
        """
    @builtins.property
    def serialize_key_with_dispose(self) -> bool:
        """
        Controls whether or not the serialized key is propagated on the wire with dispose samples.

        :type: bool
        """
    @serialize_key_with_dispose.setter
    def serialize_key_with_dispose(self, arg1: bool) -> None:
        """
        Controls whether or not the serialized key is propagated on the wire with dispose samples.
        """
    @builtins.property
    def virtual_guid(self) -> Guid:
        """
        The virtual GUID of the DataWriter. This property uses value semantics.

        :type: Guid
        """
    @virtual_guid.setter
    def virtual_guid(self, arg1: Guid) -> None:
        """
        The virtual GUID of the DataWriter. This property uses value semantics.
        """
    __hash__: NoneType
    pass
class DataWriterProtocolStatus():
    """
    Information about the DataWriter protocol status
    """
    @builtins.property
    def first_available_sample_sequence_number(self) -> SequenceNumber:
        """
        The sequence number of the first available sample currently queued in the local DataWriter.

        :type: SequenceNumber
        """
    @builtins.property
    def first_available_sample_virtual_sequence_number(self) -> SequenceNumber:
        """
        The virtual sequence number of the first available sample currently queued in the local DataWriter.

        :type: SequenceNumber
        """
    @builtins.property
    def first_unacknowledged_sample_sequence_number(self) -> SequenceNumber:
        """
        The sequence number of the first unacknowledged sample currently queued in the local DataWriter.

        :type: SequenceNumber
        """
    @builtins.property
    def first_unacknowledged_sample_subscription_handle(self) -> InstanceHandle:
        """
        The handle of a remote DataReader that has not acknowledged the first unacknowledged sample of the local DataWriter.

        :type: InstanceHandle
        """
    @builtins.property
    def first_unacknowledged_sample_virtual_sequence_number(self) -> SequenceNumber:
        """
        The virtual sequence number of the first unacknowledged sample currently queued in the local DataWriter.

        :type: SequenceNumber
        """
    @builtins.property
    def first_unelapsed_keep_duration_sample_sequence_number(self) -> SequenceNumber:
        """
        The sequence number of the first sample whose keep duration has not yet elapsed.

        :type: SequenceNumber
        """
    @builtins.property
    def last_available_sample_sequence_number(self) -> SequenceNumber:
        """
        The sequence number of the last available sample currently queued in the local DataWriter.

        :type: SequenceNumber
        """
    @builtins.property
    def last_available_sample_virtual_sequence_number(self) -> SequenceNumber:
        """
        The virtual sequence number of the last available sample currently queued in the local DataWriter.

        :type: SequenceNumber
        """
    @builtins.property
    def pulled_fragment_bytes(self) -> int:
        """
        The number of bytes of DATA_FRAG messages that have been pulled from this DataWriter.

        :type: int
        """
    @builtins.property
    def pulled_fragment_count(self) -> int:
        """
        The number of DATA_FRAG messages that have been pulled from this DataWriter.

        :type: int
        """
    @builtins.property
    def pulled_sample_bytes(self) -> EventCount64:
        """
        The number of bytes of user samples pulled from local DataWriter by matching DataReaders.

        :type: EventCount64
        """
    @builtins.property
    def pulled_sample_count(self) -> EventCount64:
        """
        The number of user samples pulled from local DataWriter by matching DataReaders.

        :type: EventCount64
        """
    @builtins.property
    def pushed_fragment_bytes(self) -> int:
        """
        The number of bytes of DATA_FRAG messages that have been pushed by this DataWriter.

        :type: int
        """
    @builtins.property
    def pushed_fragment_count(self) -> int:
        """
        The number of DATA_FRAG messages that have been pushed by this DataWriter.

        :type: int
        """
    @builtins.property
    def pushed_sample_bytes(self) -> EventCount64:
        """
        The number of bytes of user samples pushed on write from a local DataWriter to a matching remote DataReader.

        :type: EventCount64
        """
    @builtins.property
    def pushed_sample_count(self) -> EventCount64:
        """
        The number of user samples pushed on write from a local DataWriter to a matching remote DataReader.

        :type: EventCount64
        """
    @builtins.property
    def received_ack_bytes(self) -> EventCount64:
        """
        The number of bytes of ACKs from a remote DataReader received by a local DataWriter.

        :type: EventCount64
        """
    @builtins.property
    def received_ack_count(self) -> EventCount64:
        """
        The number of ACKs from a remote DataReader received by a local DataWriter.

        :type: EventCount64
        """
    @builtins.property
    def received_nack_bytes(self) -> EventCount64:
        """
        The number of bytes of NACKs from a remote DataReader received by a local DataWriter.

        :type: EventCount64
        """
    @builtins.property
    def received_nack_count(self) -> EventCount64:
        """
        The number of NACKs from a remote DataReader received by a local DataWriter.

        :type: EventCount64
        """
    @builtins.property
    def received_nack_fragment_bytes(self) -> int:
        """
        The number of bytes of NACK_FRAG messages that have been received by this DataWriter.

        :type: int
        """
    @builtins.property
    def received_nack_fragment_count(self) -> int:
        """
        The number of NACK_FRAG messages that have been received by this DataWriter.

        :type: int
        """
    @builtins.property
    def rejected_sample_count(self) -> EventCount64:
        """
        The number of times a sample is rejected due to exceptions in the send path.

        :type: EventCount64
        """
    @builtins.property
    def send_window_size(self) -> int:
        """
        Current maximum number of outstanding samples allowed in the DataWriter's queue.

        :type: int
        """
    @builtins.property
    def sent_gap_bytes(self) -> EventCount64:
        """
        The number of bytes of GAPs sent from local DataWriter to matching remote DataReaders.

        :type: EventCount64
        """
    @builtins.property
    def sent_gap_count(self) -> EventCount64:
        """
        The number of GAPs sent from local DataWriter to matching remote DataReaders.

        :type: EventCount64
        """
    @builtins.property
    def sent_heartbeat_bytes(self) -> EventCount64:
        """
        The number of bytes of Heartbeats sent between a local DataWriter and matching remote DataReader.

        :type: EventCount64
        """
    @builtins.property
    def sent_heartbeat_count(self) -> EventCount64:
        """
        The number of Heartbeats sent between a local DataWriter and matching remote DataReader.

        :type: EventCount64
        """
    pass
class DataWriterQos():
    def __eq__(self, arg0: rti.connextdds.DataWriterQos) -> bool: 
        """
        Test for equality
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a DataWriterQos with the default value for each policy.
        """
    @typing.overload
    def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
        """
        Create a DataWriterQos with settings equivalent to those of the provided DataWriter.
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.DataWriterQos) -> None: 
        """
        Create a copy of a DataWriterQos object.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Durability) -> rti.connextdds.DataWriterQos: 
        """
        Set the DurabilityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DurabilityService) -> rti.connextdds.DataWriterQos: 
        """
        Set the DurabilityServiceQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Deadline) -> rti.connextdds.DataWriterQos: 
        """
        Set the DeadlineQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.LatencyBudget) -> rti.connextdds.DataWriterQos: 
        """
        Set the LatencyBudgetQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Liveliness) -> rti.connextdds.DataWriterQos: 
        """
        Set the LivelinessQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Reliability) -> rti.connextdds.DataWriterQos: 
        """
        Set the ReliabilityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DestinationOrder) -> rti.connextdds.DataWriterQos: 
        """
        Set the DestinationOrderQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.History) -> rti.connextdds.DataWriterQos: 
        """
        Set the HistoryQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.ResourceLimits) -> rti.connextdds.DataWriterQos: 
        """
        Set the ResourceLimitsQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportPriority) -> rti.connextdds.DataWriterQos: 
        """
        Set the TransportPriorityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Lifespan) -> rti.connextdds.DataWriterQos: 
        """
        Set the LifespanQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.UserData) -> rti.connextdds.DataWriterQos: 
        """
        Set the UserDataQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Ownership) -> rti.connextdds.DataWriterQos: 
        """
        Set the OwnershipQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.OwnershipStrength) -> rti.connextdds.DataWriterQos: 
        """
        Set the OwnershipStrengthQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.WriterDataLifecycle) -> rti.connextdds.DataWriterQos: 
        """
        Set the WriterDataLifecycleQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataWriterResourceLimits) -> rti.connextdds.DataWriterQos: 
        """
        Set the DataWriterResourceLimitsQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataWriterProtocol) -> rti.connextdds.DataWriterQos: 
        """
        Set the DataWriterProtocolQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportSelection) -> rti.connextdds.DataWriterQos: 
        """
        Set the TransportSelectionQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportUnicast) -> rti.connextdds.DataWriterQos: 
        """
        Set the TransportUnicastQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.PublishMode) -> rti.connextdds.DataWriterQos: 
        """
        Set the PublishModeQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Property) -> rti.connextdds.DataWriterQos: 
        """
        Set the PropertyQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Service) -> rti.connextdds.DataWriterQos: 
        """
        Set the ServiceQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Batch) -> rti.connextdds.DataWriterQos: 
        """
        Set the BatchQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.MultiChannel) -> rti.connextdds.DataWriterQos: 
        """
        Set the MultiChannelQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Availability) -> rti.connextdds.DataWriterQos: 
        """
        Set the AvailabilityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.DataWriterQos: 
        """
        Set the EntityNameQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TopicQueryDispatch) -> rti.connextdds.DataWriterQos: 
        """
        Set the TopicQueryDispatchQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TypeSupport) -> rti.connextdds.DataWriterQos: 
        """
        Set the TypeSupportQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataRepresentation) -> rti.connextdds.DataWriterQos: 
        """
        Set the DataRepresentationQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataTag) -> rti.connextdds.DataWriterQos: 
        """
        Set the DataTagQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataWriterTransferMode) -> rti.connextdds.DataWriterQos: 
        """
        Set the DataWriterTransferModeQoS.
        """
    def __ne__(self, arg0: rti.connextdds.DataWriterQos) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Durability) -> rti.connextdds.DataWriterQos: 
        """
        Get the DurabilityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DurabilityService) -> rti.connextdds.DataWriterQos: 
        """
        Get the DurabilityServiceQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Deadline) -> rti.connextdds.DataWriterQos: 
        """
        Get the DeadlineQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.LatencyBudget) -> rti.connextdds.DataWriterQos: 
        """
        Get the LatencyBudgetQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Liveliness) -> rti.connextdds.DataWriterQos: 
        """
        Get the LivelinessQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Reliability) -> rti.connextdds.DataWriterQos: 
        """
        Get the ReliabilityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DestinationOrder) -> rti.connextdds.DataWriterQos: 
        """
        Get the DestinationOrderQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.History) -> rti.connextdds.DataWriterQos: 
        """
        Get the HistoryQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.ResourceLimits) -> rti.connextdds.DataWriterQos: 
        """
        Get the ResourceLimitsQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportPriority) -> rti.connextdds.DataWriterQos: 
        """
        Get the TransportPriorityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Lifespan) -> rti.connextdds.DataWriterQos: 
        """
        Get the LifespanQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.UserData) -> rti.connextdds.DataWriterQos: 
        """
        Get the UserDataQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Ownership) -> rti.connextdds.DataWriterQos: 
        """
        Get the OwnershipQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.OwnershipStrength) -> rti.connextdds.DataWriterQos: 
        """
        Get the OwnershipStrengthQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.WriterDataLifecycle) -> rti.connextdds.DataWriterQos: 
        """
        Get the WriterDataLifecycleQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataWriterResourceLimits) -> rti.connextdds.DataWriterQos: 
        """
        Get the DataWriterResourceLimitsQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataWriterProtocol) -> rti.connextdds.DataWriterQos: 
        """
        Get the DataWriterProtocolQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportSelection) -> rti.connextdds.DataWriterQos: 
        """
        Get the TransportSelectionQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportUnicast) -> rti.connextdds.DataWriterQos: 
        """
        Get the TransportUnicastQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.PublishMode) -> rti.connextdds.DataWriterQos: 
        """
        Get the PublishModeQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Property) -> rti.connextdds.DataWriterQos: 
        """
        Get the PropertyQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Service) -> rti.connextdds.DataWriterQos: 
        """
        Get the ServiceQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Batch) -> rti.connextdds.DataWriterQos: 
        """
        Get the BatchQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.MultiChannel) -> rti.connextdds.DataWriterQos: 
        """
        Get the MultiChannelQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Availability) -> rti.connextdds.DataWriterQos: 
        """
        Get the AvailabilityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.DataWriterQos: 
        """
        Get the EntityNameQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TopicQueryDispatch) -> rti.connextdds.DataWriterQos: 
        """
        Get the TopicQueryDispatchQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TypeSupport) -> rti.connextdds.DataWriterQos: 
        """
        Get the TypeSupportQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataRepresentation) -> rti.connextdds.DataWriterQos: 
        """
        Get the DataRepresentationQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataTag) -> rti.connextdds.DataWriterQos: 
        """
        Get the DataTagQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataWriterTransferMode) -> rti.connextdds.DataWriterQos: 
        """
        Get the DataWriterTransferModeQoS.
        """
    def __str__(self) -> str: ...
    def to_string(self, format: rti.connextdds.QosPrintFormat = QosPrintFormat(), base: typing.Optional[rti.connextdds.DataWriterQos] = None, print_all: bool = False) -> str: 
        """
        Convert QoS to string based on params.
        """
    @builtins.property
    def availability(self) -> Availability:
        """
        Get/set Availability QoS.

        :type: Availability
        """
    @availability.setter
    def availability(self, arg1: Availability) -> None:
        """
        Get/set Availability QoS.
        """
    @builtins.property
    def batch(self) -> Batch:
        """
        Get/set Batch QoS.

        :type: Batch
        """
    @batch.setter
    def batch(self, arg1: Batch) -> None:
        """
        Get/set Batch QoS.
        """
    @builtins.property
    def data_representation(self) -> DataRepresentation:
        """
        Get/set DataRepresentation QoS.

        :type: DataRepresentation
        """
    @data_representation.setter
    def data_representation(self, arg1: DataRepresentation) -> None:
        """
        Get/set DataRepresentation QoS.
        """
    @builtins.property
    def data_tag(self) -> DataTag:
        """
        Get/set DataTag QoS.

        :type: DataTag
        """
    @data_tag.setter
    def data_tag(self, arg1: DataTag) -> None:
        """
        Get/set DataTag QoS.
        """
    @builtins.property
    def data_writer_protocol(self) -> DataWriterProtocol:
        """
        (Deprecated) use protocol instead

        :type: DataWriterProtocol
        """
    @data_writer_protocol.setter
    def data_writer_protocol(self, arg1: DataWriterProtocol) -> None:
        """
        (Deprecated) use protocol instead
        """
    @builtins.property
    def data_writer_resource_limits(self) -> DataWriterResourceLimits:
        """
        (Deprecated) use writer_resource_limits instead

        :type: DataWriterResourceLimits
        """
    @data_writer_resource_limits.setter
    def data_writer_resource_limits(self, arg1: DataWriterResourceLimits) -> None:
        """
        (Deprecated) use writer_resource_limits instead
        """
    @builtins.property
    def data_writer_transfer_mode(self) -> DataWriterTransferMode:
        """
        Get/set DataWriterTransferMode QoS.

        :type: DataWriterTransferMode
        """
    @data_writer_transfer_mode.setter
    def data_writer_transfer_mode(self, arg1: DataWriterTransferMode) -> None:
        """
        Get/set DataWriterTransferMode QoS.
        """
    @builtins.property
    def deadline(self) -> Deadline:
        """
        Get/set Deadline QoS.

        :type: Deadline
        """
    @deadline.setter
    def deadline(self, arg1: Deadline) -> None:
        """
        Get/set Deadline QoS.
        """
    @builtins.property
    def destination_order(self) -> DestinationOrder:
        """
        Get/set DestinationOrder QoS.

        :type: DestinationOrder
        """
    @destination_order.setter
    def destination_order(self, arg1: DestinationOrder) -> None:
        """
        Get/set DestinationOrder QoS.
        """
    @builtins.property
    def durability(self) -> Durability:
        """
        Get/set Durability QoS.

        :type: Durability
        """
    @durability.setter
    def durability(self, arg1: Durability) -> None:
        """
        Get/set Durability QoS.
        """
    @builtins.property
    def durability_service(self) -> DurabilityService:
        """
        Get/set DurabilityService QoS.

        :type: DurabilityService
        """
    @durability_service.setter
    def durability_service(self, arg1: DurabilityService) -> None:
        """
        Get/set DurabilityService QoS.
        """
    @builtins.property
    def entity_name(self) -> EntityName:
        """
        Get/set EntityName QoS.

        :type: EntityName
        """
    @entity_name.setter
    def entity_name(self, arg1: EntityName) -> None:
        """
        Get/set EntityName QoS.
        """
    @builtins.property
    def history(self) -> History:
        """
        Get/set History QoS.

        :type: History
        """
    @history.setter
    def history(self, arg1: History) -> None:
        """
        Get/set History QoS.
        """
    @builtins.property
    def latency_budget(self) -> LatencyBudget:
        """
        Get/set LatencyBudget QoS.

        :type: LatencyBudget
        """
    @latency_budget.setter
    def latency_budget(self, arg1: LatencyBudget) -> None:
        """
        Get/set LatencyBudget QoS.
        """
    @builtins.property
    def lifespan(self) -> Lifespan:
        """
        Get/set Lifespan QoS.

        :type: Lifespan
        """
    @lifespan.setter
    def lifespan(self, arg1: Lifespan) -> None:
        """
        Get/set Lifespan QoS.
        """
    @builtins.property
    def liveliness(self) -> Liveliness:
        """
        Get/set Liveliness QoS.

        :type: Liveliness
        """
    @liveliness.setter
    def liveliness(self, arg1: Liveliness) -> None:
        """
        Get/set Liveliness QoS.
        """
    @builtins.property
    def multi_channel(self) -> MultiChannel:
        """
        Get/set MultiChannel QoS.

        :type: MultiChannel
        """
    @multi_channel.setter
    def multi_channel(self, arg1: MultiChannel) -> None:
        """
        Get/set MultiChannel QoS.
        """
    @builtins.property
    def ownership(self) -> Ownership:
        """
        Get/set Ownership QoS.

        :type: Ownership
        """
    @ownership.setter
    def ownership(self, arg1: Ownership) -> None:
        """
        Get/set Ownership QoS.
        """
    @builtins.property
    def ownership_strength(self) -> OwnershipStrength:
        """
        Get/set OwnershipStrength QoS.

        :type: OwnershipStrength
        """
    @ownership_strength.setter
    def ownership_strength(self, arg1: OwnershipStrength) -> None:
        """
        Get/set OwnershipStrength QoS.
        """
    @builtins.property
    def property(self) -> Property:
        """
        Get/set Property QoS.

        :type: Property
        """
    @property.setter
    def property(self, arg1: Property) -> None:
        """
        Get/set Property QoS.
        """
    @builtins.property
    def protocol(self) -> DataWriterProtocol:
        """
        Get/set DataWriterProtocol QoS.

        :type: DataWriterProtocol
        """
    @protocol.setter
    def protocol(self, arg1: DataWriterProtocol) -> None:
        """
        Get/set DataWriterProtocol QoS.
        """
    @builtins.property
    def publish_mode(self) -> PublishMode:
        """
        Get/set PublishMode QoS.

        :type: PublishMode
        """
    @publish_mode.setter
    def publish_mode(self, arg1: PublishMode) -> None:
        """
        Get/set PublishMode QoS.
        """
    @builtins.property
    def reliability(self) -> Reliability:
        """
        Get/set Reliability QoS.

        :type: Reliability
        """
    @reliability.setter
    def reliability(self, arg1: Reliability) -> None:
        """
        Get/set Reliability QoS.
        """
    @builtins.property
    def resource_limits(self) -> ResourceLimits:
        """
        Get/set ResourceLimits QoS.

        :type: ResourceLimits
        """
    @resource_limits.setter
    def resource_limits(self, arg1: ResourceLimits) -> None:
        """
        Get/set ResourceLimits QoS.
        """
    @builtins.property
    def service(self) -> Service:
        """
        Get/set Service QoS.

        :type: Service
        """
    @service.setter
    def service(self, arg1: Service) -> None:
        """
        Get/set Service QoS.
        """
    @builtins.property
    def topic_query_dispatch(self) -> TopicQueryDispatch:
        """
        Get/set TopicQueryDispatch QoS.

        :type: TopicQueryDispatch
        """
    @topic_query_dispatch.setter
    def topic_query_dispatch(self, arg1: TopicQueryDispatch) -> None:
        """
        Get/set TopicQueryDispatch QoS.
        """
    @builtins.property
    def transport_priority(self) -> TransportPriority:
        """
        Get/set TransportPriority QoS.

        :type: TransportPriority
        """
    @transport_priority.setter
    def transport_priority(self, arg1: TransportPriority) -> None:
        """
        Get/set TransportPriority QoS.
        """
    @builtins.property
    def transport_selection(self) -> TransportSelection:
        """
        Get/set TransportSelection QoS.

        :type: TransportSelection
        """
    @transport_selection.setter
    def transport_selection(self, arg1: TransportSelection) -> None:
        """
        Get/set TransportSelection QoS.
        """
    @builtins.property
    def transport_unicast(self) -> TransportUnicast:
        """
        Get/set TransportUnicast QoS.

        :type: TransportUnicast
        """
    @transport_unicast.setter
    def transport_unicast(self, arg1: TransportUnicast) -> None:
        """
        Get/set TransportUnicast QoS.
        """
    @builtins.property
    def type_support(self) -> TypeSupport:
        """
        Get/set TypeSupport QoS.

        :type: TypeSupport
        """
    @type_support.setter
    def type_support(self, arg1: TypeSupport) -> None:
        """
        Get/set TypeSupport QoS.
        """
    @builtins.property
    def user_data(self) -> UserData:
        """
        Get/set UserData QoS.

        :type: UserData
        """
    @user_data.setter
    def user_data(self, arg1: UserData) -> None:
        """
        Get/set UserData QoS.
        """
    @builtins.property
    def writer_data_lifecycle(self) -> WriterDataLifecycle:
        """
        Get/set WriterDataLifecycle QoS.

        :type: WriterDataLifecycle
        """
    @writer_data_lifecycle.setter
    def writer_data_lifecycle(self, arg1: WriterDataLifecycle) -> None:
        """
        Get/set WriterDataLifecycle QoS.
        """
    @builtins.property
    def writer_resource_limits(self) -> DataWriterResourceLimits:
        """
        Get/set DataWriterResourceLimits QoS.

        :type: DataWriterResourceLimits
        """
    @writer_resource_limits.setter
    def writer_resource_limits(self, arg1: DataWriterResourceLimits) -> None:
        """
        Get/set DataWriterResourceLimits QoS.
        """
    __hash__: NoneType
    pass
class DataWriterResourceLimits():
    def __eq__(self, arg0: rti.connextdds.DataWriterResourceLimits) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default DataWriterResourceLimits policy.
        """
    def __ne__(self, arg0: rti.connextdds.DataWriterResourceLimits) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def autoregister_instances(self) -> bool:
        """
        Whether or not to automatically register new instances.

        :type: bool
        """
    @autoregister_instances.setter
    def autoregister_instances(self, arg1: bool) -> None:
        """
        Whether or not to automatically register new instances.
        """
    @builtins.property
    def cookie_max_length(self) -> int:
        """
        Represents the maximum length in bytes of a Cookie.

        :type: int
        """
    @cookie_max_length.setter
    def cookie_max_length(self, arg1: int) -> None:
        """
        Represents the maximum length in bytes of a Cookie.
        """
    @builtins.property
    def initial_active_topic_queries(self) -> int:
        """
        Represents the initial number of active topic queries a DataWriter will manage.

        :type: int
        """
    @initial_active_topic_queries.setter
    def initial_active_topic_queries(self, arg1: int) -> None:
        """
        Represents the initial number of active topic queries a DataWriter will manage.
        """
    @builtins.property
    def initial_batches(self) -> int:
        """
        Represents the initial number of batches a DataWriter will manage.

        :type: int
        """
    @initial_batches.setter
    def initial_batches(self, arg1: int) -> None:
        """
        Represents the initial number of batches a DataWriter will manage.
        """
    @builtins.property
    def initial_concurrent_blocking_threads(self) -> int:
        """
        The initial number of threads that are allowed to concurrently block on write call on the same DataWriter.

        :type: int
        """
    @initial_concurrent_blocking_threads.setter
    def initial_concurrent_blocking_threads(self, arg1: int) -> None:
        """
        The initial number of threads that are allowed to concurrently block on write call on the same DataWriter.
        """
    @builtins.property
    def initial_virtual_writers(self) -> int:
        """
        The initial number of virtual writers supported by a DataWriter.

        :type: int
        """
    @initial_virtual_writers.setter
    def initial_virtual_writers(self, arg1: int) -> None:
        """
        The initial number of virtual writers supported by a DataWriter.
        """
    @builtins.property
    def initialize_writer_loaned_sample(self) -> bool:
        """
        Whether or not to initialize loaned samples returned by a DataWriter.

        :type: bool
        """
    @initialize_writer_loaned_sample.setter
    def initialize_writer_loaned_sample(self, arg1: bool) -> None:
        """
        Whether or not to initialize loaned samples returned by a DataWriter.
        """
    @builtins.property
    def instance_replacement(self) -> DataWriterResourceLimitsInstanceReplacementKind:
        """
        Sets the kinds of instances allowed to be replaced when instance resource limits are reached.

        :type: DataWriterResourceLimitsInstanceReplacementKind
        """
    @instance_replacement.setter
    def instance_replacement(self, arg1: DataWriterResourceLimitsInstanceReplacementKind) -> None:
        """
        Sets the kinds of instances allowed to be replaced when instance resource limits are reached.
        """
    @builtins.property
    def max_active_topic_queries(self) -> int:
        """
        Represents the maximum number of active topic queries a DataWriter will manage.

        :type: int
        """
    @max_active_topic_queries.setter
    def max_active_topic_queries(self, arg1: int) -> None:
        """
        Represents the maximum number of active topic queries a DataWriter will manage.
        """
    @builtins.property
    def max_app_ack_remote_readers(self) -> int:
        """
        The maximum number of application-level acknowledging remote readers supported by a DataWriter.

        :type: int
        """
    @max_app_ack_remote_readers.setter
    def max_app_ack_remote_readers(self, arg1: int) -> None:
        """
        The maximum number of application-level acknowledging remote readers supported by a DataWriter.
        """
    @builtins.property
    def max_batches(self) -> int:
        """
        Represents the maximum number of batches a DataWriter will manage.

        :type: int
        """
    @max_batches.setter
    def max_batches(self, arg1: int) -> None:
        """
        Represents the maximum number of batches a DataWriter will manage.
        """
    @builtins.property
    def max_concurrent_blocking_threads(self) -> int:
        """
        The maximum number of threads that are allowed to concurrently block on write call on the same DataWriter.

        :type: int
        """
    @max_concurrent_blocking_threads.setter
    def max_concurrent_blocking_threads(self, arg1: int) -> None:
        """
        The maximum number of threads that are allowed to concurrently block on write call on the same DataWriter.
        """
    @builtins.property
    def max_remote_reader_filters(self) -> int:
        """
        The maximum number of remote DataReaders for which the DataWriter will perform content-based filtering.

        :type: int
        """
    @max_remote_reader_filters.setter
    def max_remote_reader_filters(self, arg1: int) -> None:
        """
        The maximum number of remote DataReaders for which the DataWriter will perform content-based filtering.
        """
    @builtins.property
    def max_remote_readers(self) -> int:
        """
        The maximum number of remote readers supported by a DataWriter.

        :type: int
        """
    @max_remote_readers.setter
    def max_remote_readers(self, arg1: int) -> None:
        """
        The maximum number of remote readers supported by a DataWriter.
        """
    @builtins.property
    def max_virtual_writers(self) -> int:
        """
        The maximum number of virtual writers supported by a DataWriter.

        :type: int
        """
    @max_virtual_writers.setter
    def max_virtual_writers(self, arg1: int) -> None:
        """
        The maximum number of virtual writers supported by a DataWriter.
        """
    @builtins.property
    def replace_empty_instances(self) -> bool:
        """
        Whether or not to replace empty instances during instance replacement.

        :type: bool
        """
    @replace_empty_instances.setter
    def replace_empty_instances(self, arg1: bool) -> None:
        """
        Whether or not to replace empty instances during instance replacement.
        """
    @builtins.property
    def writer_loaned_sample_allocation(self) -> AllocationSettings:
        """
        Represents the allocation settings of loaned samples managed by a DataWriter.

        :type: AllocationSettings
        """
    @writer_loaned_sample_allocation.setter
    def writer_loaned_sample_allocation(self, arg1: AllocationSettings) -> None:
        """
        Represents the allocation settings of loaned samples managed by a DataWriter.
        """
    __hash__: NoneType
    pass
class DataWriterResourceLimitsInstanceReplacementKind():
    class DataWriterResourceLimitsInstanceReplacementKind():
        """
        Members:

          UNREGISTERED : Allows a DataWriter to reclaim unregistered acknowledged instances.

        By default, all instance replacement kinds first attempt to reclaim an unregistered, acknowledged instance. Used in DataWriterResourceLimits.instance_replacement [default]

          ALIVE : Allows a DataWriter to reclaim alive, acknowledged instances.

        When an unregistered, acknowledged instance is not available to reclaim, this kind allows a DataWriter to reclaim an alive, acknowledged instance, where an alive instance is a registered, non-disposed instance. The least recently registered or written alive instance will be reclaimed.

          DISPOSED : Allows a DataWriter to reclaim disposed acknowledged instances.

        When an unregistered, acknowledged instance is not available to reclaim, this kind allows a DataWriter to reclaim a disposed, acknowledged instance. The least recently disposed instance will be reclaimed.

          ALIVE_THEN_DISPOSED : Allows a DataWriter first to reclaim an alive, acknowledged instance, and then, if necessary, a disposed, acknowledged instance.

        When an unregistered, acknowledged instance is not available to reclaim, this kind allows a DataWriter to first try reclaiming an alive, acknowledged instance. If no instance is reclaimable, then it tries reclaiming a disposed, acknowledged instance. The least recently used (i.e., registered, written, or disposed) instance will be reclaimed.

          DISPOSED_THEN_ALIVE : Allows a DataWriter first to reclaim a disposed, acknowledged instance, and then, if necessary, an alive, acknowledged instance.

        When an unregistered, acknowledged instance is not available to reclaim, this kind allows a DataWriter to first try reclaiming a disposed, acknowledged instance. If no instance is reclaimable, then it tries reclaiming an alive, acknowledged instance. The least recently used (i.e., disposed, registered, or written) instance will be reclaimed.

          ALIVE_OR_DISPOSED : Allows a DataWriter to reclaim a either an alive acknowledged instance or a disposed acknowledged instance.

        When an unregistered acknowledged instance is not available to reclaim, this kind allows a DataWriter to reclaim either an alive, acknowledged instance or a disposed, acknowledged instance. If both instance kinds are available to reclaim, the DataWriter will reclaim the least recently used (i.e. disposed, registered, or written) instance.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        ALIVE: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
        ALIVE_OR_DISPOSED: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
        ALIVE_THEN_DISPOSED: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
        DISPOSED: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
        DISPOSED_THEN_ALIVE: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
        UNREGISTERED: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind:
        """
        Retrieves the actual enumerated value.

        :type: DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
        """
    ALIVE: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
    ALIVE_OR_DISPOSED: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
    ALIVE_THEN_DISPOSED: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
    DISPOSED: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
    DISPOSED_THEN_ALIVE: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
    UNREGISTERED: rti.connextdds.DataWriterResourceLimitsInstanceReplacementKind.DataWriterResourceLimitsInstanceReplacementKind
    __hash__: NoneType
    pass
class DataWriterSeq():
    def __add__(self, arg0: list[rti.connextdds.DataWriter]) -> list[rti.connextdds.DataWriter]: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.DataWriter) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: list[rti.connextdds.DataWriter]) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> list[rti.connextdds.DataWriter]: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.DataWriter: ...
    def __iadd__(self, arg0: list[rti.connextdds.DataWriter]) -> list[rti.connextdds.DataWriter]: ...
    def __imul__(self, arg0: int) -> list[rti.connextdds.DataWriter]: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: list[rti.connextdds.DataWriter]) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.DataWriter]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> list[rti.connextdds.DataWriter]: ...
    def __ne__(self, arg0: list[rti.connextdds.DataWriter]) -> bool: ...
    def __rmul__(self, arg0: int) -> list[rti.connextdds.DataWriter]: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.DataWriter) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: list[rti.connextdds.DataWriter]) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.DataWriter) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.DataWriter) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: list[rti.connextdds.DataWriter]) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.DataWriter) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.DataWriter: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.DataWriter: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.DataWriter) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class DataWriterShmemRefTransferModeSettings():
    def __eq__(self, arg0: rti.connextdds.DataWriterShmemRefTransferModeSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.DataWriterShmemRefTransferModeSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def enable_data_consistency_check(self) -> bool:
        """
        Controls if samples can be checked for consistency.

        :type: bool
        """
    @enable_data_consistency_check.setter
    def enable_data_consistency_check(self, arg1: bool) -> None:
        """
        Controls if samples can be checked for consistency.
        """
    __hash__: NoneType
    pass
class DataWriterTransferMode():
    def __eq__(self, arg0: rti.connextdds.DataWriterTransferMode) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates a DataWriterTransferMode qos policy with default values.
        """
    def __ne__(self, arg0: rti.connextdds.DataWriterTransferMode) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def shmem_ref_settings(self) -> DataWriterShmemRefTransferModeSettings:
        """
        Settings related to transferring data using shared memory references.

        :type: DataWriterShmemRefTransferModeSettings
        """
    @shmem_ref_settings.setter
    def shmem_ref_settings(self, arg1: DataWriterShmemRefTransferModeSettings) -> None:
        """
        Settings related to transferring data using shared memory references.
        """
    __hash__: NoneType
    pass
class Database():
    def __eq__(self, arg0: rti.connextdds.Database) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a Database QoS policy with default settings.
        """
    def __ne__(self, arg0: rti.connextdds.Database) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def cleanup_period(self) -> Duration:
        """
        Get/set the cleanup period.

        :type: Duration
        """
    @cleanup_period.setter
    def cleanup_period(self, arg1: Duration) -> None:
        """
        Get/set the cleanup period.
        """
    @builtins.property
    def initial_records(self) -> int:
        """
        Get/set the number of database records to be allocated initially.

        :type: int
        """
    @initial_records.setter
    def initial_records(self, arg1: int) -> None:
        """
        Get/set the number of database records to be allocated initially.
        """
    @builtins.property
    def initial_weak_references(self) -> int:
        """
        Get/set the initial number of weak references.

        :type: int
        """
    @initial_weak_references.setter
    def initial_weak_references(self, arg1: int) -> None:
        """
        Get/set the initial number of weak references.
        """
    @builtins.property
    def max_skiplist_level(self) -> int:
        """
        Get/set the skiplist level.

        :type: int
        """
    @max_skiplist_level.setter
    def max_skiplist_level(self, arg1: int) -> None:
        """
        Get/set the skiplist level.
        """
    @builtins.property
    def max_weak_references(self) -> int:
        """
        Get/set the maximum number of weak references.

        :type: int
        """
    @max_weak_references.setter
    def max_weak_references(self, arg1: int) -> None:
        """
        Get/set the maximum number of weak references.
        """
    @builtins.property
    def shutdown_cleanup_period(self) -> Duration:
        """
        Get/set the shutdown cleanup period.

        :type: Duration
        """
    @shutdown_cleanup_period.setter
    def shutdown_cleanup_period(self, arg1: Duration) -> None:
        """
        Get/set the shutdown cleanup period.
        """
    @builtins.property
    def shutdown_timeout(self) -> Duration:
        """
        Get/set the shutdown timeout.

        :type: Duration
        """
    @shutdown_timeout.setter
    def shutdown_timeout(self, arg1: Duration) -> None:
        """
        Get/set the shutdown timeout.
        """
    @builtins.property
    def thread(self) -> ThreadSettings:
        """
        Get/set the thread settings for the Database thread.

        :type: ThreadSettings
        """
    @thread.setter
    def thread(self, arg1: ThreadSettings) -> None:
        """
        Get/set the thread settings for the Database thread.
        """
    __hash__: NoneType
    pass
class Deadline():
    def __eq__(self, arg0: rti.connextdds.Deadline) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default deadline, with an infinite period.
        """
    @typing.overload
    def __init__(self, period: rti.connextdds.Duration) -> None: 
        """
        Creates a deadline policy with the specified period.
        """
    @typing.overload
    def __init__(self, sec: int, nanosec: int) -> None: 
        """
        Creates a deadline policy with the specified period.
        """
    def __ne__(self, arg0: rti.connextdds.Deadline) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def period(self) -> Duration:
        """
        The duration of the deadline period.

        :type: Duration
        """
    @period.setter
    def period(self, arg1: Duration) -> None:
        """
        The duration of the deadline period.
        """
    __hash__: NoneType
    pass
class DestinationOrder():
    def __eq__(self, arg0: rti.connextdds.DestinationOrder) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, kind: rti.connextdds.DestinationOrderKind) -> None: 
        """
        Creates a policy with the specified destination order kind.
        """
    def __ne__(self, arg0: rti.connextdds.DestinationOrder) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def kind(self) -> DestinationOrderKind:
        """
        The destination order kind.

        :type: DestinationOrderKind
        """
    @kind.setter
    def kind(self, arg1: DestinationOrderKind) -> None:
        """
        The destination order kind.
        """
    @builtins.property
    def scope(self) -> DestinationOrderScopeKind:
        """
        The destination order scope.

        :type: DestinationOrderScopeKind
        """
    @scope.setter
    def scope(self, arg1: DestinationOrderScopeKind) -> None:
        """
        The destination order scope.
        """
    @builtins.property
    def source_timestamp_tolerance(self) -> Duration:
        """
        The allowed tolerance between source timestamps of consecutive samples.

        :type: Duration
        """
    @source_timestamp_tolerance.setter
    def source_timestamp_tolerance(self, arg1: Duration) -> None:
        """
        The allowed tolerance between source timestamps of consecutive samples.
        """
    __hash__: NoneType
    pass
class DestinationOrderKind():
    class DestinationOrderKind():
        """
        Members:

          BY_RECEPTION_TIMESTAMP : [default] Indicates that data is ordered based on the reception time at each Subscriber.

        Since each subscriber may receive the data at different times there is no guarantee that the changes will be seen in the same order. Consequently, it is possible for each subscriber to end up with a different final value for the data.

          BY_SOURCE_TIMESTAMP : Indicates that data is ordered based on a time-stamp placed at the source (by RTI Connext or by the application).

        In any case this guarantees a consistent final value for the data in all subscribers.

        Note: If Batching is needed along with DestinationOrderKind.BY_SOURCE_TIMESTAMP and DestinationOrderScopeKind.INSTANCE, then the Batch.source_timestamp_resolution and Batch.thread_safe_write setting of Batch should be set to Duration.zero() and true respectively.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        BY_RECEPTION_TIMESTAMP: rti.connextdds.DestinationOrderKind.DestinationOrderKind
        BY_SOURCE_TIMESTAMP: rti.connextdds.DestinationOrderKind.DestinationOrderKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.DestinationOrderKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.DestinationOrderKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.DestinationOrderKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DestinationOrderKind.DestinationOrderKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.DestinationOrderKind.DestinationOrderKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.DestinationOrderKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.DestinationOrderKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.DestinationOrderKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> DestinationOrderKind.DestinationOrderKind:
        """
        Retrieves the actual enumerated value.

        :type: DestinationOrderKind.DestinationOrderKind
        """
    BY_RECEPTION_TIMESTAMP: rti.connextdds.DestinationOrderKind.DestinationOrderKind
    BY_SOURCE_TIMESTAMP: rti.connextdds.DestinationOrderKind.DestinationOrderKind
    __hash__: NoneType
    pass
class DestinationOrderScopeKind():
    class DestinationOrderScopeKind():
        """
        Members:

          INSTANCE : [default] Indicates that data is ordered on a per instance basis if used along with DestinationOrderKind.BY_SOURCE_TIMESTAMP. 

        The source timestamp of the current sample is compared to the source timestamp of the previously received sample for the same instance. The tolerance check is also applied per instance.

          TOPIC : Indicates that data is ordered on a per topic basis if used along with DestinationOrderKind.BY_SOURCE_TIMESTAMP.

        The source timestamp of the current sample is compared to the source timestamp of the previously received sample for the same topic. The tolerance check is also applied per topic.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        INSTANCE: rti.connextdds.DestinationOrderScopeKind.DestinationOrderScopeKind
        TOPIC: rti.connextdds.DestinationOrderScopeKind.DestinationOrderScopeKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.DestinationOrderScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.DestinationOrderScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.DestinationOrderScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DestinationOrderScopeKind.DestinationOrderScopeKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.DestinationOrderScopeKind.DestinationOrderScopeKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.DestinationOrderScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.DestinationOrderScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.DestinationOrderScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> DestinationOrderScopeKind.DestinationOrderScopeKind:
        """
        Retrieves the actual enumerated value.

        :type: DestinationOrderScopeKind.DestinationOrderScopeKind
        """
    INSTANCE: rti.connextdds.DestinationOrderScopeKind.DestinationOrderScopeKind
    TOPIC: rti.connextdds.DestinationOrderScopeKind.DestinationOrderScopeKind
    __hash__: NoneType
    pass
class Discovery():
    def __eq__(self, arg0: rti.connextdds.Discovery) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    def __ne__(self, arg0: rti.connextdds.Discovery) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def accept_unknown_peers(self) -> bool:
        """
        Whether to accept a new participant that is not in the initial peers list.

        :type: bool
        """
    @accept_unknown_peers.setter
    def accept_unknown_peers(self, arg1: bool) -> None:
        """
        Whether to accept a new participant that is not in the initial peers list.
        """
    @builtins.property
    def enable_endpoint_discovery(self) -> bool:
        """
        Whether to automatically enable endpoint discovery for all the remote participants.

        :type: bool
        """
    @enable_endpoint_discovery.setter
    def enable_endpoint_discovery(self, arg1: bool) -> None:
        """
        Whether to automatically enable endpoint discovery for all the remote participants.
        """
    @builtins.property
    def enabled_transports(self) -> StringSeq:
        """
        The transports (by their aliases) available for the discovery mechanism.

        This property's getter returns a deep copy.

        :type: StringSeq
        """
    @enabled_transports.setter
    def enabled_transports(self, arg1: StringSeq) -> None:
        """
        The transports (by their aliases) available for the discovery mechanism.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def initial_peers(self) -> StringSeq:
        """
        The initial list of peers that the discovery mechanism will contact to announce this DomainParticipant.

        This property's getter returns a deep copy.

        :type: StringSeq
        """
    @initial_peers.setter
    def initial_peers(self, arg1: StringSeq) -> None:
        """
        The initial list of peers that the discovery mechanism will contact to announce this DomainParticipant.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def metatraffic_transport_priority(self) -> int:
        """
        The transport priority to use for the Discovery meta-traffic.

        :type: int
        """
    @metatraffic_transport_priority.setter
    def metatraffic_transport_priority(self, arg1: int) -> None:
        """
        The transport priority to use for the Discovery meta-traffic.
        """
    @builtins.property
    def multicast_receive_addresses(self) -> StringSeq:
        """
        The multicast group addresses on which discovery-related meta-traffic can be received by the DomainParticipant.

        This property's getter returns a deep copy.

        :type: StringSeq
        """
    @multicast_receive_addresses.setter
    def multicast_receive_addresses(self, arg1: StringSeq) -> None:
        """
        The multicast group addresses on which discovery-related meta-traffic can be received by the DomainParticipant.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class DiscoveryConfig():
    def __eq__(self, arg0: rti.connextdds.DiscoveryConfig) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    def __ne__(self, arg0: rti.connextdds.DiscoveryConfig) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def asynchronous_publisher(self) -> AsynchronousPublisher:
        """
        Asynchronous publishing settings for the discovery Publisher and all entities that are created by it.

        :type: AsynchronousPublisher
        """
    @asynchronous_publisher.setter
    def asynchronous_publisher(self, arg1: AsynchronousPublisher) -> None:
        """
        Asynchronous publishing settings for the discovery Publisher and all entities that are created by it.
        """
    @builtins.property
    def builtin_discovery_plugins(self) -> DiscoveryConfigBuiltinPluginKindMask:
        """
        The kind mask for built-in discovery plugins.

        :type: DiscoveryConfigBuiltinPluginKindMask
        """
    @builtin_discovery_plugins.setter
    def builtin_discovery_plugins(self, arg1: DiscoveryConfigBuiltinPluginKindMask) -> None:
        """
        The kind mask for built-in discovery plugins.
        """
    @builtins.property
    def default_domain_announcement_period(self) -> Duration:
        """
        The period to announce a participant to the default domain 0.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @default_domain_announcement_period.setter
    def default_domain_announcement_period(self, arg1: Duration) -> None:
        """
        The period to announce a participant to the default domain 0.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def dns_tracker_polling_period(self) -> Duration:
        """
        Duration that specifies the period used by the DNS tracker to poll the DNS service and check for changes in the hostnames.

        :type: Duration
        """
    @dns_tracker_polling_period.setter
    def dns_tracker_polling_period(self, arg1: Duration) -> None:
        """
        Duration that specifies the period used by the DNS tracker to poll the DNS service and check for changes in the hostnames.
        """
    @builtins.property
    def enabled_builtin_channels(self) -> DiscoveryConfigBuiltinChannelKindMask:
        """
        The mask specifying which built-in channels should be enabled.

        :type: DiscoveryConfigBuiltinChannelKindMask
        """
    @enabled_builtin_channels.setter
    def enabled_builtin_channels(self, arg1: DiscoveryConfigBuiltinChannelKindMask) -> None:
        """
        The mask specifying which built-in channels should be enabled.
        """
    @builtins.property
    def endpoint_type_object_lb_serialization_threshold(self) -> int:
        """
        Option to reduce the size required to propagate a TypeObject in Simple Endpoint Discovery.

        :type: int
        """
    @endpoint_type_object_lb_serialization_threshold.setter
    def endpoint_type_object_lb_serialization_threshold(self, arg1: int) -> None:
        """
        Option to reduce the size required to propagate a TypeObject in Simple Endpoint Discovery.
        """
    @builtins.property
    def ignore_default_domain_announcements(self) -> bool:
        """
        Used to ignore the announcements received by a participant on the default domain 0 corresponding to participants running on domains IDs other than 0.

        :type: bool
        """
    @ignore_default_domain_announcements.setter
    def ignore_default_domain_announcements(self, arg1: bool) -> None:
        """
        Used to ignore the announcements received by a participant on the default domain 0 corresponding to participants running on domains IDs other than 0.
        """
    @builtins.property
    def initial_participant_announcements(self) -> int:
        """
        The number of initial announcements sent when a participant is first enabled or when a remote participant is newly discovered.

        :type: int
        """
    @initial_participant_announcements.setter
    def initial_participant_announcements(self, arg1: int) -> None:
        """
        The number of initial announcements sent when a participant is first enabled or when a remote participant is newly discovered.
        """
    @builtins.property
    def locator_reachability_assert_period(self) -> Duration:
        """
        Period at which this DomainParticipant will assert the locators discovered from other DomainParticipants.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @locator_reachability_assert_period.setter
    def locator_reachability_assert_period(self, arg1: Duration) -> None:
        """
        Period at which this DomainParticipant will assert the locators discovered from other DomainParticipants.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def locator_reachability_change_detection_period(self) -> Duration:
        """
        Period at which this DomainParticipant will check if its locators are reachable from other DomainParticipants.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @locator_reachability_change_detection_period.setter
    def locator_reachability_change_detection_period(self, arg1: Duration) -> None:
        """
        Period at which this DomainParticipant will check if its locators are reachable from other DomainParticipants.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def locator_reachability_lease_duration(self) -> Duration:
        """
        The time period after which other DomainParticipants can consider one of their locators as "unreachable" if they do not receive a REACHABILITY PING from this DomainParticipant.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @locator_reachability_lease_duration.setter
    def locator_reachability_lease_duration(self, arg1: Duration) -> None:
        """
        The time period after which other DomainParticipants can consider one of their locators as "unreachable" if they do not receive a REACHABILITY PING from this DomainParticipant.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def max_initial_participant_announcement_period(self) -> Duration:
        """
        The maximum period between initial announcements when a participant is first enabled or when a remote participant is newly discovered.

        :type: Duration
        """
    @max_initial_participant_announcement_period.setter
    def max_initial_participant_announcement_period(self, arg1: Duration) -> None:
        """
        The maximum period between initial announcements when a participant is first enabled or when a remote participant is newly discovered.
        """
    @builtins.property
    def max_liveliness_loss_detection_period(self) -> Duration:
        """
        The period to assert liveliness for the participant.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @max_liveliness_loss_detection_period.setter
    def max_liveliness_loss_detection_period(self, arg1: Duration) -> None:
        """
        The period to assert liveliness for the participant.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def min_initial_participant_announcement_period(self) -> Duration:
        """
        The minimum period between initial announcements when a participant is first enabled or when a remote participant is newly discovered.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @min_initial_participant_announcement_period.setter
    def min_initial_participant_announcement_period(self, arg1: Duration) -> None:
        """
        The minimum period between initial announcements when a participant is first enabled or when a remote participant is newly discovered.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def new_remote_participant_announcements(self) -> int:
        """
        The number of participant announcements sent when a remote participant is newly discovered.

        :type: int
        """
    @new_remote_participant_announcements.setter
    def new_remote_participant_announcements(self, arg1: int) -> None:
        """
        The number of participant announcements sent when a remote participant is newly discovered.
        """
    @builtins.property
    def participant_announcement_period(self) -> Duration:
        """
        The period at which a participant announces itself to potential peers when using the Simple Participant Discovery Protocol 2.0 (SPDP2)

        :type: Duration
        """
    @participant_announcement_period.setter
    def participant_announcement_period(self, arg1: Duration) -> None:
        """
        The period at which a participant announces itself to potential peers when using the Simple Participant Discovery Protocol 2.0 (SPDP2)
        """
    @builtins.property
    def participant_liveliness_assert_period(self) -> Duration:
        """
        The period to assert liveliness for the participant.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @participant_liveliness_assert_period.setter
    def participant_liveliness_assert_period(self, arg1: Duration) -> None:
        """
        The period to assert liveliness for the participant.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def participant_liveliness_lease_duration(self) -> Duration:
        """
        The liveliness lease duration for the participant.

        :type: Duration
        """
    @participant_liveliness_lease_duration.setter
    def participant_liveliness_lease_duration(self, arg1: Duration) -> None:
        """
        The liveliness lease duration for the participant.
        """
    @builtins.property
    def participant_message_reader(self) -> RtpsReliableReaderProtocol:
        """
        Reliability policy for a built-in participant message reader.

        :type: RtpsReliableReaderProtocol
        """
    @participant_message_reader.setter
    def participant_message_reader(self, arg1: RtpsReliableReaderProtocol) -> None:
        """
        Reliability policy for a built-in participant message reader.
        """
    @builtins.property
    def participant_message_reader_reliability_kind(self) -> ReliabilityKind:
        """
        Reliability policy for a built-in participant message reader.

        :type: ReliabilityKind
        """
    @participant_message_reader_reliability_kind.setter
    def participant_message_reader_reliability_kind(self, arg1: ReliabilityKind) -> None:
        """
        Reliability policy for a built-in participant message reader.
        """
    @builtins.property
    def participant_message_writer(self) -> RtpsReliableWriterProtocol:
        """
        Reliability policy for a built-in participant message writer.

        :type: RtpsReliableWriterProtocol
        """
    @participant_message_writer.setter
    def participant_message_writer(self, arg1: RtpsReliableWriterProtocol) -> None:
        """
        Reliability policy for a built-in participant message writer.
        """
    @builtins.property
    def participant_reader_resource_limits(self) -> BuiltinTopicReaderResourceLimits:
        """
        Resource limits.

        :type: BuiltinTopicReaderResourceLimits
        """
    @participant_reader_resource_limits.setter
    def participant_reader_resource_limits(self, arg1: BuiltinTopicReaderResourceLimits) -> None:
        """
        Resource limits.
        """
    @builtins.property
    def publication_reader(self) -> RtpsReliableReaderProtocol:
        """
        RTPS protocol-related configuration settings for the RTPS reliable reader associated to a built-in publication reader.

        :type: RtpsReliableReaderProtocol
        """
    @publication_reader.setter
    def publication_reader(self, arg1: RtpsReliableReaderProtocol) -> None:
        """
        RTPS protocol-related configuration settings for the RTPS reliable reader associated to a built-in publication reader.
        """
    @builtins.property
    def publication_reader_resource_limits(self) -> BuiltinTopicReaderResourceLimits:
        """
        Publication reader resource limits.

        :type: BuiltinTopicReaderResourceLimits
        """
    @publication_reader_resource_limits.setter
    def publication_reader_resource_limits(self, arg1: BuiltinTopicReaderResourceLimits) -> None:
        """
        Publication reader resource limits.
        """
    @builtins.property
    def publication_writer(self) -> RtpsReliableWriterProtocol:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated to a built-in publication reader.

        :type: RtpsReliableWriterProtocol
        """
    @publication_writer.setter
    def publication_writer(self, arg1: RtpsReliableWriterProtocol) -> None:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated to a built-in publication reader.
        """
    @builtins.property
    def publication_writer_data_lifecycle(self) -> WriterDataLifecycle:
        """
        riter data lifecycle settings for a built-in publication writer.

        :type: WriterDataLifecycle
        """
    @publication_writer_data_lifecycle.setter
    def publication_writer_data_lifecycle(self, arg1: WriterDataLifecycle) -> None:
        """
        riter data lifecycle settings for a built-in publication writer.
        """
    @builtins.property
    def publication_writer_publish_mode(self) -> PublishMode:
        """
        Publish mode policy for the built-in publication writer.

        :type: PublishMode
        """
    @publication_writer_publish_mode.setter
    def publication_writer_publish_mode(self, arg1: PublishMode) -> None:
        """
        Publish mode policy for the built-in publication writer.
        """
    @builtins.property
    def remote_participant_purge_kind(self) -> RemoteParticipantPurgeKind:
        """
        The participant's behavior for maintaining knowledge of remote participants (and their contained entities) with which discovery communication has been lost.

        :type: RemoteParticipantPurgeKind
        """
    @remote_participant_purge_kind.setter
    def remote_participant_purge_kind(self, arg1: RemoteParticipantPurgeKind) -> None:
        """
        The participant's behavior for maintaining knowledge of remote participants (and their contained entities) with which discovery communication has been lost.
        """
    @builtins.property
    def secure_volatile_reader(self) -> RtpsReliableReaderProtocol:
        """
        RTPS reliable reader protocol-related configuration settings for the built-in secure volatile reader.

        :type: RtpsReliableReaderProtocol
        """
    @secure_volatile_reader.setter
    def secure_volatile_reader(self, arg1: RtpsReliableReaderProtocol) -> None:
        """
        RTPS reliable reader protocol-related configuration settings for the built-in secure volatile reader.
        """
    @builtins.property
    def secure_volatile_writer(self) -> RtpsReliableWriterProtocol:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated with the built-in secure volatile writer.

        :type: RtpsReliableWriterProtocol
        """
    @secure_volatile_writer.setter
    def secure_volatile_writer(self, arg1: RtpsReliableWriterProtocol) -> None:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated with the built-in secure volatile writer.
        """
    @builtins.property
    def secure_volatile_writer_publish_mode(self) -> PublishMode:
        """
        Publish mode policy for the built-in secure volatile writer.

        :type: PublishMode
        """
    @secure_volatile_writer_publish_mode.setter
    def secure_volatile_writer_publish_mode(self, arg1: PublishMode) -> None:
        """
        Publish mode policy for the built-in secure volatile writer.
        """
    @builtins.property
    def service_request_reader(self) -> RtpsReliableReaderProtocol:
        """
        RTPS protocol-related configuration settings for the RTPS reliable reader associated to a built-in publication reader.

        :type: RtpsReliableReaderProtocol
        """
    @service_request_reader.setter
    def service_request_reader(self, arg1: RtpsReliableReaderProtocol) -> None:
        """
        RTPS protocol-related configuration settings for the RTPS reliable reader associated to a built-in publication reader.
        """
    @builtins.property
    def service_request_writer(self) -> RtpsReliableWriterProtocol:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated to the built-in ServiceRequest writer.

        :type: RtpsReliableWriterProtocol
        """
    @service_request_writer.setter
    def service_request_writer(self, arg1: RtpsReliableWriterProtocol) -> None:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated to the built-in ServiceRequest writer.
        """
    @builtins.property
    def service_request_writer_data_lifecycle(self) -> WriterDataLifecycle:
        """
        Writer data lifecycle settings for a built-in ServiceRequest writer.

        :type: WriterDataLifecycle
        """
    @service_request_writer_data_lifecycle.setter
    def service_request_writer_data_lifecycle(self, arg1: WriterDataLifecycle) -> None:
        """
        Writer data lifecycle settings for a built-in ServiceRequest writer.
        """
    @builtins.property
    def service_request_writer_publish_mode(self) -> PublishMode:
        """
        Publish mode policy for the built-in service request writer.

        :type: PublishMode
        """
    @service_request_writer_publish_mode.setter
    def service_request_writer_publish_mode(self, arg1: PublishMode) -> None:
        """
        Publish mode policy for the built-in service request writer.
        """
    @builtins.property
    def subscription_reader(self) -> RtpsReliableReaderProtocol:
        """
        RTPS protocol-related configuration settings for the RTPS reliable reader associated to a built-in subscription reader.

        :type: RtpsReliableReaderProtocol
        """
    @subscription_reader.setter
    def subscription_reader(self, arg1: RtpsReliableReaderProtocol) -> None:
        """
        RTPS protocol-related configuration settings for the RTPS reliable reader associated to a built-in subscription reader.
        """
    @builtins.property
    def subscription_reader_resource_limits(self) -> BuiltinTopicReaderResourceLimits:
        """
        Subscription reader resource limits.

        :type: BuiltinTopicReaderResourceLimits
        """
    @subscription_reader_resource_limits.setter
    def subscription_reader_resource_limits(self, arg1: BuiltinTopicReaderResourceLimits) -> None:
        """
        Subscription reader resource limits.
        """
    @builtins.property
    def subscription_writer(self) -> RtpsReliableWriterProtocol:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated to a built-in subscription reader.

        :type: RtpsReliableWriterProtocol
        """
    @subscription_writer.setter
    def subscription_writer(self, arg1: RtpsReliableWriterProtocol) -> None:
        """
        RTPS protocol-related configuration settings for the RTPS reliable writer associated to a built-in subscription reader.
        """
    @builtins.property
    def subscription_writer_data_lifecycle(self) -> WriterDataLifecycle:
        """
        riter data lifecycle settings for a built-in subscription writer.

        :type: WriterDataLifecycle
        """
    @subscription_writer_data_lifecycle.setter
    def subscription_writer_data_lifecycle(self, arg1: WriterDataLifecycle) -> None:
        """
        riter data lifecycle settings for a built-in subscription writer.
        """
    @builtins.property
    def subscription_writer_publish_mode(self) -> PublishMode:
        """
        Publish mode policy for the built-in subscription writer.

        :type: PublishMode
        """
    @subscription_writer_publish_mode.setter
    def subscription_writer_publish_mode(self, arg1: PublishMode) -> None:
        """
        Publish mode policy for the built-in subscription writer.
        """
    __hash__: NoneType
    pass
class DiscoveryConfigBuiltinChannelKindMask():
    def __and__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a DiscoveryConfigBuiltinChannelKindMask equivalent to DiscoveryConfigBuiltinChannelKindMask.NONE
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Bitwise logical OR of masks.
        """
    def __repr__(self) -> str: 
        """
        Convert mask to string.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: 
        """
        Convert mask to string.
        """
    def __xor__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.DiscoveryConfigBuiltinChannelKindMask: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ALL: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask
    NONE: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask
    SERVICE_REQUEST: rti.connextdds.DiscoveryConfigBuiltinChannelKindMask
    __hash__: NoneType
    pass
class DiscoveryConfigBuiltinPluginKindMask():
    def __and__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a DiscoveryConfigBuiltinPluginKindMask equivalent to DiscoveryConfigBuiltinPluginKindMask.NONE
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Bitwise logical OR of masks.
        """
    def __repr__(self) -> str: 
        """
        Convert mask to string.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: 
        """
        Convert mask to string.
        """
    def __xor__(self, arg0: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.DiscoveryConfigBuiltinPluginKindMask: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    NONE: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask
    SDP: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask
    SDP2: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask
    SEDP: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask
    SPDP: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask
    SPDP2: rti.connextdds.DiscoveryConfigBuiltinPluginKindMask
    __hash__: NoneType
    pass
class DomainParticipant(IEntity):
    """
    Container for all Entity objects.

    * It acts as a container for all other Entity objects.
    * It acts as a factory for the Publisher, Subscriber, Topic and Entity objects.
    * It represents the participation of the application on a communication plane that isolates applications running on the same set of physical computers from each other. A domain establishes a virtual network linking all applications that share the same domainId and isolating them from applications running on different domains. In this way, several independent distributed applications can coexist in the same physical network without interfering, or even being aware of each other.
    * It provides administration services in the domain, offering operations that allow the application to ignore locally any information about a given participant (DomainParticipant.ignore), publication (ignore_publication), subscription (ignore_subscription) or topic (ignore_topic).
    """
    def __enter__(self) -> rti.connextdds.DomainParticipant: 
        """
        Enter a context for this Domain Participant, to be cleaned up on exiting context
        """
    def __eq__(self, arg0: rti.connextdds.DomainParticipant) -> bool: 
        """
        Test for equality.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
        """
        Exit the context for this Domain Participant, cleaning up resources.
        """
    @typing.overload
    def __init__(self, domain_id: int) -> None: 
        """
        Create a new DomainParticipant with default QoS.
        """
    @typing.overload
    def __init__(self, domain_id: int, qos: rti.connextdds.DomainParticipantQos, listener: rti.connextdds.DomainParticipantListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Create a new DomainParticipant
        """
    @typing.overload
    def __init__(self, entity: rti.connextdds.IEntity) -> None: 
        """
        Downcast an IEntity to a DomainParticipant.
        """
    def __lshift__(self, arg0: rti.connextdds.DomainParticipantQos) -> rti.connextdds.DomainParticipant: 
        """
        Set the domain participant's QoS.
        """
    def __ne__(self, arg0: rti.connextdds.DomainParticipant) -> bool: 
        """
        Test for inequality.
        """
    def __rshift__(self, arg0: rti.connextdds.DomainParticipantQos) -> rti.connextdds.DomainParticipant: 
        """
        Get the domain participant's QoS.
        """
    def add_peer(self, peer: str) -> None: 
        """
        Attempt to contact an additional peer participant.
        """
    def add_peers(self, peers: rti.connextdds.StringSeq) -> None: 
        """
        Add a sequence of peers to be contacted.
        """
    def assert_liveliness(self) -> None: 
        """
        Manually assert the liveliness of the DomainParticipant.
        """
    def banish_ignored_participants(self) -> None: 
        """
        Prevents ignored remote DomainParticipants from receiving traffic from the local DomainParticipant.
        """
    def close_contained_entities(self) -> None: 
        """
        Destroy all contained entities.
        """
    def contains_entity(self, handle: rti.connextdds.InstanceHandle) -> bool: 
        """
        Check whether or not the given handle represents an Entity that was created from the DomainParticipant.
        """
    def delete_durable_subscription(self, group: rti.connextdds.EndpointGroup) -> None: 
        """
        Deletes an existing Durable Subscription on all Persistence Services.
        """
    @typing.overload
    def discovered_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
        """
        Retrieve DomainParticipant information by handle.
        """
    @typing.overload
    def discovered_participant_data(self, handles: rti.connextdds.InstanceHandleSeq) -> rti.connextdds.ParticipantBuiltinTopicDataSeq: 
        """
        Retrieve DomainParticipant information with a sequence of handles.
        """
    def discovered_participant_subject_name(self, handle: rti.connextdds.InstanceHandle) -> typing.Optional[str]: 
        """
        Returns the entity name for the specified DomainParticipant InstanceHandle.
        """
    def discovered_participants(self) -> rti.connextdds.InstanceHandleSeq: 
        """
        Retrieves the instance handles of other DomainParticipants discovered by this one.
        """
    def discovered_participants_from_subject_name(self, subject_name: typing.Optional[str]) -> rti.connextdds.InstanceHandleSeq: 
        """
        Returns the list of InstanceHandles corresponding toparticipants with the given entity name.
        """
    @typing.overload
    def discovered_topic_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.TopicBuiltinTopicData: 
        """
        Get information about a discovered topic using its handle.
        """
    @typing.overload
    def discovered_topic_data(self, topic: rti.connextdds.IEntity) -> rti.connextdds.TopicBuiltinTopicData: 
        """
        Get information about a discovered topic.
        """
    @typing.overload
    def discovered_topic_data(self, handles: rti.connextdds.InstanceHandleSeq) -> rti.connextdds.TopicBuiltinTopicDataSeq: 
        """
        Get information about a discovered topics with their handles.
        """
    @typing.overload
    def discovered_topic_data(self) -> rti.connextdds.TopicBuiltinTopicDataSeq: 
        """
        Get information about all discovered topics.
        """
    def discovered_topics(self) -> rti.connextdds.InstanceHandleSeq: 
        """
        Get all Topic handles discovered by this DomainParticipant.
        """
    @staticmethod
    def finalize_participant_factory() -> None: 
        """
        Finalize the DomainParticipantFactory
        """
    @staticmethod
    @typing.overload
    def find(name: str) -> typing.Optional[rti.connextdds.DomainParticipant]: 
        """
        Find a local DomainParticipant by its name.
        """
    @staticmethod
    @typing.overload
    def find() -> rti.connextdds.DomainParticipantSeq: 
        """
        Find all local DomainParticipants.
        """
    @staticmethod
    @typing.overload
    def find(domain_id: int) -> typing.Optional[rti.connextdds.DomainParticipant]: 
        """
        Find a local DomainParticipant with the given domain ID. If more than one DomainParticipant on the same domain exists in the application, it is not specified which will be returned.
        """
    def find_contentfilter(self, name: str) -> typing.Optional[rti.connextdds.ContentFilterBase]: 
        """
        Find content filter previously registered to this DomainParticipant.
        """
    def find_datareader(self, name: str) -> typing.Optional[rti.connextdds.AnyDataReader]: 
        """
        Find a DataReader by its name.
        """
    def find_datawriter(self, name: str) -> typing.Optional[rti.connextdds.AnyDataWriter]: 
        """
        Find a DataWriter by its name.
        """
    def find_flow_controller(self, name: str) -> typing.Optional[rti.connextdds.FlowController]: 
        """
        Find a FlowController configured in this DomainParticipant.
        """
    def find_publisher(self, name: str) -> typing.Optional[rti.connextdds.Publisher]: 
        """
        Lookup a Publisher within the DomainParticipant by its entity name.
        """
    def find_publishers(self) -> rti.connextdds.PublisherSeq: 
        """
        Find all Publishers within the DomainParticipant.
        """
    def find_registered_content_filters(self) -> rti.connextdds.StringSeq: 
        """
        Retrieve a list of all registered content filter names.
        """
    def find_subscriber(self, name: str) -> typing.Optional[rti.connextdds.Subscriber]: 
        """
        Find a Subscriber in the DomainParticipant by its entity name.
        """
    def find_subscribers(self) -> rti.connextdds.SubscriberSeq: 
        """
        Find all subscribers within the DomainParticipant.
        """
    def find_topics(self) -> rti.connextdds.AnyTopicSeq: 
        """
        Find all Topics in the DomainParticipant.
        """
    def ignore_datareader(self, handle: rti.connextdds.InstanceHandle) -> None: 
        """
        Ignore a DataReader matching the provided handle.
        """
    def ignore_datareaders(self, handles: rti.connextdds.InstanceHandleSeq) -> None: 
        """
        Ignore a list of DataReaders specified by their handles.
        """
    def ignore_datawriter(self, handle: rti.connextdds.InstanceHandle) -> None: 
        """
        Ignore a DataWriter matching the provided handle.
        """
    def ignore_datawriters(self, handles: rti.connextdds.InstanceHandleSeq) -> None: 
        """
        Ignore a list of DataWriters specified by their handles.
        """
    def ignore_participant(self, handle: rti.connextdds.InstanceHandle) -> None: 
        """
        Ignore a DomainParticipant given it's handle.
        """
    def ignore_participants(self, arg0: rti.connextdds.InstanceHandleSeq) -> None: 
        """
        Ignore DomainParticipants given a list of handles.
        """
    def ignore_topic(self, handle: rti.connextdds.InstanceHandle) -> None: 
        """
        Ignore a Topic matching the provided handle.
        """
    def ignore_topics(self, handles: rti.connextdds.InstanceHandleSeq) -> None: 
        """
        Ignore a list of Topics specified by their handles.
        """
    def is_type_registered(self, name: str) -> bool: 
        """
        Check if a type has been registered to this DomainParticipant.
        """
    def register_contentfilter(self, filter: rti.connextdds.ContentFilterBase, name: str) -> None: 
        """
        Register a content filter which can be used to create a ContentFiltertedTopic.
        """
    def register_durable_subscription(self, group: rti.connextdds.EndpointGroup, topic_name: str) -> None: 
        """
        Registers a Durable Subscription on the specified Topic on all Persistence Services
        """
    @staticmethod
    def register_idl_type(type: object, registered_type_name: str) -> None: 
        """
        Registers a python class so it can be used in XML-based applications and referred to by its registered name.
        """
    def register_type(self, name: str, type: rti.connextdds.DynamicType, serialization_property: rti.connextdds.DynamicDataTypeSerializationProperty = DynamicDataTypeSerializationProperty.DEFAULT) -> None: 
        """
        Registers a DynamicType with specific serialization properties.
        """
    def remove_peer(self, peer: str) -> None: 
        """
        Remove a peer participant from this list that this DomainParticipant will attempt to communicate with.
        """
    def remove_peers(self, peers: rti.connextdds.StringSeq) -> None: 
        """
        Remove a sequence of peers from the contact list.
        """
    def resume_endpoint_discovery(self, handle: rti.connextdds.InstanceHandle) -> None: 
        """
        Initiates endpoint discovery with the remote DomainParticipant identified by its InstanceHandle.
        """
    def set_listener(self, listener: rti.connextdds.DomainParticipantListener, event_mask: rti.connextdds.StatusMask) -> None: 
        """
        Bind the listener and event mask to the DomainParticipant.
        """
    def unregister_contentfilter(self, name: str) -> None: 
        """
        Unregister content filter previously registered to this DomainParticipant.
        """
    def unregister_type(self, name: str) -> None: 
        """
        Unregister a type previously registered to this DomainParticipant.
        """
    @builtins.property
    def builtin_subscriber(self) -> Subscriber:
        """
        Get the built-in subscriber for the DomainParticipant.

        :type: Subscriber
        """
    @builtins.property
    def current_time(self) -> Time:
        """
        Get the current time.

        :type: Time
        """
    @builtins.property
    def default_datareader_qos(self) -> DataReaderQos:
        """
        The default DataReaderQos.

        This property's getter returns a deep copy.

        :type: DataReaderQos
        """
    @default_datareader_qos.setter
    def default_datareader_qos(self, arg1: DataReaderQos) -> None:
        """
        The default DataReaderQos.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def default_datawriter_qos(self) -> DataWriterQos:
        """
        The default DataWriterQos.

        This property's getter returns a deep copy.

        :type: DataWriterQos
        """
    @default_datawriter_qos.setter
    def default_datawriter_qos(self, arg1: DataWriterQos) -> None:
        """
        The default DataWriterQos.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def default_publisher_qos(self) -> PublisherQos:
        """
        The default PublisherQos.

        This property's getter returns a deep copy.

        :type: PublisherQos
        """
    @default_publisher_qos.setter
    def default_publisher_qos(self, arg1: PublisherQos) -> None:
        """
        The default PublisherQos.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def default_subscriber_qos(self) -> SubscriberQos:
        """
        The default SubscriberQos.

        This property's getter returns a deep copy.

        :type: SubscriberQos
        """
    @default_subscriber_qos.setter
    def default_subscriber_qos(self, arg1: SubscriberQos) -> None:
        """
        The default SubscriberQos.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def default_topic_qos(self) -> TopicQos:
        """
        The default TopicQos.

        This property's getter returns a deep copy.

        :type: TopicQos
        """
    @default_topic_qos.setter
    def default_topic_qos(self, arg1: TopicQos) -> None:
        """
        The default TopicQos.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def domain_id(self) -> int:
        """
        The unique domain identifier.

        :type: int
        """
    @builtins.property
    def implicit_publisher(self) -> Publisher:
        """
        Get the implicit Publisher for the DomainParticipant.

        :type: Publisher
        """
    @builtins.property
    def implicit_subscriber(self) -> Subscriber:
        """
        Get the implicit Subscriber for the DomainParticipant.

        :type: Subscriber
        """
    @builtins.property
    def listener(self) -> DomainParticipantListener:
        """
        Get the listener.

        :type: DomainParticipantListener
        """
    @listener.setter
    def listener(self, arg1: DomainParticipantListener) -> None:
        """
        Get the listener.
        """
    @builtins.property
    def participant_protocol_status(self) -> DomainParticipantProtocolStatus:
        """
        Get the protocol status for this participant

        :type: DomainParticipantProtocolStatus
        """
    @builtins.property
    def participant_reader(self) -> ParticipantBuiltinTopicData.DataReader:
        """
        Get the DomainParticipant built-in topic reader.

        :type: ParticipantBuiltinTopicData.DataReader
        """
    @builtins.property
    def publication_reader(self) -> PublicationBuiltinTopicData.DataReader:
        """
        Get the publication built-in topic reader.

        :type: PublicationBuiltinTopicData.DataReader
        """
    @builtins.property
    def qos(self) -> DomainParticipantQos:
        """
        Get the domain participant's QoS.

        This property's getter returns a deep copy.

        :type: DomainParticipantQos
        """
    @qos.setter
    def qos(self, arg1: DomainParticipantQos) -> None:
        """
        Get the domain participant's QoS.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def service_request_reader(self) -> ServiceRequest.DataReader:
        """
        Get the ServiceRequest built-in topic reader.

        :type: ServiceRequest.DataReader
        """
    @builtins.property
    def subscription_reader(self) -> SubscriptionBuiltinTopicData.DataReader:
        """
        Get the subscription built-in topic reader.

        :type: SubscriptionBuiltinTopicData.DataReader
        """
    __hash__: NoneType
    default_participant_qos: rti.connextdds.DomainParticipantQos
    participant_factory_qos: rti.connextdds.DomainParticipantFactoryQos
    pass
class DomainParticipantConfigParams():
    def __eq__(self, arg0: rti.connextdds.DomainParticipantConfigParams) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, domain_id: int = DomainParticipantConfigParams.DOMAIN_ID_USE_XML_CONFIG, participant_name: str = DomainParticipantConfigParams.ENTITY_NAME_USE_XML_CONFIG, qos_library_name: str = DomainParticipantConfigParams.QOS_ELEMENT_NAME_USE_XML_CONFIG, qos_profile_name: str = DomainParticipantConfigParams.QOS_ELEMENT_NAME_USE_XML_CONFIG, domain_entity_qos_library_name: str = DomainParticipantConfigParams.QOS_ELEMENT_NAME_USE_XML_CONFIG, domain_entity_qos_profile_name: str = DomainParticipantConfigParams.QOS_ELEMENT_NAME_USE_XML_CONFIG) -> None: 
        """
        Create a DomainParticipantConfigParams object with the specified values.
        """
    def __ne__(self, arg0: rti.connextdds.DomainParticipantConfigParams) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def domain_entity_qos_library_name(self) -> str:
        """
        The QoS library name containing the QoS profile from which the all the entities defined under the participant configuraton are created.

        :type: str
        """
    @domain_entity_qos_library_name.setter
    def domain_entity_qos_library_name(self, arg1: str) -> None:
        """
        The QoS library name containing the QoS profile from which the all the entities defined under the participant configuraton are created.
        """
    @builtins.property
    def domain_entity_qos_profile_name(self) -> str:
        """
        The QoS profile name from which the all the entities defined under the participant configuraton are created.

        :type: str
        """
    @domain_entity_qos_profile_name.setter
    def domain_entity_qos_profile_name(self, arg1: str) -> None:
        """
        The QoS profile name from which the all the entities defined under the participant configuraton are created.
        """
    @builtins.property
    def domain_id(self) -> int:
        """
        The domain id from which the DomainParticipant is created.

        :type: int
        """
    @domain_id.setter
    def domain_id(self, arg1: int) -> None:
        """
        The domain id from which the DomainParticipant is created.
        """
    @builtins.property
    def participant_name(self) -> str:
        """
        The name assigned to the DomainParticipant.

        :type: str
        """
    @participant_name.setter
    def participant_name(self, arg1: str) -> None:
        """
        The name assigned to the DomainParticipant.
        """
    @builtins.property
    def participant_qos_library_name(self) -> str:
        """
        The name of the library containing the DomainParticipant's QoS.

        :type: str
        """
    @participant_qos_library_name.setter
    def participant_qos_library_name(self, arg1: str) -> None:
        """
        The name of the library containing the DomainParticipant's QoS.
        """
    @builtins.property
    def participant_qos_profile_name(self) -> str:
        """
        The name of the profile containing the DomainParticipant's QoS.

        :type: str
        """
    @participant_qos_profile_name.setter
    def participant_qos_profile_name(self, arg1: str) -> None:
        """
        The name of the profile containing the DomainParticipant's QoS.
        """
    DOMAIN_ID_USE_XML_CONFIG: int
    ENTITY_NAME_USE_XML_CONFIG: str
    QOS_ELEMENT_NAME_USE_XML_CONFIG: str
    __hash__: NoneType
    pass
class DomainParticipantFactoryQos():
    def __eq__(self, arg0: rti.connextdds.DomainParticipantFactoryQos) -> bool: 
        """
        Test for equality
        """
    def __init__(self) -> None: 
        """
        Create a DomainParticipantFactoryQos with the default value for each policy.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityFactory) -> rti.connextdds.DomainParticipantFactoryQos: 
        """
        Set the EntityFactoryQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.SystemResourceLimits) -> rti.connextdds.DomainParticipantFactoryQos: 
        """
        Set the SystemResourceLimitsQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Monitoring) -> rti.connextdds.DomainParticipantFactoryQos: 
        """
        Set the MonitoringQoS.
        """
    def __ne__(self, arg0: rti.connextdds.DomainParticipantFactoryQos) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityFactory) -> rti.connextdds.DomainParticipantFactoryQos: 
        """
        Get the EntityFactoryQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.SystemResourceLimits) -> rti.connextdds.DomainParticipantFactoryQos: 
        """
        Get the SystemResourceLimitsQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Monitoring) -> rti.connextdds.DomainParticipantFactoryQos: 
        """
        Get the MonitoringQoS.
        """
    def __str__(self) -> str: ...
    def to_string(self, format: rti.connextdds.QosPrintFormat = QosPrintFormat(), base: typing.Optional[rti.connextdds.DomainParticipantFactoryQos] = None, print_all: bool = False) -> str: 
        """
        Convert QoS to string based on params.
        """
    @builtins.property
    def entity_factory(self) -> EntityFactory:
        """
        Get/set EntityFactory QoS.

        :type: EntityFactory
        """
    @entity_factory.setter
    def entity_factory(self, arg1: EntityFactory) -> None:
        """
        Get/set EntityFactory QoS.
        """
    @builtins.property
    def monitoring(self) -> Monitoring:
        """
        Get/set Monitoring QoS.

        :type: Monitoring
        """
    @monitoring.setter
    def monitoring(self, arg1: Monitoring) -> None:
        """
        Get/set Monitoring QoS.
        """
    @builtins.property
    def system_resource_limits(self) -> SystemResourceLimits:
        """
        Get/set SystemResourceLimits QoS.

        :type: SystemResourceLimits
        """
    @system_resource_limits.setter
    def system_resource_limits(self, arg1: SystemResourceLimits) -> None:
        """
        Get/set SystemResourceLimits QoS.
        """
    __hash__: NoneType
    pass
class PublisherListener(AnyDataWriterListener):
    def __init__(self) -> None: ...
    pass
class DomainParticipantProtocolStatus():
    """
    Protocol status of a DomainParticipant
    """
    @builtins.property
    def corrupted_rtps_message_count(self) -> int:
        """
        The number of corrupted RTPS messages detected by the domain participant.

        :type: int
        """
    @builtins.property
    def corrupted_rtps_message_count_change(self) -> int:
        """
        The incremental change in the number of corrupted RTPS messages detected by the domain participant since the last time the status was read.

        :type: int
        """
    @builtins.property
    def last_corrupted_message_timestamp(self) -> Time:
        """
        The timestamp when the last corrupted RTPS message was detected by the domain participant.

        :type: Time
        """
    pass
class DomainParticipantQos():
    def __eq__(self, arg0: rti.connextdds.DomainParticipantQos) -> bool: 
        """
        Test for equality
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a DomainParticipantQos with the default value for each policy.
        """
    @typing.overload
    def __init__(self, participant: rti.connextdds.DomainParticipant) -> None: 
        """
        Create a DomainParticipantQos with settings equivalent to those of the provided DomainParticipant object.
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.DomainParticipantQos) -> None: 
        """
        Create a copy of a DomainParticipantQos object.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.UserData) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the UserDataQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityFactory) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the EntityFactoryQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.WireProtocol) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the WireProtocolQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportBuiltin) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the TransportBuiltinQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Discovery) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the DiscoveryQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DomainParticipantResourceLimits) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the DomainParticipantResourceLimitsQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Event) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the EventQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.ReceiverPool) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the ReceiverPoolQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Database) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the DatabaseQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DiscoveryConfig) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the DiscoveryConfigQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Property) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the PropertyQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the EntityNameQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportMulticastMapping) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the TransportMulticastMappingQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Partition) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the PartitionQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportUnicast) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the TransportUnicastQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Service) -> rti.connextdds.DomainParticipantQos: 
        """
        Set the ServiceQoS.
        """
    def __ne__(self, arg0: rti.connextdds.DomainParticipantQos) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.UserData) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the UserDataQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityFactory) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the EntityFactoryQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.WireProtocol) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the WireProtocolQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportBuiltin) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the TransportBuiltinQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Discovery) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the DiscoveryQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DomainParticipantResourceLimits) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the DomainParticipantResourceLimitsQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Event) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the EventQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.ReceiverPool) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the ReceiverPoolQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Database) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the DatabaseQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DiscoveryConfig) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the DiscoveryConfigQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Property) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the PropertyQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the EntityNameQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportMulticastMapping) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the TransportMulticastMappingQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Partition) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the PartitionQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportUnicast) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the TransportUnicastQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Service) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the ServiceQoS.
        """
    def __str__(self) -> str: ...
    def to_string(self, format: rti.connextdds.QosPrintFormat = QosPrintFormat(), base: typing.Optional[rti.connextdds.DomainParticipantQos] = None, print_all: bool = False) -> str: 
        """
        Convert QoS to string based on params.
        """
    @builtins.property
    def database(self) -> Database:
        """
        Get/set Database QoS.

        :type: Database
        """
    @database.setter
    def database(self, arg1: Database) -> None:
        """
        Get/set Database QoS.
        """
    @builtins.property
    def default_unicast(self) -> TransportUnicast:
        """
        Get/set TransportUnicast QoS.

        :type: TransportUnicast
        """
    @default_unicast.setter
    def default_unicast(self, arg1: TransportUnicast) -> None:
        """
        Get/set TransportUnicast QoS.
        """
    @builtins.property
    def discovery(self) -> Discovery:
        """
        Get/set Discovery QoS.

        :type: Discovery
        """
    @discovery.setter
    def discovery(self, arg1: Discovery) -> None:
        """
        Get/set Discovery QoS.
        """
    @builtins.property
    def discovery_config(self) -> DiscoveryConfig:
        """
        Get/set DiscoveryConfig QoS.

        :type: DiscoveryConfig
        """
    @discovery_config.setter
    def discovery_config(self, arg1: DiscoveryConfig) -> None:
        """
        Get/set DiscoveryConfig QoS.
        """
    @builtins.property
    def entity_factory(self) -> EntityFactory:
        """
        Get/set EntityFactory QoS.

        :type: EntityFactory
        """
    @entity_factory.setter
    def entity_factory(self, arg1: EntityFactory) -> None:
        """
        Get/set EntityFactory QoS.
        """
    @builtins.property
    def event(self) -> Event:
        """
        Get/set Event QoS.

        :type: Event
        """
    @event.setter
    def event(self, arg1: Event) -> None:
        """
        Get/set Event QoS.
        """
    @builtins.property
    def participant_name(self) -> EntityName:
        """
        Get/set EntityName QoS.

        :type: EntityName
        """
    @participant_name.setter
    def participant_name(self, arg1: EntityName) -> None:
        """
        Get/set EntityName QoS.
        """
    @builtins.property
    def partition(self) -> Partition:
        """
        Get/set Partition QoS.

        :type: Partition
        """
    @partition.setter
    def partition(self, arg1: Partition) -> None:
        """
        Get/set Partition QoS.
        """
    @builtins.property
    def property(self) -> Property:
        """
        Get/set Property QoS.

        :type: Property
        """
    @property.setter
    def property(self, arg1: Property) -> None:
        """
        Get/set Property QoS.
        """
    @builtins.property
    def receiver_pool(self) -> ReceiverPool:
        """
        Get/set ReceiverPool QoS.

        :type: ReceiverPool
        """
    @receiver_pool.setter
    def receiver_pool(self, arg1: ReceiverPool) -> None:
        """
        Get/set ReceiverPool QoS.
        """
    @builtins.property
    def resource_limits(self) -> DomainParticipantResourceLimits:
        """
        Get/set DomainParticipantResourceLimits QoS.

        :type: DomainParticipantResourceLimits
        """
    @resource_limits.setter
    def resource_limits(self, arg1: DomainParticipantResourceLimits) -> None:
        """
        Get/set DomainParticipantResourceLimits QoS.
        """
    @builtins.property
    def service(self) -> Service:
        """
        Get/set Service QoS.

        :type: Service
        """
    @service.setter
    def service(self, arg1: Service) -> None:
        """
        Get/set Service QoS.
        """
    @builtins.property
    def transport_builtin(self) -> TransportBuiltin:
        """
        Get/set TransportBuiltin QoS.

        :type: TransportBuiltin
        """
    @transport_builtin.setter
    def transport_builtin(self, arg1: TransportBuiltin) -> None:
        """
        Get/set TransportBuiltin QoS.
        """
    @builtins.property
    def transport_multicast_mapping(self) -> TransportMulticastMapping:
        """
        Get/set TransportMulticastMapping QoS.

        :type: TransportMulticastMapping
        """
    @transport_multicast_mapping.setter
    def transport_multicast_mapping(self, arg1: TransportMulticastMapping) -> None:
        """
        Get/set TransportMulticastMapping QoS.
        """
    @builtins.property
    def user_data(self) -> UserData:
        """
        Get/set UserData QoS.

        :type: UserData
        """
    @user_data.setter
    def user_data(self, arg1: UserData) -> None:
        """
        Get/set UserData QoS.
        """
    @builtins.property
    def wire_protocol(self) -> WireProtocol:
        """
        Get/set WireProtocol QoS.

        :type: WireProtocol
        """
    @wire_protocol.setter
    def wire_protocol(self, arg1: WireProtocol) -> None:
        """
        Get/set WireProtocol QoS.
        """
    __hash__: NoneType
    pass
class DomainParticipantResourceLimits():
    def __eq__(self, arg0: rti.connextdds.DomainParticipantResourceLimits) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default policy.
        """
    def __ne__(self, arg0: rti.connextdds.DomainParticipantResourceLimits) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def channel_filter_expression_max_length(self) -> int:
        """
        Maximum length of a channel ChannelSettings.filter_expression in a MultiChannel DataWriter.

        :type: int
        """
    @channel_filter_expression_max_length.setter
    def channel_filter_expression_max_length(self, arg1: int) -> None:
        """
        Maximum length of a channel ChannelSettings.filter_expression in a MultiChannel DataWriter.
        """
    @builtins.property
    def channel_seq_max_length(self) -> int:
        """
        Maximum number of channels that can be specified in MultiChannel for MultiChannel DataWriters.

        :type: int
        """
    @channel_seq_max_length.setter
    def channel_seq_max_length(self, arg1: int) -> None:
        """
        Maximum number of channels that can be specified in MultiChannel for MultiChannel DataWriters.
        """
    @builtins.property
    def content_filter_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to content filter.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @content_filter_allocation.setter
    def content_filter_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to content filter.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def content_filter_hash_buckets(self) -> int:
        """
        Number of hash buckets for content filters.

        :type: int
        """
    @content_filter_hash_buckets.setter
    def content_filter_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for content filters.
        """
    @builtins.property
    def content_filtered_topic_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to content filtered topic.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @content_filtered_topic_allocation.setter
    def content_filtered_topic_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to content filtered topic.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def content_filtered_topic_hash_buckets(self) -> int:
        """
        Number of hash buckets for content filtered topics.

        :type: int
        """
    @content_filtered_topic_hash_buckets.setter
    def content_filtered_topic_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for content filtered topics.
        """
    @builtins.property
    def contentfilter_property_max_length(self) -> int:
        """
        This field is the maximum length of all data related to a Content-filtered topic.

        :type: int
        """
    @contentfilter_property_max_length.setter
    def contentfilter_property_max_length(self, arg1: int) -> None:
        """
        This field is the maximum length of all data related to a Content-filtered topic.
        """
    @builtins.property
    def deserialized_type_object_dynamic_allocation_threshold(self) -> int:
        """
        A threshold, in bytes, for dynamic memory allocation for the deserialized TypeObject.

        :type: int
        """
    @deserialized_type_object_dynamic_allocation_threshold.setter
    def deserialized_type_object_dynamic_allocation_threshold(self, arg1: int) -> None:
        """
        A threshold, in bytes, for dynamic memory allocation for the deserialized TypeObject.
        """
    @builtins.property
    def flow_controller_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to flow controllers.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @flow_controller_allocation.setter
    def flow_controller_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to flow controllers.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def flow_controller_hash_buckets(self) -> int:
        """
        Number of hash buckets for flow controllers.

        :type: int
        """
    @flow_controller_hash_buckets.setter
    def flow_controller_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for flow controllers.
        """
    @builtins.property
    def ignored_entity_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to ignored entities.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @ignored_entity_allocation.setter
    def ignored_entity_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to ignored entities.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def ignored_entity_hash_buckets(self) -> int:
        """
        Number of hash buckets for ignored entities.

        :type: int
        """
    @ignored_entity_hash_buckets.setter
    def ignored_entity_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for ignored entities.
        """
    @builtins.property
    def ignored_entity_replacement_kind(self) -> IgnoredEntityReplacementKind:
        """
        Replacement policy for the ignored entities. It sets what entity can be replaced when resource limits set in DomainParticipantResourceLimits.ignored_entity_allocation are reached.

        :type: IgnoredEntityReplacementKind
        """
    @ignored_entity_replacement_kind.setter
    def ignored_entity_replacement_kind(self, arg1: IgnoredEntityReplacementKind) -> None:
        """
        Replacement policy for the ignored entities. It sets what entity can be replaced when resource limits set in DomainParticipantResourceLimits.ignored_entity_allocation are reached.
        """
    @builtins.property
    def local_publisher_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to local Publisher.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @local_publisher_allocation.setter
    def local_publisher_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to local Publisher.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def local_publisher_hash_buckets(self) -> int:
        """
        Number of hash buckets for local Publisher.

        :type: int
        """
    @local_publisher_hash_buckets.setter
    def local_publisher_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for local Publisher.
        """
    @builtins.property
    def local_reader_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to local DataReaders.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @local_reader_allocation.setter
    def local_reader_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to local DataReaders.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def local_reader_hash_buckets(self) -> int:
        """
        Hash buckets settings applied to local DataReaders.

        :type: int
        """
    @local_reader_hash_buckets.setter
    def local_reader_hash_buckets(self, arg1: int) -> None:
        """
        Hash buckets settings applied to local DataReaders.
        """
    @builtins.property
    def local_subscriber_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to local Subscriber.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @local_subscriber_allocation.setter
    def local_subscriber_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to local Subscriber.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def local_subscriber_hash_buckets(self) -> int:
        """
        Number of hash buckets for local Subscriber.

        :type: int
        """
    @local_subscriber_hash_buckets.setter
    def local_subscriber_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for local Subscriber.
        """
    @builtins.property
    def local_topic_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to local Topic.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @local_topic_allocation.setter
    def local_topic_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to local Topic.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def local_topic_hash_buckets(self) -> int:
        """
        Number of hash buckets for local Topic.

        :type: int
        """
    @local_topic_hash_buckets.setter
    def local_topic_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for local Topic.
        """
    @builtins.property
    def local_writer_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to local DataWriters.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @local_writer_allocation.setter
    def local_writer_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to local DataWriters.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def local_writer_hash_buckets(self) -> int:
        """
        Hash buckets settings applied to local DataWriters.

        :type: int
        """
    @local_writer_hash_buckets.setter
    def local_writer_hash_buckets(self, arg1: int) -> None:
        """
        Hash buckets settings applied to local DataWriters.
        """
    @builtins.property
    def matching_reader_writer_pair_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to matching local reader and remote/local writer pairs.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @matching_reader_writer_pair_allocation.setter
    def matching_reader_writer_pair_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to matching local reader and remote/local writer pairs.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def matching_reader_writer_pair_hash_buckets(self) -> int:
        """
        Number of hash buckets for matching local reader and remote/local writer pairs.

        :type: int
        """
    @matching_reader_writer_pair_hash_buckets.setter
    def matching_reader_writer_pair_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for matching local reader and remote/local writer pairs.
        """
    @builtins.property
    def matching_writer_reader_pair_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to matching local writer and remote/local reader pairs.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @matching_writer_reader_pair_allocation.setter
    def matching_writer_reader_pair_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to matching local writer and remote/local reader pairs.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def matching_writer_reader_pair_hash_buckets(self) -> int:
        """
        Number of hash buckets for matching local writer and remote/local reader pairs.

        :type: int
        """
    @matching_writer_reader_pair_hash_buckets.setter
    def matching_writer_reader_pair_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for matching local writer and remote/local reader pairs.
        """
    @builtins.property
    def max_endpoint_group_cumulative_characters(self) -> int:
        """
        Maximum number of combined role_name characters allowed in all EndpointGroup in a Availability.

        :type: int
        """
    @max_endpoint_group_cumulative_characters.setter
    def max_endpoint_group_cumulative_characters(self, arg1: int) -> None:
        """
        Maximum number of combined role_name characters allowed in all EndpointGroup in a Availability.
        """
    @builtins.property
    def max_endpoint_groups(self) -> int:
        """
        Maximum number of EndpointGroup allowable in a Availability.

        :type: int
        """
    @max_endpoint_groups.setter
    def max_endpoint_groups(self, arg1: int) -> None:
        """
        Maximum number of EndpointGroup allowable in a Availability.
        """
    @builtins.property
    def max_gather_destinations(self) -> int:
        """
        Maximum number of destinations per RTI Connext send.

        :type: int
        """
    @max_gather_destinations.setter
    def max_gather_destinations(self, arg1: int) -> None:
        """
        Maximum number of destinations per RTI Connext send.
        """
    @builtins.property
    def max_partition_cumulative_characters(self) -> int:
        """
        Maximum number of combined characters allowable in all partition names in a Partition.

        :type: int
        """
    @max_partition_cumulative_characters.setter
    def max_partition_cumulative_characters(self, arg1: int) -> None:
        """
        Maximum number of combined characters allowable in all partition names in a Partition.
        """
    @builtins.property
    def max_partitions(self) -> int:
        """
        Maximum number of partition name strings allowable in a Partition.

        :type: int
        """
    @max_partitions.setter
    def max_partitions(self, arg1: int) -> None:
        """
        Maximum number of partition name strings allowable in a Partition.
        """
    @builtins.property
    def outstanding_asynchronous_sample_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to the maximum number of samples (from DataWriter) waiting to be asynchronously written.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @outstanding_asynchronous_sample_allocation.setter
    def outstanding_asynchronous_sample_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to the maximum number of samples (from DataWriter) waiting to be asynchronously written.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def participant_property_list_max_length(self) -> int:
        """
        Maximum number of properties associated with the DomainParticipant.

        :type: int
        """
    @participant_property_list_max_length.setter
    def participant_property_list_max_length(self, arg1: int) -> None:
        """
        Maximum number of properties associated with the DomainParticipant.
        """
    @builtins.property
    def participant_property_string_max_length(self) -> int:
        """
        Maximum string length of the properties associated with the DomainParticipant.

        :type: int
        """
    @participant_property_string_max_length.setter
    def participant_property_string_max_length(self, arg1: int) -> None:
        """
        Maximum string length of the properties associated with the DomainParticipant.
        """
    @builtins.property
    def participant_user_data_max_length(self) -> int:
        """
        Maximum length of user data in DomainParticipantQos and ParticipantBuiltinTopicData.

        :type: int
        """
    @participant_user_data_max_length.setter
    def participant_user_data_max_length(self, arg1: int) -> None:
        """
        Maximum length of user data in DomainParticipantQos and ParticipantBuiltinTopicData.
        """
    @builtins.property
    def publisher_group_data_max_length(self) -> int:
        """
        Maximum length of group data in PublisherQos and PublicationBuiltinTopicData.

        :type: int
        """
    @publisher_group_data_max_length.setter
    def publisher_group_data_max_length(self, arg1: int) -> None:
        """
        Maximum length of group data in PublisherQos and PublicationBuiltinTopicData.
        """
    @builtins.property
    def query_condition_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to query condition pool.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @query_condition_allocation.setter
    def query_condition_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to query condition pool.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def read_condition_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to read condition pool.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @read_condition_allocation.setter
    def read_condition_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to read condition pool.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def reader_data_tag_list_max_length(self) -> int:
        """
        Maximum number of data tags associated with a DataReader.

        :type: int
        """
    @reader_data_tag_list_max_length.setter
    def reader_data_tag_list_max_length(self, arg1: int) -> None:
        """
        Maximum number of data tags associated with a DataReader.
        """
    @builtins.property
    def reader_data_tag_string_max_length(self) -> int:
        """
        Maximum string length of the data tags associated with a DataReader.

        :type: int
        """
    @reader_data_tag_string_max_length.setter
    def reader_data_tag_string_max_length(self, arg1: int) -> None:
        """
        Maximum string length of the data tags associated with a DataReader.
        """
    @builtins.property
    def reader_property_list_max_length(self) -> int:
        """
        Maximum number of properties associated with a DataReader.

        :type: int
        """
    @reader_property_list_max_length.setter
    def reader_property_list_max_length(self, arg1: int) -> None:
        """
        Maximum number of properties associated with a DataReader.
        """
    @builtins.property
    def reader_property_string_max_length(self) -> int:
        """
        Maximum string length of the properties associated with a DataReader.

        :type: int
        """
    @reader_property_string_max_length.setter
    def reader_property_string_max_length(self, arg1: int) -> None:
        """
        Maximum string length of the properties associated with a DataReader.
        """
    @builtins.property
    def reader_user_data_max_length(self) -> int:
        """
        Maximum length of user data in DataReaderQos and SubscriptionBuiltinTopicData.

        :type: int
        """
    @reader_user_data_max_length.setter
    def reader_user_data_max_length(self, arg1: int) -> None:
        """
        Maximum length of user data in DataReaderQos and SubscriptionBuiltinTopicData.
        """
    @builtins.property
    def remote_participant_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to remote DomainParticipants.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @remote_participant_allocation.setter
    def remote_participant_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to remote DomainParticipants.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def remote_participant_hash_buckets(self) -> int:
        """
        Number of hash buckets for remote DomainParticipants.

        :type: int
        """
    @remote_participant_hash_buckets.setter
    def remote_participant_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for remote DomainParticipants.
        """
    @builtins.property
    def remote_reader_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to remote DataReaders.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @remote_reader_allocation.setter
    def remote_reader_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to remote DataReaders.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def remote_reader_hash_buckets(self) -> int:
        """
        Number of hash buckets for remote DataReaders.

        :type: int
        """
    @remote_reader_hash_buckets.setter
    def remote_reader_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for remote DataReaders.
        """
    @builtins.property
    def remote_topic_query_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to remote TopicQueries.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @remote_topic_query_allocation.setter
    def remote_topic_query_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to remote TopicQueries.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def remote_topic_query_hash_buckets(self) -> int:
        """
        Number of hash buckets for remote TopicQueries.

        :type: int
        """
    @remote_topic_query_hash_buckets.setter
    def remote_topic_query_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for remote TopicQueries.
        """
    @builtins.property
    def remote_writer_allocation(self) -> AllocationSettings:
        """
        Allocation settings applied to remote DataWriters.

        This property's getter returns a deep copy.

        :type: AllocationSettings
        """
    @remote_writer_allocation.setter
    def remote_writer_allocation(self, arg1: AllocationSettings) -> None:
        """
        Allocation settings applied to remote DataWriters.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def remote_writer_hash_buckets(self) -> int:
        """
        Number of hash buckets for remote DataWriters.

        :type: int
        """
    @remote_writer_hash_buckets.setter
    def remote_writer_hash_buckets(self, arg1: int) -> None:
        """
        Number of hash buckets for remote DataWriters.
        """
    @builtins.property
    def serialized_type_object_dynamic_allocation_threshold(self) -> int:
        """
        A threshold, in bytes, for dynamic memory allocation for the serialized TypeObject.

        :type: int
        """
    @serialized_type_object_dynamic_allocation_threshold.setter
    def serialized_type_object_dynamic_allocation_threshold(self, arg1: int) -> None:
        """
        A threshold, in bytes, for dynamic memory allocation for the serialized TypeObject.
        """
    @builtins.property
    def shmem_ref_transfer_mode_max_segments(self) -> int:
        """
        Maximum number of segments created by all DataWriters belonging to a DomainParticipant.

        :type: int
        """
    @shmem_ref_transfer_mode_max_segments.setter
    def shmem_ref_transfer_mode_max_segments(self, arg1: int) -> None:
        """
        Maximum number of segments created by all DataWriters belonging to a DomainParticipant.
        """
    @builtins.property
    def subscriber_group_data_max_length(self) -> int:
        """
        Maximum length of group data in SubscriberQos and SubscriptionBuiltinTopicData.

        :type: int
        """
    @subscriber_group_data_max_length.setter
    def subscriber_group_data_max_length(self, arg1: int) -> None:
        """
        Maximum length of group data in SubscriberQos and SubscriptionBuiltinTopicData.
        """
    @builtins.property
    def topic_data_max_length(self) -> int:
        """
        Maximum length of topic data in TopicQos, TopicBuiltinTopicData, PublicationBuiltinTopicData and SubscriptionBuiltinTopicData.

        :type: int
        """
    @topic_data_max_length.setter
    def topic_data_max_length(self, arg1: int) -> None:
        """
        Maximum length of topic data in TopicQos, TopicBuiltinTopicData, PublicationBuiltinTopicData and SubscriptionBuiltinTopicData.
        """
    @builtins.property
    def transport_info_list_max_length(self) -> int:
        """
        Maximum number of installed transports to send and receive information about in ParticipantBuiltinTopicData.transport_info.

        :type: int
        """
    @transport_info_list_max_length.setter
    def transport_info_list_max_length(self, arg1: int) -> None:
        """
        Maximum number of installed transports to send and receive information about in ParticipantBuiltinTopicData.transport_info.
        """
    @builtins.property
    def type_code_max_serialized_length(self) -> int:
        """
        Maximum size of serialized string for type code.

        :type: int
        """
    @type_code_max_serialized_length.setter
    def type_code_max_serialized_length(self, arg1: int) -> None:
        """
        Maximum size of serialized string for type code.
        """
    @builtins.property
    def type_object_max_deserialized_length(self) -> int:
        """
        The maximum number of bytes that a deserialized TypeObject can consume.

        :type: int
        """
    @type_object_max_deserialized_length.setter
    def type_object_max_deserialized_length(self, arg1: int) -> None:
        """
        The maximum number of bytes that a deserialized TypeObject can consume.
        """
    @builtins.property
    def type_object_max_serialized_length(self) -> int:
        """
        The maximum length, in bytes, that the buffer to serialize a TypeObject can consume.

        :type: int
        """
    @type_object_max_serialized_length.setter
    def type_object_max_serialized_length(self, arg1: int) -> None:
        """
        The maximum length, in bytes, that the buffer to serialize a TypeObject can consume.
        """
    @builtins.property
    def writer_data_tag_list_max_length(self) -> int:
        """
        Maximum number of data tags associated with a DataWriter.

        :type: int
        """
    @writer_data_tag_list_max_length.setter
    def writer_data_tag_list_max_length(self, arg1: int) -> None:
        """
        Maximum number of data tags associated with a DataWriter.
        """
    @builtins.property
    def writer_data_tag_string_max_length(self) -> int:
        """
        Maximum string length of the data tags associated with a DataWriter.

        :type: int
        """
    @writer_data_tag_string_max_length.setter
    def writer_data_tag_string_max_length(self, arg1: int) -> None:
        """
        Maximum string length of the data tags associated with a DataWriter.
        """
    @builtins.property
    def writer_property_list_max_length(self) -> int:
        """
        Maximum number of properties associated with a DataWriter.

        :type: int
        """
    @writer_property_list_max_length.setter
    def writer_property_list_max_length(self, arg1: int) -> None:
        """
        Maximum number of properties associated with a DataWriter.
        """
    @builtins.property
    def writer_property_string_max_length(self) -> int:
        """
        Maximum string length of the properties associated with a DataWriter.

        :type: int
        """
    @writer_property_string_max_length.setter
    def writer_property_string_max_length(self, arg1: int) -> None:
        """
        Maximum string length of the properties associated with a DataWriter.
        """
    @builtins.property
    def writer_user_data_max_length(self) -> int:
        """
        Maximum length of user data in DataWriterQos and PublicationBuiltinTopicData.

        :type: int
        """
    @writer_user_data_max_length.setter
    def writer_user_data_max_length(self, arg1: int) -> None:
        """
        Maximum length of user data in DataWriterQos and PublicationBuiltinTopicData.
        """
    __hash__: NoneType
    pass
class DomainParticipantSeq():
    def __add__(self, arg0: rti.connextdds.DomainParticipantSeq) -> rti.connextdds.DomainParticipantSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.DomainParticipant) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.DomainParticipantSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.DomainParticipantSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.DomainParticipant: ...
    def __iadd__(self, arg0: rti.connextdds.DomainParticipantSeq) -> rti.connextdds.DomainParticipantSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.DomainParticipantSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DomainParticipantSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.DomainParticipant]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.DomainParticipantSeq: ...
    def __ne__(self, arg0: rti.connextdds.DomainParticipantSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.DomainParticipantSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.DomainParticipant) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.DomainParticipantSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.DomainParticipant) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.DomainParticipant) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.DomainParticipantSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.DomainParticipant) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.DomainParticipant: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.DomainParticipant: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.DomainParticipant) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class Float64Seq():
    def __add__(self, arg0: rti.connextdds.Float64Seq) -> rti.connextdds.Float64Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: float) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Float64Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Float64Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> float: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Float64Seq) -> rti.connextdds.Float64Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Float64Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Float64Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Float64Seq: ...
    def __ne__(self, arg0: rti.connextdds.Float64Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Float64Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Float64Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: float) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: float) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Float64Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: float) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> float: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> float: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: float) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Float64Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Float64Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Float64Type
        """
    def __ne__(self, arg0: rti.connextdds.Float64Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class Durability():
    def __eq__(self, arg0: rti.connextdds.Durability) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty Durability QoS policy.
        """
    @typing.overload
    def __init__(self, kind: rti.connextdds.DurabilityKind) -> None: 
        """
        Create a Durability QoS policy with the given kind.
        """
    def __ne__(self, arg0: rti.connextdds.Durability) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def direct_communication(self) -> bool:
        """
        Get/set whether a DataReader should receive samples directly from a TRANSIENT or PERSISTENT DataWriter.

        :type: bool
        """
    @direct_communication.setter
    def direct_communication(self, arg1: bool) -> None:
        """
        Get/set whether a DataReader should receive samples directly from a TRANSIENT or PERSISTENT DataWriter.
        """
    @builtins.property
    def kind(self) -> DurabilityKind:
        """
        Get/set the Durability kind.

        :type: DurabilityKind
        """
    @kind.setter
    def kind(self, arg1: DurabilityKind) -> None:
        """
        Get/set the Durability kind.
        """
    @builtins.property
    def storage_settings(self) -> PersistentStorageSettings:
        """
        Configures durable writer history and durable reader state.

        :type: PersistentStorageSettings
        """
    @storage_settings.setter
    def storage_settings(self, arg1: PersistentStorageSettings) -> None:
        """
        Configures durable writer history and durable reader state.
        """
    @builtins.property
    def writer_depth(self) -> int:
        """
        The number of samples a durable DataWriter will send to a late joining DataReader.

        :type: int
        """
    @writer_depth.setter
    def writer_depth(self, arg1: int) -> None:
        """
        The number of samples a durable DataWriter will send to a late joining DataReader.
        """
    AUTO_WRITER_DEPTH: int
    __hash__: NoneType
    persistent: rti.connextdds.Durability
    transient: rti.connextdds.Durability
    transient_local: rti.connextdds.Durability
    volatile: rti.connextdds.Durability
    pass
class DurabilityKind():
    class DurabilityKind():
        """
        Members:

          VOLATILE : [default] RTI Connext does not need to keep any samples of data instances on behalf of any DataReader that is unknown by the DataWriter at the time the instance is written.

        In other words, RTI Connext will only attempt to provide the data to existing subscribers.

        This option does not require RTI Persistence Service.

          TRANSIENT_LOCAL : RTI Connext will attempt to keep some samples so that they can be delivered to any potential late-joining DataReader.

        Which particular samples are kept depends on other QoS such as History and ResourceLimits. RTI Connext is only required to keep the data in memory of the DataWriter that wrote the data.

        Data is not required to survive the DataWriter.

        For this setting to be effective, you must also set the Reliability.kind to ReliabilityKind.RELIABLE. 

        This option does not require RTI Persistence Service.

          TRANSIENT : RTI Connext will attempt to keep some samples so that they can be delivered to any potential late-joining DataReader.

        Which particular samples are kept depends on other QoS such as History and ResourceLimits. RTI Connext is only required to keep the data in memory and not in permanent storage.

        Data is not tied to the lifecycle of the DataWriter.

        Data will survive the DataWriter.

        This option requires RTI Persistence Service.

          PERSISTENT : Data is kept on permanent storage, so that they can outlive a system session.

        This option requires RTI Persistence Service.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        PERSISTENT: rti.connextdds.DurabilityKind.DurabilityKind
        TRANSIENT: rti.connextdds.DurabilityKind.DurabilityKind
        TRANSIENT_LOCAL: rti.connextdds.DurabilityKind.DurabilityKind
        VOLATILE: rti.connextdds.DurabilityKind.DurabilityKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.DurabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.DurabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.DurabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DurabilityKind.DurabilityKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.DurabilityKind.DurabilityKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.DurabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.DurabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.DurabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> DurabilityKind.DurabilityKind:
        """
        Retrieves the actual enumerated value.

        :type: DurabilityKind.DurabilityKind
        """
    PERSISTENT: rti.connextdds.DurabilityKind.DurabilityKind
    TRANSIENT: rti.connextdds.DurabilityKind.DurabilityKind
    TRANSIENT_LOCAL: rti.connextdds.DurabilityKind.DurabilityKind
    VOLATILE: rti.connextdds.DurabilityKind.DurabilityKind
    __hash__: NoneType
    pass
class DurabilityService():
    def __eq__(self, arg0: rti.connextdds.DurabilityService) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, service_cleanup_delay: rti.connextdds.Duration, history_kind: rti.connextdds.HistoryKind, history_depth: int, max_samples: int, max_instances: int, max_samples_per_instance: int) -> None: 
        """
        Creates an instance with all the parameters set.
        """
    def __ne__(self, arg0: rti.connextdds.DurabilityService) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def history_depth(self) -> int:
        """
        Controls when the service is able to remove all information regarding a data instances.

        :type: int
        """
    @history_depth.setter
    def history_depth(self, arg1: int) -> None:
        """
        Controls when the service is able to remove all information regarding a data instances.
        """
    @builtins.property
    def history_kind(self) -> HistoryKind:
        """
        Controls when the service is able to remove all information regarding a data instances.

        :type: HistoryKind
        """
    @history_kind.setter
    def history_kind(self, arg1: HistoryKind) -> None:
        """
        Controls when the service is able to remove all information regarding a data instances.
        """
    @builtins.property
    def max_instances(self) -> int:
        """
        Controls when the service is able to remove all information regarding a data instances.

        :type: int
        """
    @max_instances.setter
    def max_instances(self, arg1: int) -> None:
        """
        Controls when the service is able to remove all information regarding a data instances.
        """
    @builtins.property
    def max_samples(self) -> int:
        """
        Controls when the service is able to remove all information regarding a data instances.

        :type: int
        """
    @max_samples.setter
    def max_samples(self, arg1: int) -> None:
        """
        Controls when the service is able to remove all information regarding a data instances.
        """
    @builtins.property
    def max_samples_per_instance(self) -> int:
        """
        Controls when the service is able to remove all information regarding a data instances.

        :type: int
        """
    @max_samples_per_instance.setter
    def max_samples_per_instance(self, arg1: int) -> None:
        """
        Controls when the service is able to remove all information regarding a data instances.
        """
    @builtins.property
    def service_cleanup_delay(self) -> Duration:
        """
        Controls when the service is able to remove all information regarding a data instances.

        :type: Duration
        """
    @service_cleanup_delay.setter
    def service_cleanup_delay(self, arg1: Duration) -> None:
        """
        Controls when the service is able to remove all information regarding a data instances.
        """
    __hash__: NoneType
    pass
class Duration():
    def __add__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Duration: 
        """
        Add two Duration objects.
        """
    def __eq__(self, arg0: rti.connextdds.Duration) -> bool: 
        """
        Compare Duration objects for equality.
        """
    def __float__(self) -> float: 
        """
        Floating point value of Duration in seconds.
        """
    def __ge__(self, arg0: rti.connextdds.Duration) -> bool: 
        """
        Greater-than-or-equal comparison for Duration objects.
        """
    def __gt__(self, arg0: rti.connextdds.Duration) -> bool: 
        """
        Greater than comparison for Duration objects.
        """
    def __iadd__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Duration: 
        """
        Add a Duration to another.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a Duration of 0 seconds.
        """
    @typing.overload
    def __init__(self, seconds: int, nanoseconds: int) -> None: 
        """
        Create a Duration of the specified seconds and nanoseconds.
        """
    @typing.overload
    def __init__(self, duration: datetime.timedelta) -> None: 
        """
        Create a Duration from a datetime.timedelta.
        """
    @typing.overload
    def __init__(self, float_duration: float) -> None: 
        """
        Create a Duration from a floating point duration in seconds.
        """
    @typing.overload
    def __init__(self, seconds: int) -> None: 
        """
        Create a Duration from an integer number of seconds.
        """
    @typing.overload
    def __init__(self, time_tuple: tuple[int, int]) -> None: 
        """
        Create a Duration from a tuple of (sec, nanosec).
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.Duration) -> None: 
        """
        Create a copy of a Duration.
        """
    def __int__(self) -> int: 
        """
        Integer value of Duration in microseconds.
        """
    def __isub__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Duration: 
        """
        Subtract a Duration from another.
        """
    def __le__(self, arg0: rti.connextdds.Duration) -> bool: 
        """
        Less-than-or-equal comparison for Duration object.
        """
    def __lt__(self, arg0: rti.connextdds.Duration) -> bool: 
        """
        Less than comparison for Duration objects.
        """
    def __mul__(self, arg0: int) -> rti.connextdds.Duration: 
        """
        Multiply a Duration by an unsigned int.
        """
    def __ne__(self, arg0: rti.connextdds.Duration) -> bool: 
        """
        Determine if Duration objects are unequal.
        """
    def __repr__(self) -> str: 
        """
        Return the detailed string representation of the Duration.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Duration: 
        """
        Multiply a Duration by an unsigned int.
        """
    def __str__(self) -> str: 
        """
        Return the string representation of the Duration.
        """
    def __sub__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Duration: 
        """
        Subtract two Duration objects.
        """
    def __truediv__(self, arg0: int) -> rti.connextdds.Duration: 
        """
        Divide a Duration by an unsigned int.
        """
    def compare(self, other: rti.connextdds.Duration) -> int: 
        """
        Compare this Duration to another. Returns -1 if this Duration is less, 0 if they are equal, and 1 if this Duration is greate
        """
    @staticmethod
    def from_microseconds(microseconds: int) -> rti.connextdds.Duration: 
        """
        Get a Duration from microseconds.
        """
    @staticmethod
    def from_milliseconds(milliseconds: int) -> rti.connextdds.Duration: 
        """
        Get a Duration from milliseconds.
        """
    @staticmethod
    def from_seconds(seconds: float) -> rti.connextdds.Duration: 
        """
        Get a Duration from seconds
        """
    def to_microseconds(self) -> int: 
        """
        Returns Duration in microseconds.
        """
    def to_milliseconds(self) -> int: 
        """
        Returns Duration in milliseconds.
        """
    def to_seconds(self) -> float: 
        """
        Return the Duration in seconds.
        """
    def to_timedelta(self) -> datetime.timedelta: 
        """
        Return the datetime.timedelta conversion of this Duration.
        """
    @builtins.property
    def nanosec(self) -> int:
        """
        Get/set the number of nanoseconds in the Duration.

        :type: int
        """
    @nanosec.setter
    def nanosec(self, arg1: int) -> None:
        """
        Get/set the number of nanoseconds in the Duration.
        """
    @builtins.property
    def sec(self) -> int:
        """
        Get/set the number of seconds in the Duration.

        :type: int
        """
    @sec.setter
    def sec(self, arg1: int) -> None:
        """
        Get/set the number of seconds in the Duration.
        """
    __hash__: NoneType
    automatic: rti.connextdds.Duration
    infinite: rti.connextdds.Duration
    zero: rti.connextdds.Duration
    pass
class DynamicData():
    class ContentFilter(ContentFilterBase):
        def __init__(self) -> None: ...
        def compile(self, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, old_compile_data: typing.Optional[object]) -> typing.Optional[object]: 
            """
            Compile an instance of the content filter according to the filter expression and parameters of the given data type.
            """
        def evaluate(self, compile_data: typing.Optional[object], sample: rti.connextdds.DynamicData, meta_data: rti.connextdds.FilterSampleInfo) -> bool: 
            """
            Evaluate whether the sample is passing the filter or not according to the sample content.
            """
        def finalize(self, compile_data: typing.Optional[object]) -> None: 
            """
            A previously compiled instance of the content filter is no longer in use and resources can now be cleaned up.
            """
        pass
    class ContentFilteredTopic(DynamicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.DynamicData.ContentFilteredTopic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.DynamicData.Topic, name: str, contentfilter: rti.connextdds.Filter) -> None: 
            """
            Create a ContentFilteredTopic with a name and Filter.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.DynamicData.ITopicDescription) -> None: 
            """
            Cast a TopicDescription to a ContentFilteredTopic.
            """
        def __ne__(self, arg0: rti.connextdds.DynamicData.ContentFilteredTopic) -> bool: 
            """
            Test for inequality.
            """
        def append_to_expression_parameter(self, index: int, extension: str) -> None: 
            """
            Append the extension to the end of parameter at the provided index, separated by a comma.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.DynamicData.ContentFilteredTopic]: 
            """
            Look up a ContentFilteredTopic by its name in the DomainParticipant.
            """
        def remove_from_expression_parameter(self, index: int, remove_term: str) -> None: 
            """
            Removes the specified term from the parameter at the provided index.
            """
        def set_filter(self, arg0: rti.connextdds.Filter) -> None: 
            """
            Set the filter.
            """
        @builtins.property
        def filter_expression(self) -> str:
            """
            Get the filter expression

            :type: str
            """
        @builtins.property
        def filter_parameters(self) -> StringSeq:
            """
            Get/set the filter parameters.

            :type: StringSeq
            """
        @filter_parameters.setter
        def filter_parameters(self, arg1: StringSeq) -> None:
            """
            Get/set the filter parameters.
            """
        @builtins.property
        def topic(self) -> DynamicData.Topic:
            """
            Get the underlying Topic.

            :type: DynamicData.Topic
            """
        __hash__: NoneType
        pass
    class ContentFilteredTopicSeq():
        def __add__(self, arg0: rti.connextdds.DynamicData.ContentFilteredTopicSeq) -> rti.connextdds.DynamicData.ContentFilteredTopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.DynamicData.ContentFilteredTopic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.DynamicData.ContentFilteredTopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.DynamicData.ContentFilteredTopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.DynamicData.ContentFilteredTopic: ...
        def __iadd__(self, arg0: rti.connextdds.DynamicData.ContentFilteredTopicSeq) -> rti.connextdds.DynamicData.ContentFilteredTopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.DynamicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.DynamicData.ContentFilteredTopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.DynamicData.ContentFilteredTopic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.DynamicData.ContentFilteredTopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.DynamicData.ContentFilteredTopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.DynamicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.DynamicData.ContentFilteredTopic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.DynamicData.ContentFilteredTopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.DynamicData.ContentFilteredTopic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.DynamicData.ContentFilteredTopic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.DynamicData.ContentFilteredTopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.DynamicData.ContentFilteredTopic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.DynamicData.ContentFilteredTopic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.DynamicData.ContentFilteredTopic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.DynamicData.ContentFilteredTopic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataReader(IDataReader, IEntity, IAnyDataReader):
        class Selector():
            def __init__(self, datareader: rti.connextdds.DynamicData.DataReader) -> None: 
                """
                Create a Selector for a DataReader to read/take based on selected conditions
                """
            def condition(self, condition: rti.connextdds.IReadCondition) -> rti.connextdds.DynamicData.DataReader.Selector: 
                """
                Select samples based on a ReadCondition.
                """
            def content(self, query: rti.connextdds.Query) -> rti.connextdds.DynamicData.DataReader.Selector: 
                """
                Select samples based on a Query.
                """
            def instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DynamicData.DataReader.Selector: 
                """
                Select a specific instance to read/take.
                """
            def max_samples(self, max: int) -> rti.connextdds.DynamicData.DataReader.Selector: 
                """
                Limit the number of samples read/taken by the Select.
                """
            def next_instance(self, previous: rti.connextdds.InstanceHandle) -> rti.connextdds.DynamicData.DataReader.Selector: 
                """
                Select the instance after the specified instance to read/take.
                """
            def read(self) -> list: 
                """
                Read copies of available samples (data and info) based on the Selector settings.
                """
            def read_data(self) -> list: 
                """
                Read copies of available valid data based on the Selector settings.
                """
            def read_loaned(self) -> rti.connextdds.DynamicData.LoanedSamples: 
                """
                Take available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            def state(self, state: rti.connextdds.DataState) -> rti.connextdds.DynamicData.DataReader.Selector: 
                """
                Select samples with a specified data state.
                """
            def take(self) -> list: 
                """
                Take copies of available samples (data and info) based on the Selector settings.
                """
            def take_data(self) -> list: 
                """
                Take copies of available valid data based on the Selector settings.
                """
            def take_loaned(self) -> rti.connextdds.DynamicData.LoanedSamples: 
                """
                Read available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            pass
        def __enter__(self) -> rti.connextdds.DynamicData.DataReader: 
            """
            Enter a context for this DataReader, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.DynamicData.DataReader) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataReader, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.DynamicData.Topic) -> None: 
            """
            Create a DataReader in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.DynamicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.DynamicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in the implicit subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.DynamicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.DynamicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.DynamicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.DynamicData.Topic) -> None: 
            """
            Create a DataReader.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.DynamicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.DynamicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in a subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.DynamicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.DynamicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.DynamicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
            """
            Get a typed DataReader from an AnyDataReader.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Get a typed DataReader from an Entity.
            """
        def __lshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.DynamicData.DataReader: 
            """
            Set the DataReaderQos for this DataReader.
            """
        def __ne__(self, arg0: rti.connextdds.DynamicData.DataReader) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.DynamicData.DataReader: 
            """
            Get the DataReaderQos from this DataReader
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Subscriber, arg1: rti.connextdds.DynamicData.TopicDescription, arg2: rti.connextdds.DataReaderQos) -> rti.connextdds.DynamicData.DataReader: ...
        def _set_related_writer_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        @typing.overload
        def acknowledge_all(self) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_all(self, arg0: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo) -> None: 
            """
            Acknowledge a single sample.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo, ack_response_data: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge a single sample with ack response data.
            """
        def close(self) -> None: 
            """
            Close this DataReader.
            """
        @staticmethod
        def find_all_by_topic(subscriber: rti.connextdds.Subscriber, topic_name: str) -> rti.connextdds.DynamicData.DataReaderSeq: 
            """
            Retrieve all DataReaders for the given topic name in the subscriber.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.DynamicData.DataReader]: 
            """
            Find DataReader in DomainParticipant with the DataReader's name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.DynamicData.DataReader]: 
            """
            Find DataReader in Subscriber with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.DynamicData.DataReader]: 
            """
            Find DataReader in Subscriber with a topic name, returning the first found.
            """
        def is_matched_publication_alive(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            Check if a matched publication is alive.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DynamicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.DynamicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_publication_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Get the PublicationBuiltinTopicData for a publication matched to this DataReader.
            """
        def matched_publication_datareader_protocol_status(self, publication_handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReaderProtocolStatus: 
            """
            Get the DataReaderProtocolStatus for the DataReader based on the matched publication handle.
            """
        def matched_publication_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a publication matched to this DataReader.
            """
        def read(self) -> list: 
            """
            Read copies of all available samples (data and info).
            """
        def read_data(self) -> list: 
            """
            Read copies of all available valid data.
            """
        def read_loaned(self) -> rti.connextdds.DynamicData.LoanedSamples: 
            """
            Read all available samples (data and info) and return them in a loaned container.
            """
        @staticmethod
        def select(*args, **kwargs) -> typing.Any: 
            """
            Get a Selector to perform complex data selections, such as per-instance selection, content, and status filtering.
            """
        def set_listener(self, listener: rti.connextdds.DynamicData.DataReaderListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and associated event mask.
            """
        def take(self) -> list: 
            """
            Take copies of all available samples (data and info).
            """
        def take_data(self) -> list: 
            """
            Take copies of all available valid data.
            """
        def take_loaned(self) -> rti.connextdds.DynamicData.LoanedSamples: 
            """
            Take all available samples (data and info) and return them in a loaned container.
            """
        def wait_for_historical_data(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind.
            """
        def wait_for_historical_data_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind. This call is awaitable and only for use with asyncio.
            """
        @builtins.property
        def _has_matched_publications_with_related_reader(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datareader_cache_status(self) -> DataReaderCacheStatus:
            """
            Get the DataReaderCacheStatus for the DataReader.

            :type: DataReaderCacheStatus
            """
        @builtins.property
        def datareader_protocol_status(self) -> DataReaderProtocolStatus:
            """
            Get the DataReaderProtocolStatus for the DataReader.

            :type: DataReaderProtocolStatus
            """
        @builtins.property
        def default_filter_state(self) -> DataState:
            """
            Returns the filter state for the read/take operations.

            :type: DataState
            """
        @default_filter_state.setter
        def default_filter_state(self, arg1: DataState) -> None:
            """
            Returns the filter state for the read/take operations.
            """
        @builtins.property
        def listener(self) -> DynamicData.DataReaderListener:
            """
            Gets or sets the listener with StatusMask.ALL

            :type: DynamicData.DataReaderListener
            """
        @listener.setter
        def listener(self, arg1: DynamicData.DataReaderListener) -> None:
            """
            Gets or sets the listener with StatusMask.ALL
            """
        @builtins.property
        def liveliness_changed_status(self) -> LivelinessChangedStatus:
            """
            Get the LivelinessChangedStatus for this DataReader.

            :type: LivelinessChangedStatus
            """
        @builtins.property
        def matched_publications(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched publication handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def qos(self) -> DataReaderQos:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.

            :type: DataReaderQos
            """
        @qos.setter
        def qos(self, arg1: DataReaderQos) -> None:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.
            """
        @builtins.property
        def requested_deadline_missed_status(self) -> RequestedDeadlineMissedStatus:
            """
            Get the RequestedDeadlineMissed status for the DataReader

            :type: RequestedDeadlineMissedStatus
            """
        @builtins.property
        def requested_incompatible_qos_status(self) -> RequestedIncompatibleQosStatus:
            """
            Get the RequestedIncompatibleQosStatus for the DataReader.

            :type: RequestedIncompatibleQosStatus
            """
        @builtins.property
        def sample_lost_status(self) -> SampleLostStatus:
            """
            Get the SampleLostStatus for the DataReader.

            :type: SampleLostStatus
            """
        @builtins.property
        def sample_rejected_status(self) -> SampleRejectedStatus:
            """
            Get the SampleRejectedStatus for the DataReader.

            :type: SampleRejectedStatus
            """
        @builtins.property
        def subscriber(self) -> Subscriber:
            """
            Returns the parent Subscriber of the DataReader.

            :type: Subscriber
            """
        @builtins.property
        def subscription_matched_status(self) -> SubscriptionMatchedStatus:
            """
            Get the SubscriptionMatchedStatus for the DataReader.

            :type: SubscriptionMatchedStatus
            """
        @builtins.property
        def topic_description(self) -> DynamicData.TopicDescription:
            """
            Returns the TopicDescription associated with the DataReader.

            :type: DynamicData.TopicDescription
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataReader.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name associated with this DataReader.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataReaderListener():
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.DynamicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class DataReaderSeq():
        def __add__(self, arg0: rti.connextdds.DynamicData.DataReaderSeq) -> rti.connextdds.DynamicData.DataReaderSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.DynamicData.DataReader) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.DynamicData.DataReaderSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.DynamicData.DataReaderSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.DynamicData.DataReader: ...
        def __iadd__(self, arg0: rti.connextdds.DynamicData.DataReaderSeq) -> rti.connextdds.DynamicData.DataReaderSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.DynamicData.DataReaderSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.DynamicData.DataReaderSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.DynamicData.DataReader]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.DynamicData.DataReaderSeq: ...
        def __ne__(self, arg0: rti.connextdds.DynamicData.DataReaderSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.DynamicData.DataReaderSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.DynamicData.DataReader) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.DynamicData.DataReaderSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.DynamicData.DataReader) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.DynamicData.DataReader) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.DynamicData.DataReaderSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.DynamicData.DataReader) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.DynamicData.DataReader: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.DynamicData.DataReader: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.DynamicData.DataReader) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataWriter(IEntity, IAnyDataWriter):
        def __enter__(self) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Enter a context for this DataWriter, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.DynamicData.DataWriter) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataWriter, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.DynamicData.Topic) -> None: 
            """
            Creates a DataWriter in the implicit publisher with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.DynamicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.DynamicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in the implicit publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.DynamicData.Topic) -> None: 
            """
            Creates a DataWriter in a publisher with default QoS.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.DynamicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.DynamicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in a publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
            """
            Create a typed DataWriter from an AnyDataWriter.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Create a typed DataWriter from an Entity.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Sets the DataWriterQos.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.DynamicData, rti.connextdds.Time]) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Writes a paired sample with a timestamp.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.DynamicData, rti.connextdds.InstanceHandle]) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Writes a paired sample with an instance handle.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DynamicDataTimestampedSeq) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Writes a sequence of pairs of samples with timestamps.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DynamicDataSeq) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Writes a sequence of samples.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DynamicData) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Writes a sample.
            """
        def __ne__(self, arg0: rti.connextdds.DynamicData.DataWriter) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Get the DataWriterQos.
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Publisher, arg1: rti.connextdds.DynamicData.Topic, arg2: rti.connextdds.DataWriterQos) -> rti.connextdds.DynamicData.DataWriter: ...
        def _set_related_reader_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        def _wait_for_sample_acknowledgment(self, sample_id: rti.connextdds.SampleIdentity, timeout: rti.connextdds.Duration) -> None: 
            """
            Wait for a sample to be acknowledged by the application.
            """
        def assert_liveliness(self) -> None: 
            """
            Manually asserts the liveliness of the DataWriter.
            """
        def close(self) -> None: 
            """
            Close this DataWriter.
            """
        def create_data(self) -> rti.connextdds.DynamicData: 
            """
            Create data of the writer's associated type and initialize it.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Dispose an instance with params.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.DynamicData) -> object: 
            """
            Dispose the instance associated with key_holder.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.DynamicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose the instance associated with key_holder using a timestamp
            """
        @typing.overload
        def dispose_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Dispose an instance with params.
            """
        @staticmethod
        def find_all_by_topic(publisher: rti.connextdds.Publisher, topic_name: str) -> rti.connextdds.DynamicData.DataWriterSeq: 
            """
            Retrieve all DataWriters for the given topic name in the publisher.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.DynamicData.DataWriter]: 
            """
            Find DataWriter in DomainParticipant with the provided name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.DynamicData.DataWriter]: 
            """
            Find DataWriter in Publisher with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.DynamicData.DataWriter]: 
            """
            Find DataWriter in publisher with a topic name, returning the first found.
            """
        def flush(self) -> None: 
            """
            Flushes the batch in progress in the context of thecalling thread.
            """
        def is_matched_subscription_active(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            A boolean indicating whether or not the matched subscription is active.
            """
        def is_sample_app_acknowledged(self, sample_id: rti.connextdds.SampleIdentity) -> bool: 
            """
            Indicates if a sample is considered application-acknowledged.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DynamicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.DynamicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_subscription_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Get the SubscriptionBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription handle.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, locator: rti.connextdds.Locator) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription locator.
            """
        def matched_subscription_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.DynamicData) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.DynamicData, timestamp: rti.connextdds.Time) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance and specified the timestamp.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.DynamicData, params: rti.connextdds.WriteParams) -> rti.connextdds.InstanceHandle: 
            """
            Registers instance with parameters.
            """
        def set_listener(self, listener: rti.connextdds.DynamicData.DataWriterListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask for the DataWriter.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Unregister an instance with parameters.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.DynamicData) -> object: 
            """
            Unregister the instance associated with key_holder.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.DynamicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister the instance associate with key_holder using a timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Unregister an instance with parameters.
            """
        def wait_for_acknowledgments(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Blocks the calling thread until all data written by a reliable DataWriter is acknowledged or until the timeout expires.
            """
        def wait_for_asynchronous_publishing(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            This operation blocks the calling thread (up to max_wait) until all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        def wait_for_asynchronous_publishing_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            This function is awaitable until either a timeout of max_wait or all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.This function works with asyncio.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        @typing.overload
        def write(self, samples: rti.connextdds.DynamicDataSeq) -> None: 
            """
            Write a sequence of samples.
            """
        @typing.overload
        def write(self, samples: rti.connextdds.DynamicDataSeq, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sequence of samples with a timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.DynamicData) -> None: 
            """
            Write a sample.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.DynamicData, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with a specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.DynamicData, handle: rti.connextdds.InstanceHandle) -> None: 
            """
            Write a sample with an instance handle.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.DynamicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with an instance handle and specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.DynamicData, params: rti.connextdds.WriteParams) -> None: 
            """
            Write with advanced parameters.
            """
        @typing.overload
        def write(self, sample_data: dict) -> None: 
            """
            Create a DynamicData object and write it with the given dictionary containing field names as keys.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.DynamicData) -> object: 
            """
            Write a sample. This method is awaitable and is only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.DynamicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with a specified timestamp. This methods is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.DynamicData, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Write a sample with an instance handle. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.DynamicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with an instance handle and specified timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.DynamicDataSeq) -> object: 
            """
            Write a sequence of samples. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.DynamicDataSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.DynamicDataSeq, handles: rti.connextdds.InstanceHandleSeq) -> object: 
            """
            Write a sequence of samples with their instance handles. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.DynamicDataSeq, handles: rti.connextdds.InstanceHandleSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with their instance handles and a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.DynamicData, params: rti.connextdds.WriteParams) -> object: 
            """
            Write with advanced parameters.
            """
        @typing.overload
        def write_async(self, sample_data: dict) -> object: 
            """
            Create a DynamicData object and write it with the given dictionary containing field names as keys. This method is awaitable and is only for use with asyncio.
            """
        @builtins.property
        def _has_matched_subscriptions_with_related_writer(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datawriter_cache_status(self) -> DataWriterCacheStatus:
            """
            Get a copy of the cache status for this writer.

            :type: DataWriterCacheStatus
            """
        @builtins.property
        def datawriter_protocol_status(self) -> DataWriterProtocolStatus:
            """
            Get a copy of the protocol status for this writer.

            :type: DataWriterProtocolStatus
            """
        @builtins.property
        def listener(self) -> DynamicData.DataWriterListener:
            """
            Get the listener associated with the DataWriter or set the listener.

            :type: DynamicData.DataWriterListener
            """
        @listener.setter
        def listener(self, arg1: DynamicData.DataWriterListener) -> None:
            """
            Get the listener associated with the DataWriter or set the listener.
            """
        @builtins.property
        def liveliness_lost_status(self) -> LivelinessLostStatus:
            """
            Get a copy of the LivelinessLostStatus.

            :type: LivelinessLostStatus
            """
        @builtins.property
        def matched_subscriptions(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched subscription handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def matched_subscriptions_locators(self) -> LocatorSeq:
            """
            The locators used to communicate with matched DataReaders.

            :type: LocatorSeq
            """
        @builtins.property
        def offered_deadline_missed_status(self) -> OfferedDeadlineMissedStatus:
            """
            Get a copy of the OfferedDeadlineMissedStatus.

            :type: OfferedDeadlineMissedStatus
            """
        @builtins.property
        def offered_incompatible_qos_status(self) -> OfferedIncompatibleQosStatus:
            """
            Get a copy of the OfferedIncompatibleQosStatus

            :type: OfferedIncompatibleQosStatus
            """
        @builtins.property
        def publication_matched_status(self) -> PublicationMatchedStatus:
            """
            Get a copy of the PublicationMatchedStatus

            :type: PublicationMatchedStatus
            """
        @builtins.property
        def publisher(self) -> Publisher:
            """
            Get the Publisher that owns this DataWriter.

            :type: Publisher
            """
        @builtins.property
        def qos(self) -> DataWriterQos:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.

            :type: DataWriterQos
            """
        @qos.setter
        def qos(self, arg1: DataWriterQos) -> None:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.
            """
        @builtins.property
        def reliable_reader_activity_changed_status(self) -> ReliableReaderActivityChangedStatus:
            """
            Get a copy of the reliable reader activity changed status for this writer.

            :type: ReliableReaderActivityChangedStatus
            """
        @builtins.property
        def reliable_writer_cache_changed_status(self) -> ReliableWriterCacheChangedStatus:
            """
            Get a copy of the reliable cache status for this writer.

            :type: ReliableWriterCacheChangedStatus
            """
        @builtins.property
        def service_request_accepted_status(self) -> ServiceRequestAcceptedStatus:
            """
            Get a copy of the service request accepted status for this writer.

            :type: ServiceRequestAcceptedStatus
            """
        @builtins.property
        def topic(self) -> DynamicData.Topic:
            """
            Get the Topic object associated with this DataWriter.

            :type: DynamicData.Topic
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataWriter.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name for the topic object associated with this DataWriter.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataWriterListener():
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class DataWriterSeq():
        def __add__(self, arg0: rti.connextdds.DynamicData.DataWriterSeq) -> rti.connextdds.DynamicData.DataWriterSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.DynamicData.DataWriter) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.DynamicData.DataWriterSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.DynamicData.DataWriterSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.DynamicData.DataWriter: ...
        def __iadd__(self, arg0: rti.connextdds.DynamicData.DataWriterSeq) -> rti.connextdds.DynamicData.DataWriterSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.DynamicData.DataWriterSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.DynamicData.DataWriterSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.DynamicData.DataWriter]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.DynamicData.DataWriterSeq: ...
        def __ne__(self, arg0: rti.connextdds.DynamicData.DataWriterSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.DynamicData.DataWriterSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.DynamicData.DataWriter) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.DynamicData.DataWriterSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.DynamicData.DataWriter) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.DynamicData.DataWriter) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.DynamicData.DataWriterSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.DynamicData.DataWriter) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.DynamicData.DataWriter: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.DynamicData.DataWriter) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class FieldsIterator():
        def __init__(self, arg0: rti.connextdds.DynamicData, arg1: bool) -> None: ...
        def __iter__(self) -> rti.connextdds.DynamicData.FieldsIterator: ...
        def __next__(self) -> str: ...
        pass
    class FieldsView():
        def __contains__(self, arg0: str) -> bool: ...
        def __init__(self, arg0: rti.connextdds.DynamicData) -> None: ...
        def __iter__(self) -> rti.connextdds.DynamicData.FieldsIterator: ...
        def __len__(self) -> int: ...
        def __reversed__(self) -> rti.connextdds.DynamicData.FieldsIterator: ...
        pass
    class ITopicDescription(IEntity):
        @builtins.property
        def name(self) -> str:
            """
            The name of the entity conforming to the ITopicDescription interface.

            :type: str
            """
        @builtins.property
        def participant(self) -> DomainParticipant:
            """
            The parent DomainParticipant.

            :type: DomainParticipant
            """
        @builtins.property
        def type_name(self) -> str:
            """
            The name of the associated type.

            :type: str
            """
        pass
    class IndexIterator():
        def __init__(self, arg0: rti.connextdds.DynamicData, arg1: bool) -> None: ...
        def __iter__(self) -> rti.connextdds.DynamicData.IndexIterator: ...
        def __next__(self) -> object: ...
        pass
    class ItemsIterator():
        def __init__(self, arg0: rti.connextdds.DynamicData, arg1: bool) -> None: ...
        def __iter__(self) -> rti.connextdds.DynamicData.ItemsIterator: ...
        def __next__(self) -> tuple[str, object]: ...
        pass
    class ItemsView():
        def __contains__(self, arg0: tuple[str, object]) -> bool: ...
        def __init__(self, arg0: rti.connextdds.DynamicData) -> None: ...
        def __iter__(self) -> rti.connextdds.DynamicData.ItemsIterator: ...
        def __len__(self) -> int: ...
        def __reversed__(self) -> rti.connextdds.DynamicData.ItemsIterator: ...
        pass
    class LoanedSample():
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, data: rti.connextdds.DynamicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct LoanedSample with data and info.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> DynamicData:
            """
            Get the data associated with the sample.

            :type: DynamicData
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        pass
    class LoanedSamples():
        def __enter__(self) -> rti.connextdds.DynamicData.LoanedSamples: 
            """
            Enter a context for the loaned samples, loan returned on context exit.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for the loaned samples, returning the resources.
            """
        def __getitem__(self, arg0: int) -> rti.connextdds.DynamicData.LoanedSample: 
            """
            Access a LoanedSample object in an array-like syntax
            """
        def __init__(self) -> None: 
            """
            Create an empty LoanedSamples object.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.DynamicData.LoanedSample]: ...
        def __len__(self) -> int: 
            """
            Get the number of samples in the loan.
            """
        def return_loan(self) -> None: 
            """
            Returns the loan to the DataReader.
            """
        @builtins.property
        def length(self) -> int:
            """
            Get the number of samples in the loan.

            :type: int
            """
        pass
    class NoOpDataReaderListener(DynamicData.DataReaderListener):
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.DynamicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.DynamicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class NoOpDataWriterListener(DynamicData.DataWriterListener):
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.DynamicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class NoOpTopicListener(DynamicData.TopicListener):
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.DynamicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class Sample():
        @typing.overload
        def __init__(self, data: rti.connextdds.DynamicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct Sample with data and info.
            """
        @typing.overload
        def __init__(self, sample: rti.connextdds.DynamicData.Sample) -> None: 
            """
            Copy constructor.
            """
        @typing.overload
        def __init__(self, loaned_sample: rti.connextdds.DynamicData.LoanedSample) -> None: 
            """
            Copy constructor.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> DynamicData:
            """
            The data associated with the sample.

            :type: DynamicData
            """
        @data.setter
        def data(self, arg1: DynamicData) -> None:
            """
            The data associated with the sample.
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        @info.setter
        def info(self, arg1: SampleInfo) -> None:
            """
            Get the info associated with the sample.
            """
        pass
    class SharedSamples():
        def __getitem__(self, arg0: int) -> rti.connextdds.DynamicData.LoanedSample: 
            """
            Get the sample at the specified index.
            """
        def __init__(self, loaned_samples: rti.connextdds.DynamicData.LoanedSamples) -> None: 
            """
            Constructs an instance of SharedSamples, removing ownership of the loan from the Loaned Samples.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.DynamicData.LoanedSample]: 
            """
            Make a sample iterator
            """
        def __len__(self) -> int: 
            """
            Returns the number of samples.
            """
        pass
    class Topic(DynamicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.DynamicData.Topic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast an Entity to a Topic.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.DynamicData.ITopicDescription) -> None: 
            """
            Cast an ITopicDescription to a Topic.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
            """
            Create a typed Topic from an AnyTopic.
            """
        @typing.overload
        def __init__(self, participant: rti.connextdds.DomainParticipant, topic_name: str, topic_type: rti.connextdds.DynamicType) -> None: 
            """
            Create a Topic with the given type.
            """
        @typing.overload
        def __init__(self, participant: rti.connextdds.DomainParticipant, topic_name: str, topic_type: rti.connextdds.DynamicType, qos: rti.connextdds.TopicQos, listener: typing.Optional[rti.connextdds.DynamicData.TopicListener] = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a Topic with the given type.
            """
        @typing.overload
        def __init__(self, participant: rti.connextdds.DomainParticipant, topic_name: str, type_name: str, qos: rti.connextdds.TopicQos, listener: typing.Optional[rti.connextdds.DynamicData.TopicListener] = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a new Topic.
            """
        def __ne__(self, arg0: rti.connextdds.DynamicData.Topic) -> bool: 
            """
            Test for inequality.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.DynamicData.Topic]: 
            """
            Look up a Topic by its name in the DomainParticipant.
            """
        def set_listener(self, listener: rti.connextdds.DynamicData.TopicListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask.
            """
        @builtins.property
        def inconsistent_topic_status(self) -> InconsistentTopicStatus:
            """
            Get a copy of the current InconsistentTopicStatus for this Topic.

            :type: InconsistentTopicStatus
            """
        @builtins.property
        def listener(self) -> DynamicData.TopicListener:
            """
            The listener.

            :type: DynamicData.TopicListener
            """
        @listener.setter
        def listener(self, arg1: DynamicData.TopicListener) -> None:
            """
            The listener.
            """
        @builtins.property
        def qos(self) -> TopicQos:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.

            :type: TopicQos
            """
        @qos.setter
        def qos(self, arg1: TopicQos) -> None:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.
            """
        __hash__: NoneType
        pass
    class TopicDescription(DynamicData.ITopicDescription, IEntity):
        def __eq__(self, arg0: rti.connextdds.DynamicData.TopicDescription) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.DynamicData.ITopicDescription) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        def __ne__(self, arg0: rti.connextdds.DynamicData.TopicDescription) -> bool: 
            """
            Test for inequality.
            """
        __hash__: NoneType
        pass
    class TopicListener():
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.DynamicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class TopicSeq():
        def __add__(self, arg0: rti.connextdds.DynamicData.TopicSeq) -> rti.connextdds.DynamicData.TopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.DynamicData.Topic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.DynamicData.TopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.DynamicData.TopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.DynamicData.Topic: ...
        def __iadd__(self, arg0: rti.connextdds.DynamicData.TopicSeq) -> rti.connextdds.DynamicData.TopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.DynamicData.TopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.DynamicData.TopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.DynamicData.Topic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.DynamicData.TopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.DynamicData.TopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.DynamicData.TopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.DynamicData.Topic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.DynamicData.TopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.DynamicData.Topic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.DynamicData.Topic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.DynamicData.TopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.DynamicData.Topic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.DynamicData.Topic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.DynamicData.Topic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.DynamicData.Topic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class TopicTypeSupport():
        @staticmethod
        def from_cdr_buffer(sample: rti.connextdds.DynamicData, buffer: rti.connextdds.CharSeq) -> None: 
            """
            Deserialize a sample from a CDR buffer.
            """
        @staticmethod
        def initialize_sample(arg0: rti.connextdds.DynamicData) -> None: ...
        @staticmethod
        def register_type(participant: rti.connextdds.DomainParticipant, type_name: str) -> None: 
            """
            Register a type with a participant.
            """
        @staticmethod
        def to_cdr_buffer(buffer: rti.connextdds.CharSeq, sample: rti.connextdds.DynamicData, representation_id: int = -1) -> rti.connextdds.CharSeq: 
            """
            Serialize sample to a CDR buffer.
            """
        pass
    class ValidLoanedSamples():
        def __enter__(self) -> rti.connextdds.DynamicData.ValidLoanedSamples: ...
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.DynamicData.LoanedSample]: ...
        pass
    class WriterContentFilter(DynamicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def writer_attach(self) -> typing.Optional[object]: 
            """
            A writer-side filtering API to create some state that can facilitate filtering on the writer side.
            """
        def writer_compile(self, writer_filter_data: typing.Optional[object], property: rti.connextdds.ExpressionProperty, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_detach(self, writer_filter_data: typing.Optional[object]) -> None: 
            """
            A writer-side filtering API to clean up a previously created state using writer_attach.
            """
        def writer_evaluate(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.DynamicData, meta_data: rti.connextdds.FilterSampleInfo) -> rti.connextdds.CookieVector: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_finalize(self, writer_filter_data: typing.Optional[object], cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to clean up a previously compiled instance of the content filter.
            """
        def writer_return_loan(self, writer_filter_data: typing.Optional[object], cookies: rti.connextdds.CookieVector) -> None: 
            """
            A writer-side filtering API to return the loan on the list of DataReaders returned by writer_evaluate.
            """
        pass
    class WriterContentFilterHelper(DynamicData.WriterContentFilter, DynamicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def add_cookie(self, cookie: rti.connextdds.Cookie) -> None: 
            """
            A helper function which will add a Cookie to the Cookie sequence that is then returned by the writer_evaluate function.
            """
        def writer_evaluate_helper(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.DynamicData, meta_data: rti.connextdds.FilterSampleInfo) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        pass
    @typing.overload
    def __contains__(self, arg0: str) -> bool: ...
    @typing.overload
    def __contains__(self, arg0: object) -> bool: ...
    @typing.overload
    def __eq__(self, arg0: rti.connextdds.DynamicData) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __eq__(self, arg0: dict) -> bool: ...
    @typing.overload
    def __getitem__(self, arg0: str) -> object: ...
    @typing.overload
    def __getitem__(self, arg0: int) -> object: ...
    @typing.overload
    def __getitem__(self, arg0: tuple) -> object: ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list: ...
    @typing.overload
    def __init__(self, dynamic_type: rti.connextdds.DynamicType) -> None: 
        """
        Create a DynamicData object from a DynamicType.
        """
    @typing.overload
    def __init__(self, dynamic_type: rti.connextdds.DynamicType, property: rti.connextdds.DynamicDataProperty) -> None: 
        """
        Create a DynamicData object from a DynamicType with properties.
        """
    @typing.overload
    def __init__(self, dynamic_type: rti.connextdds.DynamicType, data: dict) -> None: 
        """
        Create a DynamicData object from a DynamicType with a dict to initialize the fields
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.DynamicData) -> None: 
        """
        Create a copy of a DynamicData object.
        """
    def __iter__(self) -> object: ...
    def __len__(self) -> int: 
        """
        Number of members in the DynamicData object
        """
    @typing.overload
    def __ne__(self, arg0: rti.connextdds.DynamicData) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __ne__(self, arg0: dict) -> bool: ...
    def __reversed__(self) -> object: ...
    @typing.overload
    def __setitem__(self, arg0: str, arg1: object) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: object) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: tuple, arg1: object) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Iterable) -> None: ...
    def __str__(self) -> str: 
        """
        DynamicData value to string.
        """
    def append(self, value: object) -> None: 
        """
        Append a value to a sequence.
        """
    def clear_all_members(self) -> None: 
        """
        Clear the contents of all data members of this object, including key members.
        """
    @typing.overload
    def clear_member(self, name: str) -> None: 
        """
        Clear the contents of a single data member of this object.
        """
    @typing.overload
    def clear_member(self, index: int) -> None: 
        """
        Clear the contents of a single data member of this object.
        """
    @typing.overload
    def clear_optional_member(self, name: str) -> None: 
        """
        Clear the contents of a single optional data member of this object.
        """
    @typing.overload
    def clear_optional_member(self, index: int) -> None: 
        """
        Clear the contents of a single optional data member of this object.
        """
    def count(self, arg0: object) -> int: ...
    def extend(self, values: typing.Iterable) -> None: 
        """
        Extend a sequence.
        """
    def fields(self) -> rti.connextdds.DynamicData.FieldsView: ...
    @typing.overload
    def from_cdr_buffer(self, buffer: rti.connextdds.Uint8Seq) -> rti.connextdds.DynamicData: 
        """
        Populates a DynamicData sample by deserializing a CDR buffer.
        """
    @typing.overload
    def from_cdr_buffer(self, signed_buffer: rti.connextdds.CharSeq) -> rti.connextdds.DynamicData: 
        """
        Populates a DynamicData sample by deserializing a CDR buffer.
        """
    def from_json(self, str: str) -> None: 
        """
        Populates a DynamicData object from a JSON string representation.
        """
    def from_string(self, str: str, format_kind: rti.connextdds.PrintFormatKind) -> None: 
        """
        Populates a DynamicData object from a JSON string representation. At the moment the only supported value for format_kind is dds.PrintFormatKind.JSON, and from_json() is preferred.
        """
    @typing.overload
    def get_boolean(self, name: str) -> bool: 
        """
        Get a boolean value by field name.
        """
    @typing.overload
    def get_boolean(self, name: int) -> bool: 
        """
        Get a boolean value by field name.
        """
    def get_cdr_buffer(self) -> memoryview: 
        """
        Gets the CDR buffer of this DynamicData sample as a memoryview.
        """
    @typing.overload
    def get_char(self, name: str) -> str: 
        """
        Get a character value by field name.
        """
    @typing.overload
    def get_char(self, name: int) -> str: 
        """
        Get a character value by field name.
        """
    @typing.overload
    def get_char_values(self, name: str) -> rti.connextdds.CharSeq: 
        """
        Get multiple character values by field name.
        """
    @typing.overload
    def get_char_values(self, index: int) -> rti.connextdds.CharSeq: 
        """
        Get multiple character values by field name.
        """
    @typing.overload
    def get_complex(self, name: str) -> rti.connextdds.DynamicData: 
        """
        Get a complex data type value by field name.
        """
    @typing.overload
    def get_complex(self, name: int) -> rti.connextdds.DynamicData: 
        """
        Get a complex data type value by field name.
        """
    @typing.overload
    def get_complex_values(self, name: str) -> rti.connextdds.DynamicDataSeq: 
        """
        Get a list of complex values by field name.
        """
    @typing.overload
    def get_complex_values(self, index: int) -> rti.connextdds.DynamicDataSeq: 
        """
        Get a list of complex fields by index.
        """
    @typing.overload
    def get_double(self, name: str) -> float: 
        """
        Get a 64-bit floating point value by field name.
        """
    @typing.overload
    def get_double(self, name: int) -> float: 
        """
        Get a 64-bit floating point value by field name.
        """
    @typing.overload
    def get_double_values(self, name: str) -> rti.connextdds.Float64Seq: 
        """
        Get multiple 64-bit floating point values by field name.
        """
    @typing.overload
    def get_double_values(self, index: int) -> rti.connextdds.Float64Seq: 
        """
        Get multiple 64-bit floating point values by field name.
        """
    @typing.overload
    def get_float(self, name: str) -> float: 
        """
        Get a 32-bit floating point value by field name.
        """
    @typing.overload
    def get_float(self, name: int) -> float: 
        """
        Get a 32-bit floating point value by field name.
        """
    @typing.overload
    def get_float128(self, name: str) -> rti.connextdds.LongDouble: 
        """
        Get a 128-bit floating point value by field name.
        """
    @typing.overload
    def get_float128(self, name: int) -> rti.connextdds.LongDouble: 
        """
        Get a 128-bit floating point value by field name.
        """
    @typing.overload
    def get_float32(self, name: str) -> float: 
        """
        Get a 32-bit floating point value by field name.
        """
    @typing.overload
    def get_float32(self, name: int) -> float: 
        """
        Get a 32-bit floating point value by field name.
        """
    @typing.overload
    def get_float32_values(self, name: str) -> rti.connextdds.Float32Seq: 
        """
        Get multiple 32-bit floating point values by field name.
        """
    @typing.overload
    def get_float32_values(self, index: int) -> rti.connextdds.Float32Seq: 
        """
        Get multiple 32-bit floating point values by field name.
        """
    @typing.overload
    def get_float64(self, name: str) -> float: 
        """
        Get a 64-bit floating point value by field name.
        """
    @typing.overload
    def get_float64(self, name: int) -> float: 
        """
        Get a 64-bit floating point value by field name.
        """
    @typing.overload
    def get_float64_values(self, name: str) -> rti.connextdds.Float64Seq: 
        """
        Get multiple 64-bit floating point values by field name.
        """
    @typing.overload
    def get_float64_values(self, index: int) -> rti.connextdds.Float64Seq: 
        """
        Get multiple 64-bit floating point values by field name.
        """
    @typing.overload
    def get_float_values(self, name: str) -> rti.connextdds.Float32Seq: 
        """
        Get multiple 32-bit floating point values by field name.
        """
    @typing.overload
    def get_float_values(self, index: int) -> rti.connextdds.Float32Seq: 
        """
        Get multiple 32-bit floating point values by field name.
        """
    @typing.overload
    def get_int(self, name: str) -> int: 
        """
        Get a int (signed) value by field name.
        """
    @typing.overload
    def get_int(self, name: int) -> int: 
        """
        Get a int (signed) value by field name.
        """
    @typing.overload
    def get_int16(self, name: str) -> int: 
        """
        Get a 16-bit signed int value by field name.
        """
    @typing.overload
    def get_int16(self, name: int) -> int: 
        """
        Get a 16-bit signed int value by field name.
        """
    @typing.overload
    def get_int16_values(self, name: str) -> rti.connextdds.Int16Seq: 
        """
        Get multiple 16-bit signed int values by field name.
        """
    @typing.overload
    def get_int16_values(self, index: int) -> rti.connextdds.Int16Seq: 
        """
        Get multiple 16-bit signed int values by field name.
        """
    @typing.overload
    def get_int32(self, name: str) -> int: 
        """
        Get a 32-bit signed int value by field name.
        """
    @typing.overload
    def get_int32(self, name: int) -> int: 
        """
        Get a 32-bit signed int value by field name.
        """
    @typing.overload
    def get_int32_values(self, name: str) -> rti.connextdds.Int32Seq: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def get_int32_values(self, index: int) -> rti.connextdds.Int32Seq: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def get_int64(self, name: str) -> int: 
        """
        Get a 64-bit signed int value by field name.
        """
    @typing.overload
    def get_int64(self, name: int) -> int: 
        """
        Get a 64-bit signed int value by field name.
        """
    @typing.overload
    def get_int64_values(self, name: str) -> rti.connextdds.Int64Seq: 
        """
        Get multiple 64-bit signed int values by field name.
        """
    @typing.overload
    def get_int64_values(self, index: int) -> rti.connextdds.Int64Seq: 
        """
        Get multiple 64-bit signed int values by field name.
        """
    @typing.overload
    def get_int8(self, name: str) -> int: 
        """
        Get an int8 value by field name.
        """
    @typing.overload
    def get_int8(self, index: int) -> int: 
        """
        Get an int8 value by field index.
        """
    @typing.overload
    def get_int_values(self, name: str) -> rti.connextdds.Int32Seq: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def get_int_values(self, index: int) -> rti.connextdds.Int32Seq: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def get_long(self, name: str) -> int: 
        """
        Get a 32-bit signed int value by field name.
        """
    @typing.overload
    def get_long(self, name: int) -> int: 
        """
        Get a 32-bit signed int value by field name.
        """
    @typing.overload
    def get_long_values(self, name: str) -> rti.connextdds.Int32Seq: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def get_long_values(self, index: int) -> rti.connextdds.Int32Seq: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def get_longdouble(self, name: str) -> rti.connextdds.LongDouble: 
        """
        Get a 128-bit floating point value by field name.
        """
    @typing.overload
    def get_longdouble(self, name: int) -> rti.connextdds.LongDouble: 
        """
        Get a 128-bit floating point value by field name.
        """
    @typing.overload
    def get_longlong(self, name: str) -> int: 
        """
        Get a 64-bit signed int value by field name.
        """
    @typing.overload
    def get_longlong(self, name: int) -> int: 
        """
        Get a 64-bit signed int value by field name.
        """
    @typing.overload
    def get_longlong_values(self, name: str) -> rti.connextdds.Int64Seq: 
        """
        Get multiple 64-bit signed int values by field name.
        """
    @typing.overload
    def get_longlong_values(self, index: int) -> rti.connextdds.Int64Seq: 
        """
        Get multiple 64-bit signed int values by field name.
        """
    @typing.overload
    def get_octet(self, name: str) -> int: 
        """
        Get a 8-bit unsigned int value by field name.
        """
    @typing.overload
    def get_octet(self, name: int) -> int: 
        """
        Get a 8-bit unsigned int value by field name.
        """
    @typing.overload
    def get_octet_values(self, name: str) -> rti.connextdds.Uint8Seq: 
        """
        Get multiple 8-bit unsigned int values by field name.
        """
    @typing.overload
    def get_octet_values(self, index: int) -> rti.connextdds.Uint8Seq: 
        """
        Get multiple 8-bit unsigned int values by field name.
        """
    @typing.overload
    def get_short(self, name: str) -> int: 
        """
        Get a 16-bit signed int value by field name.
        """
    @typing.overload
    def get_short(self, name: int) -> int: 
        """
        Get a 16-bit signed int value by field name.
        """
    @typing.overload
    def get_short_values(self, name: str) -> rti.connextdds.Int16Seq: 
        """
        Get multiple 16-bit signed int values by field name.
        """
    @typing.overload
    def get_short_values(self, index: int) -> rti.connextdds.Int16Seq: 
        """
        Get multiple 16-bit signed int values by field name.
        """
    @typing.overload
    def get_string(self, name: str) -> str: 
        """
        Get a string value by field name.
        """
    @typing.overload
    def get_string(self, name: int) -> str: 
        """
        Get a string value by field name.
        """
    @typing.overload
    def get_uint(self, name: str) -> int: 
        """
        Get a 32-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint(self, name: int) -> int: 
        """
        Get a 32-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint16(self, name: str) -> int: 
        """
        Get a 16-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint16(self, name: int) -> int: 
        """
        Get a 16-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint16_values(self, name: str) -> rti.connextdds.Uint16Seq: 
        """
        Get multiple 16-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint16_values(self, index: int) -> rti.connextdds.Uint16Seq: 
        """
        Get multiple 16-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint32(self, name: str) -> int: 
        """
        Get a 32-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint32(self, name: int) -> int: 
        """
        Get a 32-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint32_values(self, name: str) -> rti.connextdds.Uint32Seq: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint32_values(self, index: int) -> rti.connextdds.Uint32Seq: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint64(self, name: str) -> int: 
        """
        Get a 64-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint64(self, name: int) -> int: 
        """
        Get a 64-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint64_values(self, name: str) -> rti.connextdds.Uint64Seq: 
        """
        Get multiple 64-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint64_values(self, index: int) -> rti.connextdds.Uint64Seq: 
        """
        Get multiple 64-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint8(self, name: str) -> int: 
        """
        Get a 8-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint8(self, name: int) -> int: 
        """
        Get a 8-bit unsigned int value by field name.
        """
    @typing.overload
    def get_uint8_values(self, name: str) -> rti.connextdds.Uint8Seq: 
        """
        Get multiple 8-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint8_values(self, index: int) -> rti.connextdds.Uint8Seq: 
        """
        Get multiple 8-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint_values(self, name: str) -> rti.connextdds.Uint32Seq: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def get_uint_values(self, index: int) -> rti.connextdds.Uint32Seq: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def get_ulong(self, name: str) -> int: 
        """
        Get a 32-bit unsigned int value by field name.
        """
    @typing.overload
    def get_ulong(self, name: int) -> int: 
        """
        Get a 32-bit unsigned int value by field name.
        """
    @typing.overload
    def get_ulong_values(self, name: str) -> rti.connextdds.Uint32Seq: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def get_ulong_values(self, index: int) -> rti.connextdds.Uint32Seq: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def get_ulonglong(self, name: str) -> int: 
        """
        Get a 64-bit unsigned int value by field name.
        """
    @typing.overload
    def get_ulonglong(self, name: int) -> int: 
        """
        Get a 64-bit unsigned int value by field name.
        """
    @typing.overload
    def get_ulonglong_values(self, name: str) -> rti.connextdds.Uint64Seq: 
        """
        Get multiple 64-bit unsigned int values by field name.
        """
    @typing.overload
    def get_ulonglong_values(self, index: int) -> rti.connextdds.Uint64Seq: 
        """
        Get multiple 64-bit unsigned int values by field name.
        """
    @typing.overload
    def get_ushort(self, name: str) -> int: 
        """
        Get a 16-bit unsigned int value by field name.
        """
    @typing.overload
    def get_ushort(self, name: int) -> int: 
        """
        Get a 16-bit unsigned int value by field name.
        """
    @typing.overload
    def get_ushort_values(self, name: str) -> rti.connextdds.Uint16Seq: 
        """
        Get multiple 16-bit unsigned int values by field name.
        """
    @typing.overload
    def get_ushort_values(self, index: int) -> rti.connextdds.Uint16Seq: 
        """
        Get multiple 16-bit unsigned int values by field name.
        """
    @typing.overload
    def get_value(self, field_path: str) -> object: 
        """
        Automatically resolve type and return value for a field.
        """
    @typing.overload
    def get_value(self, field_path: int) -> object: 
        """
        Automatically resolve type and return value for a field.
        """
    @typing.overload
    def get_values(self, field_path: str) -> object: 
        """
        Automatically resolve type and return collection for a field.
        """
    @typing.overload
    def get_values(self, field_path: int) -> object: 
        """
        Automatically resolve type and return collection for a field.
        """
    @typing.overload
    def get_wchar(self, name: str) -> str: 
        """
        Get a wchar value by field name.
        """
    @typing.overload
    def get_wchar(self, index: int) -> str: 
        """
        Get a wchar value by field index.
        """
    @typing.overload
    def get_wstring(self, name: str) -> str: 
        """
        Get a wstring value by field name.
        """
    @typing.overload
    def get_wstring(self, index: int) -> str: 
        """
        Get a wstring value by field index.
        """
    @typing.overload
    def is_member_key(self, name: str) -> bool: 
        """
        Returns whether a member is a key.
        """
    @typing.overload
    def is_member_key(self, index: int) -> bool: 
        """
        Returns whether a member is a key.
        """
    def items(self) -> rti.connextdds.DynamicData.ItemsView: ...
    @typing.overload
    def loan_value(self, index: int) -> rti.connextdds.LoanedDynamicData: 
        """
        Gets a view of a complex member.
        """
    @typing.overload
    def loan_value(self, data: rti.connextdds.LoanedDynamicData, index: int) -> rti.connextdds.LoanedDynamicData: 
        """
        Gets a view of a complex member.
        """
    @typing.overload
    def loan_value(self, name: str) -> rti.connextdds.LoanedDynamicData: 
        """
        Gets a view of a complex member.
        """
    @typing.overload
    def loan_value(self, data: rti.connextdds.LoanedDynamicData, name: str) -> rti.connextdds.LoanedDynamicData: 
        """
        Gets a view of a complex member.
        """
    @typing.overload
    def member_exists(self, name: str) -> bool: 
        """
        Determine if an optional member is set by member name.
        """
    @typing.overload
    def member_exists(self, index: int) -> bool: 
        """
        Determine if an optional member is set by member index.
        """
    @typing.overload
    def member_exists_in_type(self, name: str) -> bool: 
        """
        Determine if a member with a particular name exists in the type.
        """
    @typing.overload
    def member_exists_in_type(self, index: int) -> bool: 
        """
        Determine if a member with a particular index exists in the type.
        """
    def member_index(self, name: str) -> int: 
        """
        Translates from member name to member index.
        """
    @typing.overload
    def member_info(self, name: str) -> rti.connextdds.DynamicDataMemberInfo: 
        """
        Returns info about a member.
        """
    @typing.overload
    def member_info(self, index: int) -> rti.connextdds.DynamicDataMemberInfo: 
        """
        Returns info about a member.
        """
    @typing.overload
    def set_boolean(self, name: str, value: bool) -> None: 
        """
        Set a boolean value by name.
        """
    @typing.overload
    def set_boolean(self, index: int, value: bool) -> None: 
        """
        Set a boolean value by index.
        """
    def set_cdr_buffer(self, buffer: Buffer) -> None: 
        """
        Sets the CDR buffer of this DynamicData sample.

        buffer can be any object that supports the buffer protocol and produces a one-dimensional contiguous byte buffer.
        """
    @typing.overload
    def set_char(self, name: str, value: str) -> None: 
        """
        Set a character value by name.
        """
    @typing.overload
    def set_char(self, index: int, value: str) -> None: 
        """
        Set a character value by index.
        """
    @typing.overload
    def set_char(self, name: str, value: int) -> None: 
        """
        Set a char value by field name using an int.
        """
    @typing.overload
    def set_char(self, index: int, value: int) -> None: 
        """
        Set a char value by field index using an int.
        """
    @typing.overload
    def set_char_values(self, name: str, values: object) -> None: 
        """
        Get multiple character values by field name.
        """
    @typing.overload
    def set_char_values(self, index: int, values: object) -> None: 
        """
        Get multiple character values by field name.
        """
    @typing.overload
    def set_complex(self, name: str, value: rti.connextdds.DynamicData) -> None: 
        """
        Set a complex data type value by name.
        """
    @typing.overload
    def set_complex(self, index: int, value: rti.connextdds.DynamicData) -> None: 
        """
        Set a complex data type value by index.
        """
    @typing.overload
    def set_complex_values(self, name: str, values: typing.Iterable) -> None: 
        """
        Set a list of complex values by field name.
        """
    @typing.overload
    def set_complex_values(self, index: int, values: typing.Iterable) -> None: 
        """
        Set a list of complex values by index.
        """
    @typing.overload
    def set_double(self, name: str, value: float) -> None: 
        """
        Set a 64-bit floating point value by name.
        """
    @typing.overload
    def set_double(self, index: int, value: float) -> None: 
        """
        Set a 64-bit floating point value by index.
        """
    @typing.overload
    def set_double_values(self, name: str, values: object) -> None: 
        """
        Get multiple 64-bit floating point values by field name.
        """
    @typing.overload
    def set_double_values(self, index: int, values: object) -> None: 
        """
        Get multiple 64-bit floating point values by field name.
        """
    @typing.overload
    def set_float(self, name: str, value: float) -> None: 
        """
        Set a 32-bit floating point value by name.
        """
    @typing.overload
    def set_float(self, index: int, value: float) -> None: 
        """
        Set a 32-bit floating point value by index.
        """
    @typing.overload
    def set_float128(self, name: str, value: rti.connextdds.LongDouble) -> None: 
        """
        Set a 128-bit floating point value by name.
        """
    @typing.overload
    def set_float128(self, index: int, value: rti.connextdds.LongDouble) -> None: 
        """
        Set a 128-bit floating point value by index.
        """
    @typing.overload
    def set_float32(self, name: str, value: float) -> None: 
        """
        Set a 32-bit floating point value by name.
        """
    @typing.overload
    def set_float32(self, index: int, value: float) -> None: 
        """
        Set a 32-bit floating point value by index.
        """
    @typing.overload
    def set_float32_values(self, name: str, values: object) -> None: 
        """
        Get multiple 32-bit floating point values by field name.
        """
    @typing.overload
    def set_float32_values(self, index: int, values: object) -> None: 
        """
        Get multiple 32-bit floating point values by field name.
        """
    @typing.overload
    def set_float64(self, name: str, value: float) -> None: 
        """
        Set a 64-bit floating point value by name.
        """
    @typing.overload
    def set_float64(self, index: int, value: float) -> None: 
        """
        Set a 64-bit floating point value by index.
        """
    @typing.overload
    def set_float64_values(self, name: str, values: object) -> None: 
        """
        Get multiple 64-bit floating point values by field name.
        """
    @typing.overload
    def set_float64_values(self, index: int, values: object) -> None: 
        """
        Get multiple 64-bit floating point values by field name.
        """
    @typing.overload
    def set_float_values(self, name: str, values: object) -> None: 
        """
        Get multiple 32-bit floating point values by field name.
        """
    @typing.overload
    def set_float_values(self, index: int, values: object) -> None: 
        """
        Get multiple 32-bit floating point values by field name.
        """
    @typing.overload
    def set_int(self, name: str, value: int) -> None: 
        """
        Set a int (signed) value by name.
        """
    @typing.overload
    def set_int(self, index: int, value: int) -> None: 
        """
        Set a int (signed) value by index.
        """
    @typing.overload
    def set_int16(self, name: str, value: int) -> None: 
        """
        Set a 16-bit signed int value by name.
        """
    @typing.overload
    def set_int16(self, index: int, value: int) -> None: 
        """
        Set a 16-bit signed int value by index.
        """
    @typing.overload
    def set_int16_values(self, name: str, values: object) -> None: 
        """
        Get multiple 16-bit signed int values by field name.
        """
    @typing.overload
    def set_int16_values(self, index: int, values: object) -> None: 
        """
        Get multiple 16-bit signed int values by field name.
        """
    @typing.overload
    def set_int32(self, name: str, value: int) -> None: 
        """
        Set a 32-bit signed int value by name.
        """
    @typing.overload
    def set_int32(self, index: int, value: int) -> None: 
        """
        Set a 32-bit signed int value by index.
        """
    @typing.overload
    def set_int32_values(self, name: str, values: object) -> None: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def set_int32_values(self, index: int, values: object) -> None: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def set_int64(self, name: str, value: int) -> None: 
        """
        Set a 64-bit signed int value by name.
        """
    @typing.overload
    def set_int64(self, index: int, value: int) -> None: 
        """
        Set a 64-bit signed int value by index.
        """
    @typing.overload
    def set_int64_values(self, name: str, values: object) -> None: 
        """
        Get multiple 64-bit signed int values by field name.
        """
    @typing.overload
    def set_int64_values(self, index: int, values: object) -> None: 
        """
        Get multiple 64-bit signed int values by field name.
        """
    @typing.overload
    def set_int8(self, name: str, value: int) -> None: 
        """
        Set an int8 value by field name using an int.
        """
    @typing.overload
    def set_int8(self, index: int, value: int) -> None: 
        """
        Set an int8 value by field index using an int.
        """
    @typing.overload
    def set_int_values(self, name: str, values: object) -> None: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def set_int_values(self, index: int, values: object) -> None: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def set_long(self, name: str, value: int) -> None: 
        """
        Set a 32-bit signed int value by name.
        """
    @typing.overload
    def set_long(self, index: int, value: int) -> None: 
        """
        Set a 32-bit signed int value by index.
        """
    @typing.overload
    def set_long_values(self, name: str, values: object) -> None: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def set_long_values(self, index: int, values: object) -> None: 
        """
        Get multiple 32-bit signed int values by field name.
        """
    @typing.overload
    def set_longdouble(self, name: str, value: rti.connextdds.LongDouble) -> None: 
        """
        Set a 128-bit floating point value by name.
        """
    @typing.overload
    def set_longdouble(self, index: int, value: rti.connextdds.LongDouble) -> None: 
        """
        Set a 128-bit floating point value by index.
        """
    @typing.overload
    def set_longlong(self, name: str, value: int) -> None: 
        """
        Set a 64-bit signed int value by name.
        """
    @typing.overload
    def set_longlong(self, index: int, value: int) -> None: 
        """
        Set a 64-bit signed int value by index.
        """
    @typing.overload
    def set_longlong_values(self, name: str, values: object) -> None: 
        """
        Get multiple 64-bit signed int values by field name.
        """
    @typing.overload
    def set_longlong_values(self, index: int, values: object) -> None: 
        """
        Get multiple 64-bit signed int values by field name.
        """
    @typing.overload
    def set_octet(self, name: str, value: int) -> None: 
        """
        Set a 8-bit unsigned int value by name.
        """
    @typing.overload
    def set_octet(self, index: int, value: int) -> None: 
        """
        Set a 8-bit unsigned int value by index.
        """
    @typing.overload
    def set_octet_values(self, name: str, values: object) -> None: 
        """
        Get multiple 8-bit unsigned int values by field name.
        """
    @typing.overload
    def set_octet_values(self, index: int, values: object) -> None: 
        """
        Get multiple 8-bit unsigned int values by field name.
        """
    @typing.overload
    def set_short(self, name: str, value: int) -> None: 
        """
        Set a 16-bit signed int value by name.
        """
    @typing.overload
    def set_short(self, index: int, value: int) -> None: 
        """
        Set a 16-bit signed int value by index.
        """
    @typing.overload
    def set_short_values(self, name: str, values: object) -> None: 
        """
        Get multiple 16-bit signed int values by field name.
        """
    @typing.overload
    def set_short_values(self, index: int, values: object) -> None: 
        """
        Get multiple 16-bit signed int values by field name.
        """
    @typing.overload
    def set_string(self, name: str, value: str) -> None: 
        """
        Set a string value by name.
        """
    @typing.overload
    def set_string(self, index: int, value: str) -> None: 
        """
        Set a string value by index.
        """
    @typing.overload
    def set_uint(self, name: str, value: int) -> None: 
        """
        Set a 32-bit unsigned int value by name.
        """
    @typing.overload
    def set_uint(self, index: int, value: int) -> None: 
        """
        Set a 32-bit unsigned int value by index.
        """
    @typing.overload
    def set_uint16(self, name: str, value: int) -> None: 
        """
        Set a 16-bit unsigned int value by name.
        """
    @typing.overload
    def set_uint16(self, index: int, value: int) -> None: 
        """
        Set a 16-bit unsigned int value by index.
        """
    @typing.overload
    def set_uint16_values(self, name: str, values: object) -> None: 
        """
        Get multiple 16-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint16_values(self, index: int, values: object) -> None: 
        """
        Get multiple 16-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint32(self, name: str, value: int) -> None: 
        """
        Set a 32-bit unsigned int value by name.
        """
    @typing.overload
    def set_uint32(self, index: int, value: int) -> None: 
        """
        Set a 32-bit unsigned int value by index.
        """
    @typing.overload
    def set_uint32_values(self, name: str, values: object) -> None: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint32_values(self, index: int, values: object) -> None: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint64(self, name: str, value: int) -> None: 
        """
        Set a 64-bit unsigned int value by name.
        """
    @typing.overload
    def set_uint64(self, index: int, value: int) -> None: 
        """
        Set a 64-bit unsigned int value by index.
        """
    @typing.overload
    def set_uint64_values(self, name: str, values: object) -> None: 
        """
        Get multiple 64-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint64_values(self, index: int, values: object) -> None: 
        """
        Get multiple 64-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint8(self, name: str, value: int) -> None: 
        """
        Set a 8-bit unsigned int value by name.
        """
    @typing.overload
    def set_uint8(self, index: int, value: int) -> None: 
        """
        Set a 8-bit unsigned int value by index.
        """
    @typing.overload
    def set_uint8_values(self, name: str, values: object) -> None: 
        """
        Get multiple 8-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint8_values(self, index: int, values: object) -> None: 
        """
        Get multiple 8-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint_values(self, name: str, values: object) -> None: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def set_uint_values(self, index: int, values: object) -> None: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def set_ulong(self, name: str, value: int) -> None: 
        """
        Set a 32-bit unsigned int value by name.
        """
    @typing.overload
    def set_ulong(self, index: int, value: int) -> None: 
        """
        Set a 32-bit unsigned int value by index.
        """
    @typing.overload
    def set_ulong_values(self, name: str, values: object) -> None: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def set_ulong_values(self, index: int, values: object) -> None: 
        """
        Get multiple 32-bit unsigned int values by field name.
        """
    @typing.overload
    def set_ulonglong(self, name: str, value: int) -> None: 
        """
        Set a 64-bit unsigned int value by name.
        """
    @typing.overload
    def set_ulonglong(self, index: int, value: int) -> None: 
        """
        Set a 64-bit unsigned int value by index.
        """
    @typing.overload
    def set_ulonglong_values(self, name: str, values: object) -> None: 
        """
        Get multiple 64-bit unsigned int values by field name.
        """
    @typing.overload
    def set_ulonglong_values(self, index: int, values: object) -> None: 
        """
        Get multiple 64-bit unsigned int values by field name.
        """
    @typing.overload
    def set_ushort(self, name: str, value: int) -> None: 
        """
        Set a 16-bit unsigned int value by name.
        """
    @typing.overload
    def set_ushort(self, index: int, value: int) -> None: 
        """
        Set a 16-bit unsigned int value by index.
        """
    @typing.overload
    def set_ushort_values(self, name: str, values: object) -> None: 
        """
        Get multiple 16-bit unsigned int values by field name.
        """
    @typing.overload
    def set_ushort_values(self, index: int, values: object) -> None: 
        """
        Get multiple 16-bit unsigned int values by field name.
        """
    @typing.overload
    def set_value(self, field_path: str, value: object) -> None: 
        """
        Automatically resolve type and set value for a field.
        """
    @typing.overload
    def set_value(self, field_path: int, value: object) -> None: 
        """
        Automatically resolve type and set value for a field.
        """
    @typing.overload
    def set_values(self, field_path: str, values: object) -> None: 
        """
        Automatically resolve type and set collection for a field.
        """
    @typing.overload
    def set_values(self, field_path: int, values: object) -> None: 
        """
        Automatically resolve type and set collection for a field.
        """
    @typing.overload
    def set_wchar(self, name: str, value: str) -> None: 
        """
        Set a wchar value by field name.
        """
    @typing.overload
    def set_wchar(self, index: int, value: str) -> None: 
        """
        Set a wchar value by field index.
        """
    @typing.overload
    def set_wstring(self, name: str, value: str) -> None: 
        """
        Set a wstring by field name.
        """
    @typing.overload
    def set_wstring(self, index: int, value: str) -> None: 
        """
        Set a wstring value by field index.
        """
    def to_cdr_buffer(self) -> rti.connextdds.CharSeq: 
        """
        Serializes a DynamicData sample to CDR format
        """
    def to_json(self) -> str: 
        """
        Convert DynamicData object to a JSON string representation
        """
    def to_string(self, format: rti.connextdds.PrintFormatProperty = PrintFormatProperty.default) -> str: 
        """
        Convert DynamicData object to string with print format.
        """
    def update(self, arg0: dict) -> None: ...
    @builtins.property
    def discriminator(self) -> int:
        """
        Used to get and set the discriminator value of a union. (valid for UnionType only)

        :type: int
        """
    @discriminator.setter
    def discriminator(self, arg1: int) -> None:
        """
        Used to get and set the discriminator value of a union. (valid for UnionType only)
        """
    @builtins.property
    def discriminator_value(self) -> int:
        """
        Deprecated: use the discriminator property instead.

        :type: int
        """
    @builtins.property
    def info(self) -> DynamicDataInfo:
        """
        Returns info about this sample

        :type: DynamicDataInfo
        """
    @builtins.property
    def is_cdr(self) -> bool:
        """
        Determines if this DynamicData sample is represented as CDR

        :type: bool
        """
    @builtins.property
    def member_count(self) -> int:
        """
        Get the number of members in this sample.

        :type: int
        """
    @builtins.property
    def type(self) -> object:
        """
        Gets the data type of this DynamicData.

        :type: object
        """
    @builtins.property
    def type_kind(self) -> TypeKind:
        """
        Gets this data type kind of this DynamicData.

        :type: TypeKind
        """
    __hash__: NoneType
    pass
class DynamicDataEncapsulationKind():
    class DynamicDataEncapsulationKind():
        """
        Members:

          CDR_BIG_ENDIAN : CDR big endian encapsulation.

          CDR_LITTLE_ENDIAN : CDR little endian encapsulation.

          PL_CDR_BIG_ENDIAN : PL CDR big endian encapsulation.

          PL_CDR_LITTLE_ENDIAN : PL CDR little endian encapsulation.

          DEFAULT : Default encapsulation.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        CDR_BIG_ENDIAN: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
        CDR_LITTLE_ENDIAN: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
        DEFAULT: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
        PL_CDR_BIG_ENDIAN: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
        PL_CDR_LITTLE_ENDIAN: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.DynamicDataEncapsulationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.DynamicDataEncapsulationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.DynamicDataEncapsulationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.DynamicDataEncapsulationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.DynamicDataEncapsulationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.DynamicDataEncapsulationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> DynamicDataEncapsulationKind.DynamicDataEncapsulationKind:
        """
        Retrieves the actual enumerated value.

        :type: DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
        """
    CDR_BIG_ENDIAN: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
    CDR_LITTLE_ENDIAN: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
    DEFAULT: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
    PL_CDR_BIG_ENDIAN: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
    PL_CDR_LITTLE_ENDIAN: rti.connextdds.DynamicDataEncapsulationKind.DynamicDataEncapsulationKind
    __hash__: NoneType
    pass
class DynamicDataInfo():
    def __eq__(self, arg0: rti.connextdds.DynamicDataInfo) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.DynamicDataInfo) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def encapsulation_kind(self) -> DynamicDataEncapsulationKind:
        """
        The encapsulation kind.

        :type: DynamicDataEncapsulationKind
        """
    @builtins.property
    def is_optimized_storage(self) -> bool:
        """
        Flag indicating whether storage is optimized.

        :type: bool
        """
    @builtins.property
    def member_count(self) -> int:
        """
        The number of members of this sample.

        :type: int
        """
    @builtins.property
    def stored_size(self) -> int:
        """
        The number of bytes currently used to store the data of this sample.

        :type: int
        """
    __hash__: NoneType
    pass
class DynamicDataMemberInfo():
    def __eq__(self, arg0: rti.connextdds.DynamicDataMemberInfo) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a DynamicDataMemberInfo object.
        """
    def __ne__(self, arg0: rti.connextdds.DynamicDataMemberInfo) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def element_count(self) -> int:
        """
        The number of elements in the member.

        :type: int
        """
    @builtins.property
    def element_kind(self) -> TypeKind:
        """
        The type kind of the elements in the member

        :type: TypeKind
        """
    @builtins.property
    def index(self) -> int:
        """
        The member index

        :type: int
        """
    @builtins.property
    def kind(self) -> TypeKind:
        """
        The member type kind

        :type: TypeKind
        """
    @builtins.property
    def name(self) -> str:
        """
        The member name

        :type: str
        """
    __hash__: NoneType
    pass
class DynamicDataProperty():
    def __eq__(self, arg0: rti.connextdds.DynamicDataProperty) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Construct with default settings.
        """
    @typing.overload
    def __init__(self, initial_buffer_size: int, max_buffer_size: int, max_buffer_size_increment: int, check_buffer_size: bool) -> None: ...
    def __ne__(self, arg0: rti.connextdds.DynamicDataProperty) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def check_buffer_size(self) -> bool:
        """
        Check buffer size.

        :type: bool
        """
    @check_buffer_size.setter
    def check_buffer_size(self, arg1: bool) -> None:
        """
        Check buffer size.
        """
    @builtins.property
    def initial_buffer_size(self) -> int:
        """
        Initial buffer size.

        :type: int
        """
    @initial_buffer_size.setter
    def initial_buffer_size(self, arg1: int) -> None:
        """
        Initial buffer size.
        """
    @builtins.property
    def max_buffer_size(self) -> int:
        """
        Max buffer size.

        :type: int
        """
    @max_buffer_size.setter
    def max_buffer_size(self, arg1: int) -> None:
        """
        Max buffer size.
        """
    @builtins.property
    def max_buffer_size_increment(self) -> int:
        """
        Max buffer size.

        :type: int
        """
    @max_buffer_size_increment.setter
    def max_buffer_size_increment(self, arg1: int) -> None:
        """
        Max buffer size.
        """
    __hash__: NoneType
    pass
class DynamicDataSeq():
    def __add__(self, arg0: rti.connextdds.DynamicDataSeq) -> rti.connextdds.DynamicDataSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.DynamicData) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.DynamicDataSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.DynamicDataSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.DynamicData: ...
    def __iadd__(self, arg0: rti.connextdds.DynamicDataSeq) -> rti.connextdds.DynamicDataSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.DynamicDataSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DynamicDataSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.DynamicData]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.DynamicDataSeq: ...
    def __ne__(self, arg0: rti.connextdds.DynamicDataSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.DynamicDataSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.DynamicData) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.DynamicDataSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.DynamicData) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.DynamicData) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.DynamicDataSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.DynamicData) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.DynamicData: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.DynamicData: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.DynamicData) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class DynamicDataTimestampedSeq():
    def __add__(self, arg0: rti.connextdds.DynamicDataTimestampedSeq) -> rti.connextdds.DynamicDataTimestampedSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: tuple[rti.connextdds.DynamicData, rti.connextdds.Time]) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.DynamicDataTimestampedSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.DynamicDataTimestampedSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> tuple[rti.connextdds.DynamicData, rti.connextdds.Time]: ...
    def __iadd__(self, arg0: rti.connextdds.DynamicDataTimestampedSeq) -> rti.connextdds.DynamicDataTimestampedSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.DynamicDataTimestampedSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.DynamicDataTimestampedSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[tuple[rti.connextdds.DynamicData, rti.connextdds.Time]]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.DynamicDataTimestampedSeq: ...
    def __ne__(self, arg0: rti.connextdds.DynamicDataTimestampedSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.DynamicDataTimestampedSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: tuple[rti.connextdds.DynamicData, rti.connextdds.Time]) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.DynamicDataTimestampedSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: tuple[rti.connextdds.DynamicData, rti.connextdds.Time]) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: tuple[rti.connextdds.DynamicData, rti.connextdds.Time]) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.DynamicDataTimestampedSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: tuple[rti.connextdds.DynamicData, rti.connextdds.Time]) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> tuple[rti.connextdds.DynamicData, rti.connextdds.Time]: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> tuple[rti.connextdds.DynamicData, rti.connextdds.Time]: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: tuple[rti.connextdds.DynamicData, rti.connextdds.Time]) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class DynamicDataTypeSerializationProperty():
    def __eq__(self, arg0: rti.connextdds.DynamicDataTypeSerializationProperty) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Construct with default settings.
        """
    @typing.overload
    def __init__(self, max_serialized_size: int, min_serialized_size: int, trim_to_size: bool, skip_deserialization: bool) -> None: 
        """
        Specify all serialization settings at object creation time.
        """
    def __ne__(self, arg0: rti.connextdds.DynamicDataTypeSerializationProperty) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def max_serialized_size(self) -> int:
        """
        The maximum number of bytes that objects of a given type could consume when serialized on the network. [DEPRECATED]

        :type: int
        """
    @max_serialized_size.setter
    def max_serialized_size(self, arg1: int) -> None:
        """
        The maximum number of bytes that objects of a given type could consume when serialized on the network. [DEPRECATED]
        """
    @builtins.property
    def min_serialized_size(self) -> int:
        """
        The minimum number of bytes that objects of a given type could consume when serialized on the network. [DEPRECATED]

        :type: int
        """
    @min_serialized_size.setter
    def min_serialized_size(self, arg1: int) -> None:
        """
        The minimum number of bytes that objects of a given type could consume when serialized on the network. [DEPRECATED]
        """
    @builtins.property
    def skip_deserialization(self) -> bool:
        """
        Controls whether the DynamicData object will be deserialized by a DynamicDataReader.

        :type: bool
        """
    @skip_deserialization.setter
    def skip_deserialization(self, arg1: bool) -> None:
        """
        Controls whether the DynamicData object will be deserialized by a DynamicDataReader.
        """
    @builtins.property
    def trim_to_size(self) -> bool:
        """
        Controls the growth of the buffer in a DynamicData object.

        :type: bool
        """
    @trim_to_size.setter
    def trim_to_size(self, arg1: bool) -> None:
        """
        Controls the growth of the buffer in a DynamicData object.
        """
    DEFAULT: rti.connextdds.DynamicDataTypeSerializationProperty
    __hash__: NoneType
    pass
class ACTEnumMember(DynamicType):
    def __eq__(self, arg0: rti.connextdds.ACTEnumMember) -> bool: 
        """
        Test for equality.
        """
    def __getattr__(self, arg0: str) -> rti.connextdds.EnumMember: ...
    @typing.overload
    def __getitem__(self, arg0: str) -> rti.connextdds.EnumMember: ...
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.EnumMember: ...
    def __ne__(self, arg0: rti.connextdds.ACTEnumMember) -> bool: 
        """
        Test for inequality.
        """
    def cdr_serialized_sample_max_size(self, arg0: int) -> int: 
        """
        Gets the maximum serialized size of samples of this type.
        """
    def cdr_serialized_sample_min_size(self, arg0: int) -> int: 
        """
        Gets the minimum serialized size of samples of this type.
        """
    def extensibility_kind(self) -> rti.connextdds.ExtensibilityKind: 
        """
        Gets the extensibility kind.
        """
    def find_member_by_name(self, arg0: str) -> int: 
        """
        Obtains the member index from its name.
        """
    @typing.overload
    def member(self, arg0: int) -> rti.connextdds.EnumMember: 
        """
        Gets a member by its index.
        """
    @typing.overload
    def member(self, arg0: str) -> rti.connextdds.EnumMember: 
        """
        Gets a member by its name.
        """
    def members(self) -> rti.connextdds.EnumMemberSeq: 
        """
        Gets a copy of all the members
        """
    @builtins.property
    def member_count(self) -> int:
        """
        Gets the number of members.

        :type: int
        """
    INVALID_INDEX: int
    __hash__: NoneType
    pass
class DynamicTypePrintFormatProperty():
    def __eq__(self, arg0: rti.connextdds.DynamicTypePrintFormatProperty) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, indent: int = 0, print_ordinals: bool = False) -> None: 
        """
        Construct with default settings.
        """
    def __ne__(self, arg0: rti.connextdds.DynamicTypePrintFormatProperty) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def indent(self) -> int:
        """
        The amount of additional indent to be included when converting a DynamicType to a string.

        :type: int
        """
    @indent.setter
    def indent(self, arg1: int) -> None:
        """
        The amount of additional indent to be included when converting a DynamicType to a string.
        """
    @builtins.property
    def min_serialized_size(self) -> bool:
        """
        The minimum number of bytes that objects of a given type could consume when serialized on the network. [DEPRECATED]

        :type: bool
        """
    @min_serialized_size.setter
    def min_serialized_size(self, arg1: bool) -> None:
        """
        The minimum number of bytes that objects of a given type could consume when serialized on the network. [DEPRECATED]
        """
    __hash__: NoneType
    pass
class EndpointGroup():
    def __init__(self, role_name: str, quorum_count: int) -> None: 
        """
        Create an EndpointGroup with the provided parameters.
        """
    @builtins.property
    def quorum_count(self) -> int:
        """
        Get/set the EndpointGroup's quorum count.

        :type: int
        """
    @quorum_count.setter
    def quorum_count(self, arg1: int) -> None:
        """
        Get/set the EndpointGroup's quorum count.
        """
    @builtins.property
    def role_name(self) -> str:
        """
        Get/set the EndpointGroup's role name.

        :type: str
        """
    @role_name.setter
    def role_name(self, arg1: str) -> None:
        """
        Get/set the EndpointGroup's role name.
        """
    pass
class EndpointGroupSeq():
    def __add__(self, arg0: rti.connextdds.EndpointGroupSeq) -> rti.connextdds.EndpointGroupSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.EndpointGroup) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.EndpointGroupSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.EndpointGroupSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.EndpointGroup: ...
    def __iadd__(self, arg0: rti.connextdds.EndpointGroupSeq) -> rti.connextdds.EndpointGroupSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.EndpointGroupSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.EndpointGroupSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.EndpointGroup]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.EndpointGroupSeq: ...
    def __ne__(self, arg0: rti.connextdds.EndpointGroupSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.EndpointGroupSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.EndpointGroup) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.EndpointGroupSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.EndpointGroup) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.EndpointGroup) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.EndpointGroupSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.EndpointGroup) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.EndpointGroup: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.EndpointGroup: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.EndpointGroup) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class EndpointGroupVector():
    """
    A DDS standard container with functionality similar to a C++ vector.
    """
    def __eq__(self, arg0: rti.connextdds.EndpointGroupVector) -> bool: 
        """
        Compare EndpointGroupVectors for equality.
        """
    def __getitem__(self, arg0: int) -> rti.connextdds.EndpointGroup: 
        """
        Get the value at the specified index.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty EndpointGroupVector
        """
    @typing.overload
    def __init__(self, size: int) -> None: 
        """
        Create a EndpointGroupVector with a preallocated size.
        """
    @typing.overload
    def __init__(self, vector: rti.connextdds.EndpointGroupVector) -> None: 
        """
        Create a copy from another EndpointGroupVector.
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, list: rti.connextdds.EndpointGroupSeq) -> None: 
        """
        Create a EndpointGroupVector from a list of values.
        """
    def __iter__(self) -> typing.Iterator[rti.connextdds.EndpointGroup]: 
        """
        Iterate over the contents of the vector.
        """
    def __len__(self) -> int: 
        """
        Get the length of the EndpointGroupVector.
        """
    def __ne__(self, arg0: rti.connextdds.EndpointGroupVector) -> bool: 
        """
        Compare EndpointGroupVectors for inequality.
        """
    def __setitem__(self, arg0: int, arg1: rti.connextdds.EndpointGroup) -> None: 
        """
        Set the value at the specified index.
        """
    def clear(self) -> None: 
        """
        Resize EndpointGroupVector to 0.
        """
    def resize(self, size: int) -> None: 
        """
        Resize EndpointGroupVector.
        """
    __hash__: NoneType
    pass
class Entity(IEntity):
    pass
class EntityFactory():
    def __eq__(self, arg0: rti.connextdds.EntityFactory) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, auto_enable: bool) -> None: 
        """
        Specifies whether the entity acting as a factory automatically enables the instances it creates.
        """
    def __ne__(self, arg0: rti.connextdds.EntityFactory) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def autoenable_created_entities(self) -> bool:
        """
        Whether the entity acting as a factory automatically enables the instances it creates.

        :type: bool
        """
    @autoenable_created_entities.setter
    def autoenable_created_entities(self, arg1: bool) -> None:
        """
        Whether the entity acting as a factory automatically enables the instances it creates.
        """
    __hash__: NoneType
    auto_enable: rti.connextdds.EntityFactory
    manually_enable: rti.connextdds.EntityFactory
    pass
class EntityLock():
    def __enter__(self) -> rti.connextdds.EntityLock: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    def unlock(self) -> None: ...
    pass
class EntityName():
    def __eq__(self, arg0: rti.connextdds.EntityName) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy (no name).
        """
    @typing.overload
    def __init__(self, name: str) -> None: 
        """
        Creates an instance that specifies an entity name.
        """
    def __ne__(self, arg0: rti.connextdds.EntityName) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def name(self) -> typing.Optional[str]:
        """
        Sets the entity name.

        :type: typing.Optional[str]
        """
    @name.setter
    def name(self, arg1: typing.Optional[str]) -> None:
        """
        Sets the entity name.
        """
    @builtins.property
    def role_name(self) -> typing.Optional[str]:
        """
        Sets the role name.

        :type: typing.Optional[str]
        """
    @role_name.setter
    def role_name(self, arg1: typing.Optional[str]) -> None:
        """
        Sets the role name.
        """
    __hash__: NoneType
    pass
class EntitySeq():
    def __add__(self, arg0: rti.connextdds.EntitySeq) -> rti.connextdds.EntitySeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.Entity) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.EntitySeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.EntitySeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Entity: ...
    def __iadd__(self, arg0: rti.connextdds.EntitySeq) -> rti.connextdds.EntitySeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.EntitySeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.EntitySeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.Entity]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.EntitySeq: ...
    def __ne__(self, arg0: rti.connextdds.EntitySeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.EntitySeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Entity) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.EntitySeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.Entity) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.Entity) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.EntitySeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.Entity) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.Entity: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.Entity: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.Entity) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class EnumMember():
    @typing.overload
    def __eq__(self, arg0: rti.connextdds.EnumMember) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __eq__(self, arg0: int) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, name: str, ordinal: int) -> None: 
        """
        Create an EnumMember with a given name and ordinal value.
        """
    def __int__(self) -> int: ...
    def __long__(self) -> int: ...
    @typing.overload
    def __ne__(self, arg0: rti.connextdds.EnumMember) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __ne__(self, arg0: int) -> bool: 
        """
        Test for inequality.
        """
    def __str__(self) -> str: ...
    @builtins.property
    def name(self) -> str:
        """
        The member name.

        :type: str
        """
    @name.setter
    def name(self, arg1: str) -> None:
        """
        The member name.
        """
    @builtins.property
    def ordinal(self) -> int:
        """
        The member's ordinal.

        :type: int
        """
    @ordinal.setter
    def ordinal(self, arg1: int) -> None:
        """
        The member's ordinal.
        """
    __hash__: NoneType
    pass
class EnumMemberSeq():
    def __add__(self, arg0: rti.connextdds.EnumMemberSeq) -> rti.connextdds.EnumMemberSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.EnumMember) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.EnumMemberSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.EnumMemberSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.EnumMember: ...
    def __iadd__(self, arg0: rti.connextdds.EnumMemberSeq) -> rti.connextdds.EnumMemberSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.EnumMemberSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.EnumMemberSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.EnumMember]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.EnumMemberSeq: ...
    def __ne__(self, arg0: rti.connextdds.EnumMemberSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.EnumMemberSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.EnumMember) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.EnumMemberSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.EnumMember) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.EnumMember) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.EnumMemberSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.EnumMember) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.EnumMember: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.EnumMember: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.EnumMember) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class EnumType(ACTEnumMember, DynamicType):
    def __eq__(self, arg0: rti.connextdds.EnumType) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, name: str) -> None: 
        """
        Creates an empty EnumType.
        """
    @typing.overload
    def __init__(self, name: str, members: rti.connextdds.EnumMemberSeq) -> None: 
        """
        Creates a enum with the members in the list.
        """
    @typing.overload
    def __init__(self, type: rti.connextdds.DynamicType) -> None: 
        """
        Cast a DynamicType to an EnumType.
        """
    def __ne__(self, arg0: rti.connextdds.EnumType) -> bool: 
        """
        Test for inequality.
        """
    def add_member(self, member: rti.connextdds.EnumMember) -> rti.connextdds.EnumType: 
        """
        Adds a member at the end.
        """
    def add_members(self, members: rti.connextdds.EnumMemberSeq) -> rti.connextdds.EnumType: 
        """
        Adds a member at the end.
        """
    def find_member_by_ordinal(self, ordinal: int) -> int: 
        """
        Gets the index of the member with this ordinal value.
        """
    @builtins.property
    def extensibility_kind(self) -> ExtensibilityKind:
        """
        Enum's extensibility kind.

        :type: ExtensibilityKind
        """
    @extensibility_kind.setter
    def extensibility_kind(self, arg1: ExtensibilityKind) -> None:
        """
        Enum's extensibility kind.
        """
    INVALID_INDEX: int
    __hash__: NoneType
    pass
class Error(Exception, Exception, BaseException):
    pass
class Event():
    def __eq__(self, arg0: rti.connextdds.Event) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, thread: rti.connextdds.ThreadSettings, initial_count: int, max_count: int) -> None: 
        """
        Creates an instance with all the parameters set.
        """
    def __ne__(self, arg0: rti.connextdds.Event) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def initial_count(self) -> int:
        """
        Event thread QoS.

        :type: int
        """
    @initial_count.setter
    def initial_count(self, arg1: int) -> None:
        """
        Event thread QoS.
        """
    @builtins.property
    def max_count(self) -> int:
        """
        Event thread QoS.

        :type: int
        """
    @max_count.setter
    def max_count(self, arg1: int) -> None:
        """
        Event thread QoS.
        """
    @builtins.property
    def thread(self) -> ThreadSettings:
        """
        Event thread QoS.

        :type: ThreadSettings
        """
    @thread.setter
    def thread(self, arg1: ThreadSettings) -> None:
        """
        Event thread QoS.
        """
    __hash__: NoneType
    pass
class EventCount32():
    @builtins.property
    def change(self) -> int:
        """
        The incremental count.

        :type: int
        """
    @builtins.property
    def total(self) -> int:
        """
        The total count.

        :type: int
        """
    pass
class EventCount64():
    @builtins.property
    def change(self) -> int:
        """
        The incremental count.

        :type: int
        """
    @builtins.property
    def total(self) -> int:
        """
        The total count.

        :type: int
        """
    pass
class AlreadyClosedError(Exception, Exception, BaseException):
    pass
class ExpressionProperty():
    def __eq__(self, arg0: rti.connextdds.ExpressionProperty) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default ExpressionProperty with key_only_filter = false and writer_side_filter_optimization = false.
        """
    @typing.overload
    def __init__(self, key_only_filter: bool, writer_side_filter_optimization: bool) -> None: 
        """
        Create an ExpressionProperty with the provided key_only_filter, and writer_side_filter_optimization.
        """
    def __ne__(self, arg0: rti.connextdds.ExpressionProperty) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def key_only_filter(self) -> bool:
        """
        The value for key_only_filter, indicating if the filter expression is based only on key fields. In this case, RTI Connext itself can cache the filtering results.

        :type: bool
        """
    @key_only_filter.setter
    def key_only_filter(self, arg1: bool) -> None:
        """
        The value for key_only_filter, indicating if the filter expression is based only on key fields. In this case, RTI Connext itself can cache the filtering results.
        """
    @builtins.property
    def writer_side_filter_optimization(self) -> bool:
        """
        The value for writer_side_filter_optimization, indicating if the filter implementation can cache the filtering result for the provided expression.

        :type: bool
        """
    @writer_side_filter_optimization.setter
    def writer_side_filter_optimization(self, arg1: bool) -> None:
        """
        The value for writer_side_filter_optimization, indicating if the filter implementation can cache the filtering result for the provided expression.
        """
    __hash__: NoneType
    pass
class ExtensibilityKind():
    class ExtensibilityKind():
        """
        Members:

          FINAL : Final extensibility.

          EXTENSIBLE : Extensible extensibility.

          MUTABLE : Mutable extensibility.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        EXTENSIBLE: rti.connextdds.ExtensibilityKind.ExtensibilityKind
        FINAL: rti.connextdds.ExtensibilityKind.ExtensibilityKind
        MUTABLE: rti.connextdds.ExtensibilityKind.ExtensibilityKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.ExtensibilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.ExtensibilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.ExtensibilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ExtensibilityKind.ExtensibilityKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.ExtensibilityKind.ExtensibilityKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.ExtensibilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.ExtensibilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.ExtensibilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> ExtensibilityKind.ExtensibilityKind:
        """
        Retrieves the actual enumerated value.

        :type: ExtensibilityKind.ExtensibilityKind
        """
    EXTENSIBLE: rti.connextdds.ExtensibilityKind.ExtensibilityKind
    FINAL: rti.connextdds.ExtensibilityKind.ExtensibilityKind
    MUTABLE: rti.connextdds.ExtensibilityKind.ExtensibilityKind
    __hash__: NoneType
    pass
class Filter():
    @typing.overload
    def __init__(self, expression: str) -> None: 
        """
        Create a Filter with the specified expression.
        """
    @typing.overload
    def __init__(self, expression: str, parameters: rti.connextdds.StringSeq) -> None: 
        """
        Create a Filter with the specified expression and parameters.
        """
    def __iter__(self) -> typing.Iterator[str]: ...
    def add_parameters(self, parameter: str) -> rti.connextdds.Filter: 
        """
        Append a parameter to the Filter.
        """
    def set_parameters(self, arg0: rti.connextdds.StringSeq) -> None: 
        """
        Set the parameters for the Filter.
        """
    @builtins.property
    def expression(self) -> str:
        """
        Get the Filter's expression.

        :type: str
        """
    @builtins.property
    def name(self) -> str:
        """
        The name of the type of Filter.

        :type: str
        """
    @name.setter
    def name(self, arg1: str) -> None:
        """
        The name of the type of Filter.
        """
    @builtins.property
    def parameter_count(self) -> int:
        """
        Get the number of parameters.

        :type: int
        """
    SQL_FILTER_NAME: str
    STRINGMATCH_FILTER_NAME: str
    pass
class FilterSampleInfo():
    def __eq__(self, arg0: rti.connextdds.FilterSampleInfo) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.FilterSampleInfo) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def priority(self) -> int:
        """
        Get a positive integer designating the relative priority of the sample, used to determine the transmission order of pending transmissions.

        :type: int
        """
    @builtins.property
    def related_sample_identity(self) -> SampleIdentity:
        """
        The Identity of another sample related to this one.

        :type: SampleIdentity
        """
    __hash__: NoneType
    pass
class Float128Seq():
    def __add__(self, arg0: rti.connextdds.Float128Seq) -> rti.connextdds.Float128Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.LongDouble) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Float128Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Float128Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.LongDouble: ...
    def __iadd__(self, arg0: rti.connextdds.Float128Seq) -> rti.connextdds.Float128Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Float128Seq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Float128Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.LongDouble]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Float128Seq: ...
    def __ne__(self, arg0: rti.connextdds.Float128Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Float128Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.LongDouble) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Float128Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.LongDouble) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.LongDouble) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Float128Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.LongDouble) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.LongDouble: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.LongDouble: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.LongDouble) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class Float128Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Float128Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Float128Type
        """
    def __ne__(self, arg0: rti.connextdds.Float128Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class Float32Seq():
    def __add__(self, arg0: rti.connextdds.Float32Seq) -> rti.connextdds.Float32Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: float) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Float32Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Float32Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> float: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Float32Seq) -> rti.connextdds.Float32Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Float32Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Float32Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Float32Seq: ...
    def __ne__(self, arg0: rti.connextdds.Float32Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Float32Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Float32Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: float) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: float) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Float32Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: float) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> float: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> float: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: float) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Float32Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Float32Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Float32Type
        """
    def __ne__(self, arg0: rti.connextdds.Float32Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
DoubleSeq = Float64Seq
DoubleType = Float64Type
FloatSeq = Float32Seq
FloatType = Float32Type
class FlowController():
    def __eq__(self, arg0: rti.connextdds.FlowController) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, participant: rti.connextdds.DomainParticipant, name: str, token_bucket: rti.connextdds.FlowControllerProperty = FlowControllerProperty()) -> None: 
        """
        Creates a FlowController with specific properties.
        """
    def __ne__(self, arg0: rti.connextdds.FlowController) -> bool: 
        """
        Test for inequality.
        """
    def close(self) -> None: 
        """
        Manually destroys this object.
        """
    def retain(self) -> None: 
        """
        Disables the automatic destruction of this object.
        """
    def trigger_flow(self) -> None: 
        """
        Provides an external way to trigger a FlowController.
        """
    @builtins.property
    def closed(self) -> bool:
        """
        Whether this FlowController has been closed.

        :type: bool
        """
    @builtins.property
    def name(self) -> str:
        """
        The name of this FlowController.

        :type: str
        """
    @builtins.property
    def participant(self) -> DomainParticipant:
        """
        The participant of this FlowController.

        :type: DomainParticipant
        """
    @builtins.property
    def property(self) -> FlowControllerProperty:
        """
        The configuration of this FlowController.

        :type: FlowControllerProperty
        """
    DEFAULT_NAME: str
    FIXED_RATE_NAME: str
    ON_DEMAND_NAME: str
    __hash__: NoneType
    pass
class FlowControllerProperty():
    def __eq__(self, arg0: rti.connextdds.FlowControllerProperty) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a FlowControllerProperty with earliest-deadline-first scheduling policy and default token-bucket configuration.
        """
    @typing.overload
    def __init__(self, scheduling_policy: rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy, token_bucket: rti.connextdds.FlowControllerTokenBucketProperty = FlowControllerTokenBucketProperty()) -> None: 
        """
        Creates a FlowControllerProperty with the specified scheduling policy and token-bucket configuration.
        """
    def __ne__(self, arg0: rti.connextdds.FlowControllerProperty) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def scheduling_policy(self) -> FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy:
        """
        The scheduling policy.

        :type: FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy
        """
    @scheduling_policy.setter
    def scheduling_policy(self, arg1: FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy) -> None:
        """
        The scheduling policy.
        """
    @builtins.property
    def token_bucket(self) -> FlowControllerTokenBucketProperty:
        """
        The token-bucket configuration

        :type: FlowControllerTokenBucketProperty
        """
    @token_bucket.setter
    def token_bucket(self, arg1: FlowControllerTokenBucketProperty) -> None:
        """
        The token-bucket configuration
        """
    __hash__: NoneType
    pass
class FlowControllerSchedulingPolicy():
    class FlowControllerSchedulingPolicy():
        """
        Members:

          ROUND_ROBIN : Indicates to flow control in a round-robin fashion.

        Whenever tokens become available, the flow controller distributes the tokens uniformly across all of its (non-empty) destination queues. No destinations are prioritized. Instead, all destinations are treated equally and are serviced in a round-robin fashion.

          EARLIEST_DEADLINE_FIRST : Indicates to flow control in an earliest-deadline-first fashion.

        A sample's deadline is determined by the time it was written plus the latency budget of the DataWriter at the time of the write call (as specified in the LatencyBudget). The relative priority of a flow controller's destination queue is determined by the earliest deadline across all samples it contains.

        When tokens become available, the FlowController distributes tokens to the destination queues in order of their deadline priority. In other words, the queue containing the sample with the earliest deadline is serviced first. The number of tokens granted equals the number of tokens required to send the first sample in the queue. Note that the priority of a queue may change as samples are sent (i.e. removed from the queue). If a sample must be sent to multiple destinations or two samples have an equal deadline value, the corresponding destination queues are serviced in a round-robin fashion.

        Hence, under the default LatencyBudget::duration setting, an EDF_FLOW_CONTROLLER_SCHED_POLICY FlowController preserves the order in which the user calls DataWriter.write() across the DataWriters associated with the flow controller.

        Since the LatencyBudget is mutable, a sample written second may contain an earlier deadline than the sample written first if the LatencyBudget.duration value is sufficiently decreased in between writing the two samples. In that case, if the first sample is not yet written (still in queue waiting for its turn), it inherits the priority corresponding to the (earlier) deadline from the second sample.

        In other words, the priority of a destination queue is always determined by the earliest deadline among all samples contained in the queue. This priority inheritance approach is required in order to both honor the updated LatencyBudget.duration and adhere to the DataWriter in-order data delivery guarantee.

        [default] for DataWriter

          HIGHEST_PRIORITY_FIRST : Indicates to flow control in a highest-priority-first fashion.

        Determines the next destination queue to service as determined by the publication priority of the DataWriter, channel of multi-channel DataWriter, or individual sample.

        The relative priority of a flow controller's destination queue is determined by the highest publication priority of all samples it contains.

        When tokens become available, the FlowController distributes tokens to the destination queues in order of their publication priority. In other words, the queue containing the sample with the highest publication priority is serviced first. The number of tokens granted equals the number of tokens required to send the first sample in the queue. Note that the priority of a queue may change as samples are sent (i.e. removed from the queue). If a sample must be sent to multiple destinations or two samples have an equal publication priority, the corresponding destination queues are serviced in a round-robin fashion.

        This priority inheritance approach is required in order to both honor the designated publication priority and adhere to the DataWriter in-order data delivery guarantee.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        EARLIEST_DEADLINE_FIRST: rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy
        HIGHEST_PRIORITY_FIRST: rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy
        ROUND_ROBIN: rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.FlowControllerSchedulingPolicy) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.FlowControllerSchedulingPolicy) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.FlowControllerSchedulingPolicy) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.FlowControllerSchedulingPolicy) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.FlowControllerSchedulingPolicy) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.FlowControllerSchedulingPolicy) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy:
        """
        Retrieves the actual enumerated value.

        :type: FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy
        """
    EARLIEST_DEADLINE_FIRST: rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy
    HIGHEST_PRIORITY_FIRST: rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy
    ROUND_ROBIN: rti.connextdds.FlowControllerSchedulingPolicy.FlowControllerSchedulingPolicy
    __hash__: NoneType
    pass
class FlowControllerTokenBucketProperty():
    def __eq__(self, arg0: rti.connextdds.FlowControllerTokenBucketProperty) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, max_tokens: int = LENGTH_UNLIMITED, tokens_added_per_period: int = LENGTH_UNLIMITED, tokens_leaked_per_period: int = 0, period: rti.connextdds.Duration = Duration(1, 0), bytes_per_token: int = LENGTH_UNLIMITED) -> None: 
        """
        Initializes the properties.
        """
    def __ne__(self, arg0: rti.connextdds.FlowControllerTokenBucketProperty) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def bytes_per_token(self) -> int:
        """
        The maximum number of bytes allowed to send for each token available.

        :type: int
        """
    @bytes_per_token.setter
    def bytes_per_token(self, arg1: int) -> None:
        """
        The maximum number of bytes allowed to send for each token available.
        """
    @builtins.property
    def max_tokens(self) -> int:
        """
        The maximum number of tokens that can accumulate in the token bucket.

        :type: int
        """
    @max_tokens.setter
    def max_tokens(self, arg1: int) -> None:
        """
        The maximum number of tokens that can accumulate in the token bucket.
        """
    @builtins.property
    def period(self) -> Duration:
        """
        The period for adding tokens to and removing tokens from the bucket.

        :type: Duration
        """
    @period.setter
    def period(self, arg1: Duration) -> None:
        """
        The period for adding tokens to and removing tokens from the bucket.
        """
    @builtins.property
    def tokens_added_per_period(self) -> int:
        """
        The number of tokens added to the token bucket per specified period.

        :type: int
        """
    @tokens_added_per_period.setter
    def tokens_added_per_period(self, arg1: int) -> None:
        """
        The number of tokens added to the token bucket per specified period.
        """
    @builtins.property
    def tokens_leaked_per_period(self) -> int:
        """
        The number of tokens removed from the token bucket per specified period.

        :type: int
        """
    @tokens_leaked_per_period.setter
    def tokens_leaked_per_period(self, arg1: int) -> None:
        """
        The number of tokens removed from the token bucket per specified period.
        """
    __hash__: NoneType
    pass
class GenerationCount():
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default GenerationCount object.
        """
    @typing.overload
    def __init__(self, disposed_count: int, no_writers_count: int) -> None: 
        """
        Create a GenerationCount object with the provided disposed_count and no_writers count.
        """
    @builtins.property
    def disposed(self) -> int:
        """
        Get the disposed generation count.

        :type: int
        """
    @builtins.property
    def no_writers(self) -> int:
        """
        Get the no_writers generation count.

        :type: int
        """
    pass
class GroupData():
    def __eq__(self, arg0: rti.connextdds.GroupData) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a GroupData instance.
        """
    @typing.overload
    def __init__(self, bytes: rti.connextdds.Uint8Seq) -> None: 
        """
        Create a GroupData instance with a sequence of bytes.
        """
    def __iter__(self) -> typing.Iterator[int]: ...
    def __ne__(self, arg0: rti.connextdds.GroupData) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> Uint8Seq:
        """
        The byte sequence of this GroupData.

        :type: Uint8Seq
        """
    @value.setter
    def value(self, arg1: Uint8Seq) -> None:
        """
        The byte sequence of this GroupData.
        """
    __hash__: NoneType
    pass
class GuardCondition(ICondition):
    def __eq__(self, arg0: rti.connextdds.GuardCondition) -> bool: 
        """
        Compare GuardCondition objects for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a GuardCondition in an untriggered state.
        """
    @typing.overload
    def __init__(self, condition: rti.connextdds.ICondition) -> None: 
        """
        Create a GuardCondition from a Condition.
        """
    def __ne__(self, arg0: rti.connextdds.GuardCondition) -> bool: 
        """
        Compare GuardCondition objects for inequality.
        """
    def reset_handler(self) -> None: 
        """
        Resets the handler for this GuardCondition.
        """
    def set_handler(self, func: typing.Callable[[rti.connextdds.GuardCondition], None]) -> None: 
        """
        Set a handler function receiving the Condition as its only argument.
        """
    def set_handler_no_args(self, func: typing.Callable[[], None]) -> None: 
        """
        Set a handler function with no arguments.
        """
    @builtins.property
    def trigger_value(self) -> bool:
        """
        Get/set the trigger value for this GuardCondition

        :type: bool
        """
    @trigger_value.setter
    def trigger_value(self, arg1: bool) -> None:
        """
        Get/set the trigger value for this GuardCondition
        """
    __hash__: NoneType
    pass
class Guid():
    def __eq__(self, arg0: rti.connextdds.Guid) -> bool: 
        """
        Compare Guids for equality.
        """
    def __ge__(self, arg0: rti.connextdds.Guid) -> bool: 
        """
        Compare Guids.
        """
    def __getitem__(self, arg0: int) -> int: ...
    def __gt__(self, arg0: rti.connextdds.Guid) -> bool: 
        """
        Compare Guids.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default Guid (equivalent to unknown Guid).
        """
    @typing.overload
    def __init__(self, builtin_topic_key: rti.connextdds.BuiltinTopicKey) -> None: 
        """
        Create a Guid from a BuiltinTopicKey.
        """
    def __le__(self, arg0: rti.connextdds.Guid) -> bool: 
        """
        Compare Guids.
        """
    def __len__(self) -> int: ...
    def __lt__(self, arg0: rti.connextdds.Guid) -> bool: 
        """
        Compare Guids.
        """
    def __ne__(self, arg0: rti.connextdds.Guid) -> bool: 
        """
        Compare Guids for inequality.
        """
    def __setitem__(self, arg0: int, arg1: int) -> int: ...
    def __str__(self) -> str: ...
    __hash__: NoneType
    automatic: rti.connextdds.Guid
    unknown: rti.connextdds.Guid
    pass
class History():
    def __eq__(self, arg0: rti.connextdds.History) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a policy that keeps the last sample only.
        """
    @typing.overload
    def __init__(self, kind: rti.connextdds.HistoryKind, depth: int = 1) -> None: 
        """
        Creates a policy with a specific history kind and optionally a history depth.
        """
    def __ne__(self, arg0: rti.connextdds.History) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    def keep_last(depth: int) -> rti.connextdds.History: 
        """
        Creates a History with HistoryKind.KEEP_LAST and the specified depth.
        """
    @builtins.property
    def depth(self) -> int:
        """
        The history kind.

        :type: int
        """
    @depth.setter
    def depth(self, arg1: int) -> None:
        """
        The history kind.
        """
    @builtins.property
    def kind(self) -> HistoryKind:
        """
        The history kind.

        :type: HistoryKind
        """
    @kind.setter
    def kind(self, arg1: HistoryKind) -> None:
        """
        The history kind.
        """
    __hash__: NoneType
    keep_all: rti.connextdds.History
    pass
class HistoryKind():
    class HistoryKind():
        """
        Members:

          KEEP_LAST : [default] Keep the last depth samples.

        On the publishing side, RTI Connext will only attempt to keep the most recent depth samples of each instance of data (identified by its key) managed by the DataWriter. Invalid samples represeting a disposal or unregistration of an instance do not count towards the history depth.

        On the subscribing side, the DataReader will only attempt to keep the most recent depth samples received for each instance (identified by its key) until the application takes them via the DataReader 's take() operation.

        Invalid samples represeting a dispoasal or unregistration of an instance do count towards the history depth and may therefore replace a value of the instance currently being stored in the reader queue.

          KEEP_ALL : Keep all the samples.

        On the publishing side, RTI Connext will attempt to keep all samples (representing each value written) of each instance of data (identified by its key) managed by the DataWriter until they can be delivered to all subscribers.

        On the subscribing side, RTI Connext will attempt to keep all samples of each instance of data (identified by its key) managed by the DataReader. These samples are kept until the application takes them from RTI Connext via the take() operation.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        KEEP_ALL: rti.connextdds.HistoryKind.HistoryKind
        KEEP_LAST: rti.connextdds.HistoryKind.HistoryKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.HistoryKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.HistoryKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.HistoryKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.HistoryKind.HistoryKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.HistoryKind.HistoryKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.HistoryKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.HistoryKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.HistoryKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> HistoryKind.HistoryKind:
        """
        Retrieves the actual enumerated value.

        :type: HistoryKind.HistoryKind
        """
    KEEP_ALL: rti.connextdds.HistoryKind.HistoryKind
    KEEP_LAST: rti.connextdds.HistoryKind.HistoryKind
    __hash__: NoneType
    pass
class AnyDataReader(IAnyDataReader):
    def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
        """
        Create an AnyDataReader instance from a object that conforms to the IAnyDataReader interface.
        """
    @staticmethod
    def _create_correlation_condition(reader: rti.connextdds.IAnyDataReader, sample_state: rti.connextdds.SampleState, related_sample_sn: rti.connextdds.SequenceNumber) -> rti.connextdds.ReadCondition: ...
    @staticmethod
    def _create_correlation_index(reader: rti.connextdds.IAnyDataReader) -> None: ...
    pass
class IAnyDataReaderSeq():
    def __add__(self, arg0: rti.connextdds.IAnyDataReaderSeq) -> rti.connextdds.IAnyDataReaderSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.IAnyDataReader) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.IAnyDataReaderSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.IAnyDataReaderSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.IAnyDataReader: ...
    def __iadd__(self, arg0: rti.connextdds.IAnyDataReaderSeq) -> rti.connextdds.IAnyDataReaderSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.IAnyDataReaderSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.IAnyDataReaderSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.IAnyDataReader]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.IAnyDataReaderSeq: ...
    def __ne__(self, arg0: rti.connextdds.IAnyDataReaderSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.IAnyDataReaderSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.IAnyDataReader) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.IAnyDataReaderSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.IAnyDataReader) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.IAnyDataReader) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.IAnyDataReaderSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.IAnyDataReader) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.IAnyDataReader: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.IAnyDataReader: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.IAnyDataReader) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class AnyDataWriter(IAnyDataWriter):
    def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
        """
        Create an AnyDataWriter instance from a object that conforms to the IAnyDataWriter interface.
        """
    pass
class IAnyDataWriterSeq():
    def __add__(self, arg0: rti.connextdds.IAnyDataWriterSeq) -> rti.connextdds.IAnyDataWriterSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.IAnyDataWriter) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.IAnyDataWriterSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.IAnyDataWriterSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.IAnyDataWriter: ...
    def __iadd__(self, arg0: rti.connextdds.IAnyDataWriterSeq) -> rti.connextdds.IAnyDataWriterSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.IAnyDataWriterSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.IAnyDataWriterSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.IAnyDataWriter]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.IAnyDataWriterSeq: ...
    def __ne__(self, arg0: rti.connextdds.IAnyDataWriterSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.IAnyDataWriterSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.IAnyDataWriter) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.IAnyDataWriterSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.IAnyDataWriter) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.IAnyDataWriter) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.IAnyDataWriterSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.IAnyDataWriter) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.IAnyDataWriter: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.IAnyDataWriter: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.IAnyDataWriter) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class AnyTopic(IAnyTopic):
    def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
        """
        Create an AnyTopic instance from a object that conforms to the IAnyTopic interface.
        """
    pass
class IAnyTopicSeq():
    def __add__(self, arg0: rti.connextdds.IAnyTopicSeq) -> rti.connextdds.IAnyTopicSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.IAnyTopic) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.IAnyTopicSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.IAnyTopicSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.IAnyTopic: ...
    def __iadd__(self, arg0: rti.connextdds.IAnyTopicSeq) -> rti.connextdds.IAnyTopicSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.IAnyTopicSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.IAnyTopicSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.IAnyTopic]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.IAnyTopicSeq: ...
    def __ne__(self, arg0: rti.connextdds.IAnyTopicSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.IAnyTopicSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.IAnyTopic) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.IAnyTopicSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.IAnyTopic) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.IAnyTopic) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.IAnyTopicSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.IAnyTopic) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.IAnyTopic: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.IAnyTopic: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.IAnyTopic) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class Condition(ICondition):
    pass
class IConditionSeq():
    def __add__(self, arg0: rti.connextdds.IConditionSeq) -> rti.connextdds.IConditionSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.ICondition) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.IConditionSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.IConditionSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.ICondition: ...
    def __iadd__(self, arg0: rti.connextdds.IConditionSeq) -> rti.connextdds.IConditionSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.IConditionSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.IConditionSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.ICondition]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.IConditionSeq: ...
    def __ne__(self, arg0: rti.connextdds.IConditionSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.IConditionSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.ICondition) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.IConditionSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.ICondition) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.ICondition) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.IConditionSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.ICondition) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.ICondition: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.ICondition: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.ICondition) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class DataReader(IDataReader, IEntity, IAnyDataReader):
    class LoanedSample():
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, data: rti.connextdds.UserDataSample, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct LoanedSample with data and info.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> UserDataSample:
            """
            Get the data associated with the sample.

            :type: UserDataSample
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        pass
    class LoanedSamples():
        def __enter__(self) -> rti.connextdds.DataReader.LoanedSamples: 
            """
            Enter a context for the loaned samples, loan returned on context exit.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for the loaned samples, returning the resources.
            """
        def __getitem__(self, arg0: int) -> rti.connextdds.DataReader.LoanedSample: 
            """
            Access a LoanedSample object in an array-like syntax
            """
        def __init__(self) -> None: 
            """
            Create an empty LoanedSamples object.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.DataReader.LoanedSample]: ...
        def __len__(self) -> int: 
            """
            Get the number of samples in the loan.
            """
        def return_loan(self) -> None: 
            """
            Returns the loan to the DataReader.
            """
        @builtins.property
        def length(self) -> int:
            """
            Get the number of samples in the loan.

            :type: int
            """
        pass
    class Selector():
        def __init__(self, datareader: rti.connextdds.DataReader) -> None: 
            """
            Create a Selector for a DataReader to read/take based on selected conditions
            """
        def condition(self, condition: rti.connextdds.IReadCondition) -> rti.connextdds.DataReader.Selector: 
            """
            Select samples based on a ReadCondition.
            """
        def content(self, query: rti.connextdds.Query) -> rti.connextdds.DataReader.Selector: 
            """
            Select samples based on a Query.
            """
        def instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReader.Selector: 
            """
            Select a specific instance to read/take.
            """
        def max_samples(self, max: int) -> rti.connextdds.DataReader.Selector: 
            """
            Limit the number of samples read/taken by the Select.
            """
        def next_instance(self, previous: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReader.Selector: 
            """
            Select the instance after the specified instance to read/take.
            """
        def read(self) -> list: 
            """
            Read copies of all available data and info based on Selector settings.
            """
        def read_data(self) -> list: 
            """
            Read copies of all available valid data based on Selector settings.
            """
        def read_loaned(self) -> rti.connextdds.DataReader.LoanedSamples: 
            """
            (Advanced) Read data as a collection of loaned data in C format and info objects based on Selector settings
            """
        def state(self, state: rti.connextdds.DataState) -> rti.connextdds.DataReader.Selector: 
            """
            Select samples with a specified data state.
            """
        def take(self) -> list: 
            """
            Take copies of all available data and info based on Selector settings.
            """
        def take_data(self) -> list: 
            """
            Take copies of all available valid data based on Selector settings.
            """
        def take_loaned(self) -> rti.connextdds.DataReader.LoanedSamples: 
            """
            (Advanced) Take data as a collection of loaned data in C format and info objects based on Selector settings
            """
        pass
    def __enter__(self) -> rti.connextdds.DataReader: 
        """
        Enter a context for this DataReader, to be cleaned up on exiting context
        """
    def __eq__(self, arg0: rti.connextdds.DataReader) -> bool: 
        """
        Test for equality.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
        """
        Exit the context for this DataReader, cleaning up resources.
        """
    @typing.overload
    def __init__(self, topic: rti.connextdds.Topic) -> None: 
        """
        Create a DataReader in the implicit subscriber with default QoS.
        """
    @typing.overload
    def __init__(self, sub: rti.connextdds.Subscriber, topic: rti.connextdds.Topic) -> None: 
        """
        Create a DataReader in a subscriber with default QoS.
        """
    @typing.overload
    def __init__(self, topic: rti.connextdds.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Create a DataReader in the implicit subscriber with specific QoS and a listener.
        """
    @typing.overload
    def __init__(self, sub: rti.connextdds.Subscriber, topic: rti.connextdds.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Create a DataReader in a subscriber with specific QoS and a listener.
        """
    @typing.overload
    def __init__(self, cft: rti.connextdds.ContentFilteredTopic) -> None: 
        """
        Create a DataReader with a ContentFilteredTopic in the participant's implicit subscriber with default QoS.
        """
    @typing.overload
    def __init__(self, sub: rti.connextdds.Subscriber, cft: rti.connextdds.ContentFilteredTopic) -> None: 
        """
        Create a DataReader with a ContentFilteredTopic in a subscriber with default QoS.
        """
    @typing.overload
    def __init__(self, cft: rti.connextdds.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Create a DataReader with a ContentFilteredTopic in the implicit subscriber with specific QoS.
        """
    @typing.overload
    def __init__(self, sub: rti.connextdds.Subscriber, cft: rti.connextdds.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Create a DataReader with a ContentFilteredTopic in a subscribrer with specific QoS.
        """
    @typing.overload
    def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
        """
        Get a typed DataReader from an AnyDataReader.
        """
    @typing.overload
    def __init__(self, entity: rti.connextdds.IEntity) -> None: 
        """
        Get a typed DataReader from an Entity.
        """
    def __lshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.DataReader: 
        """
        Set the DataReaderQos for this DataReader.
        """
    def __ne__(self, arg0: rti.connextdds.DataReader) -> bool: 
        """
        Test for inequality.
        """
    def __rshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.DataReader: 
        """
        Get the DataReaderQos from this DataReader
        """
    @staticmethod
    @typing.overload
    def _create_disabled(arg0: rti.connextdds.Subscriber, arg1: rti.connextdds.Topic, arg2: rti.connextdds.DataReaderQos) -> rti.connextdds.DataReader: ...
    @staticmethod
    @typing.overload
    def _create_disabled(arg0: rti.connextdds.Subscriber, arg1: rti.connextdds.ContentFilteredTopic, arg2: rti.connextdds.DataReaderQos) -> rti.connextdds.DataReader: ...
    def _set_related_writer_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
    @typing.overload
    def acknowledge_all(self) -> None: 
        """
        Acknowledge all previously accessed samples.
        """
    @typing.overload
    def acknowledge_all(self, arg0: rti.connextdds.AckResponseData) -> None: 
        """
        Acknowledge all previously accessed samples.
        """
    @typing.overload
    def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo) -> None: 
        """
        Acknowledge a single sample.
        """
    @typing.overload
    def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo, ack_response_data: rti.connextdds.AckResponseData) -> None: 
        """
        Acknowledge a single sample with ack response data.
        """
    def close(self) -> None: 
        """
        Close this DataReader.
        """
    @staticmethod
    def find_all_by_topic(subscriber: rti.connextdds.Subscriber, topic_name: str) -> list[rti.connextdds.DataReader]: 
        """
        Retrieve all DataReaders for the given topic name in the subscriber.
        """
    @staticmethod
    @typing.overload
    def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.DataReader]: 
        """
        Find DataReader in DomainParticipant with the DataReader's name, returning the first found.
        """
    @staticmethod
    @typing.overload
    def find_by_name(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.DataReader]: 
        """
        Find DataReader in Subscriber with the DataReader's name, returning the first found.
        """
    @staticmethod
    def find_by_topic(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.DataReader]: 
        """
        Find DataReader in Subscriber with a topic name, returning the first found.
        """
    def is_matched_publication_alive(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
        """
        Check if a matched publication is alive.
        """
    def key_value(self, handle: rti.connextdds.InstanceHandle) -> object: 
        """
        Retrieve the instance key that corresponds to an instance handle.
        """
    @typing.overload
    def lookup_instance(self, key_holder: rti.connextdds.UserDataSample) -> rti.connextdds.InstanceHandle: 
        """
        Retrieve the instance handle that corresponds to an instance key_holder
        """
    @typing.overload
    def lookup_instance(self, key_holder: object) -> rti.connextdds.InstanceHandle: 
        """
        Retrieve the instance handle that corresponds to an instance key_holder
        """
    def matched_publication_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
        """
        Get the PublicationBuiltinTopicData for a publication matched to this DataReader.
        """
    def matched_publication_datareader_protocol_status(self, publication_handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReaderProtocolStatus: 
        """
        Get the DataReaderProtocolStatus for the DataReader based on the matched publication handle.
        """
    def matched_publication_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
        """
        Get the ParticipantBuiltinTopicData for a publication matched to this DataReader.
        """
    def read(self) -> list: 
        """
        Read copies of all available data and info
        """
    def read_data(self) -> list: 
        """
        Read copies of all available valid data
        """
    def read_loaned(self) -> rti.connextdds.DataReader.LoanedSamples: 
        """
        (Advanced) Read all data as a collection of loaned data in C format and info objects
        """
    def select(self) -> rti.connextdds.DataReader.Selector: 
        """
        Get a Selector to perform complex data selections, such as per-instance selection, content, and status filtering.
        """
    def set_listener(self, listener: rti.connextdds.DataReaderListener, event_mask: rti.connextdds.StatusMask) -> None: 
        """
        Set the listener and associated event mask.
        """
    def take(self) -> list: 
        """
        Take copies of all available data and info
        """
    def take_async(self, condition: rti.connextdds.IReadCondition = None) -> object: 
        """
        Takes copies of data, info tuples as data becomes available in an async generator. Must ``import rti.asyncio``.

        Example:

          .. code-block:: python

            async for data, info in reader.take_async():
                if info.valid:
                    print(data)
                else:
                    print(info.state.instance_state)


        A ReadCondition or QueryCondition can be used to filter the data
        """
    def take_data(self) -> list: 
        """
        Take copies of all available valid data
        """
    def take_data_async(self, condition: rti.connextdds.IReadCondition = None) -> object: 
        """
        Takes copies of data as it becomes available in an async generator. Must ``import rti.asyncio``.

        Example:

          .. code-block:: python

            async for data in reader.take_data_async():
              print(data)


        A ReadCondition or QueryCondition can be used to filter the data
        """
    def take_loaned(self) -> rti.connextdds.DataReader.LoanedSamples: 
        """
        (Advanced) Take all data as a collection of loaned data in C format and info objects
        """
    def wait_for_historical_data(self, max_wait: rti.connextdds.Duration) -> None: 
        """
        Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind.
        """
    def wait_for_historical_data_async(self, max_wait: rti.connextdds.Duration) -> object: 
        """
        Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind. This call is awaitable and only for use with asyncio.
        """
    @builtins.property
    def _has_matched_publications_with_related_reader(self) -> int:
        """
        :type: int
        """
    @builtins.property
    def datareader_cache_status(self) -> DataReaderCacheStatus:
        """
        Get the DataReaderCacheStatus for the DataReader.

        :type: DataReaderCacheStatus
        """
    @builtins.property
    def datareader_protocol_status(self) -> DataReaderProtocolStatus:
        """
        Get the DataReaderProtocolStatus for the DataReader.

        :type: DataReaderProtocolStatus
        """
    @builtins.property
    def default_filter_state(self) -> DataState:
        """
        Returns the filter state for the read/take operations.

        :type: DataState
        """
    @default_filter_state.setter
    def default_filter_state(self, arg1: DataState) -> None:
        """
        Returns the filter state for the read/take operations.
        """
    @builtins.property
    def listener(self) -> DataReaderListener:
        """
        Gets or sets the listener with StatusMask.ALL

        :type: DataReaderListener
        """
    @listener.setter
    def listener(self, arg1: DataReaderListener) -> None:
        """
        Gets or sets the listener with StatusMask.ALL
        """
    @builtins.property
    def liveliness_changed_status(self) -> LivelinessChangedStatus:
        """
        Get the LivelinessChangedStatus for this DataReader.

        :type: LivelinessChangedStatus
        """
    @builtins.property
    def matched_publications(self) -> InstanceHandleSeq:
        """
        Get a copy of the list of the currently matched publication handles.

        :type: InstanceHandleSeq
        """
    @builtins.property
    def qos(self) -> DataReaderQos:
        """
        The DataReaderQos for this DataReader.

        This property's getter returns a deep copy.

        :type: DataReaderQos
        """
    @qos.setter
    def qos(self, arg1: DataReaderQos) -> None:
        """
        The DataReaderQos for this DataReader.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def requested_deadline_missed_status(self) -> RequestedDeadlineMissedStatus:
        """
        Get the RequestedDeadlineMissed status for the DataReader

        :type: RequestedDeadlineMissedStatus
        """
    @builtins.property
    def requested_incompatible_qos_status(self) -> RequestedIncompatibleQosStatus:
        """
        Get the RequestedIncompatibleQosStatus for the DataReader.

        :type: RequestedIncompatibleQosStatus
        """
    @builtins.property
    def sample_lost_status(self) -> SampleLostStatus:
        """
        Get the SampleLostStatus for the DataReader.

        :type: SampleLostStatus
        """
    @builtins.property
    def sample_rejected_status(self) -> SampleRejectedStatus:
        """
        Get the SampleRejectedStatus for the DataReader.

        :type: SampleRejectedStatus
        """
    @builtins.property
    def subscriber(self) -> Subscriber:
        """
        Returns the parent Subscriber of the DataReader.

        :type: Subscriber
        """
    @builtins.property
    def subscription_matched_status(self) -> SubscriptionMatchedStatus:
        """
        Get the SubscriptionMatchedStatus for the DataReader.

        :type: SubscriptionMatchedStatus
        """
    @builtins.property
    def topic_description(self) -> TopicDescription:
        """
        Returns the TopicDescription associated with the DataReader.

        :type: TopicDescription
        """
    @builtins.property
    def topic_name(self) -> str:
        """
        Get the topic name associated with this DataReader.

        :type: str
        """
    @builtins.property
    def type_name(self) -> str:
        """
        Get the type name associated with this DataReader.

        :type: str
        """
    __hash__: NoneType
    pass
class ITopicDescription(IEntity):
    @builtins.property
    def name(self) -> str:
        """
        The name of the entity conforming to the ITopicDescription interface.

        :type: str
        """
    @builtins.property
    def participant(self) -> DomainParticipant:
        """
        The parent DomainParticipant.

        :type: DomainParticipant
        """
    @builtins.property
    def type_name(self) -> str:
        """
        The name of the associated type.

        :type: str
        """
    pass
class IEntitySeq():
    def __add__(self, arg0: rti.connextdds.IEntitySeq) -> rti.connextdds.IEntitySeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.IEntity) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.IEntitySeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.IEntitySeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.IEntity: ...
    def __iadd__(self, arg0: rti.connextdds.IEntitySeq) -> rti.connextdds.IEntitySeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.IEntitySeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.IEntitySeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.IEntity]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.IEntitySeq: ...
    def __ne__(self, arg0: rti.connextdds.IEntitySeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.IEntitySeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.IEntity) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.IEntitySeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.IEntity) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.IEntity) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.IEntitySeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.IEntity) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.IEntity: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.IEntity: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.IEntity) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class IReadCondition(ICondition):
    def __enter__(self) -> rti.connextdds.IReadCondition: ...
    def __eq__(self, arg0: rti.connextdds.IReadCondition) -> bool: 
        """
        Test for equality.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    def __ne__(self, arg0: rti.connextdds.IReadCondition) -> bool: 
        """
        Test for inequality.
        """
    def close(self) -> None: 
        """
        Returns the DataReader associated to this condition.
        """
    @builtins.property
    def closed(self) -> bool:
        """
        Returns the DataReader associated to this condition.

        :type: bool
        """
    @builtins.property
    def data_reader(self) -> AnyDataReader:
        """
        Returns the DataReader associated to this condition.

        :type: AnyDataReader
        """
    @builtins.property
    def state_filter(self) -> DataState:
        """
        Returns the DataState of this condition.

        :type: DataState
        """
    __hash__: NoneType
    pass
class ContentFilteredTopic(ITopicDescription, IEntity, IAnyTopic):
    def __eq__(self, arg0: rti.connextdds.ContentFilteredTopic) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, topic: rti.connextdds.Topic, name: str, contentfilter: rti.connextdds.Filter) -> None: 
        """
        Create a ContentFilteredTopic with a name and Filter.
        """
    @typing.overload
    def __init__(self, topic_description: rti.connextdds.ITopicDescription) -> None: 
        """
        Cast a TopicDescription to a ContentFilteredTopic.
        """
    def __ne__(self, arg0: rti.connextdds.ContentFilteredTopic) -> bool: 
        """
        Test for inequality.
        """
    def append_to_expression_parameter(self, index: int, extension: str) -> None: 
        """
        Append the extension to the end of parameter at the provided index, separated by a comma.
        """
    @staticmethod
    def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ContentFilteredTopic]: 
        """
        Look up a ContentFilteredTopic by its name in the DomainParticipant.
        """
    def remove_from_expression_parameter(self, index: int, remove_term: str) -> None: 
        """
        Removes the specified term from the parameter at the provided index.
        """
    def set_filter(self, arg0: rti.connextdds.Filter) -> None: 
        """
        Set the filter.
        """
    @builtins.property
    def filter_expression(self) -> str:
        """
        Get the filter expression

        :type: str
        """
    @builtins.property
    def filter_parameters(self) -> StringSeq:
        """
        Get/set the filter parameters.

        :type: StringSeq
        """
    @filter_parameters.setter
    def filter_parameters(self, arg1: StringSeq) -> None:
        """
        Get/set the filter parameters.
        """
    @builtins.property
    def topic(self) -> Topic:
        """
        Get the underlying Topic.

        :type: Topic
        """
    __hash__: NoneType
    pass
class IgnoredEntityReplacementKind():
    class IgnoredEntityReplacementKind():
        """
        Members:

          NO_REPLACEMENT

          NOT_ALIVE_FIRST
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        NOT_ALIVE_FIRST: rti.connextdds.IgnoredEntityReplacementKind.IgnoredEntityReplacementKind
        NO_REPLACEMENT: rti.connextdds.IgnoredEntityReplacementKind.IgnoredEntityReplacementKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.IgnoredEntityReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.IgnoredEntityReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.IgnoredEntityReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.IgnoredEntityReplacementKind.IgnoredEntityReplacementKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.IgnoredEntityReplacementKind.IgnoredEntityReplacementKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.IgnoredEntityReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.IgnoredEntityReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.IgnoredEntityReplacementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> IgnoredEntityReplacementKind.IgnoredEntityReplacementKind:
        """
        Retrieves the actual enumerated value.

        :type: IgnoredEntityReplacementKind.IgnoredEntityReplacementKind
        """
    NOT_ALIVE_FIRST: rti.connextdds.IgnoredEntityReplacementKind.IgnoredEntityReplacementKind
    NO_REPLACEMENT: rti.connextdds.IgnoredEntityReplacementKind.IgnoredEntityReplacementKind
    __hash__: NoneType
    pass
class IllegalOperationError(Exception, Exception, BaseException):
    pass
class ImmutablePolicyError(Exception, Exception, BaseException):
    pass
class InconsistentPolicyError(Exception, Exception, BaseException):
    pass
class InconsistentTopicStatus():
    @builtins.property
    def total_count(self) -> int:
        """
        Get the total count of pairs of DataReaders/DataWriters whose Topic names match but data types are inconsistent according to  the current type consistency enforcement policy.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta number of inconsistent pairs of DataReaders/DataWriters for the Topic that have been discovered since the last time this status was read.

        :type: int
        """
    pass
class InstanceHandle():
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
        """
        Test for equality.
        """
    def __hash__(self) -> int: ...
    def __init__(self) -> None: 
        """
        Create a nil InstanceHandle
        """
    def __ne__(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
        """
        Test for inequality.
        """
    def __nonzero__(self) -> bool: ...
    def __str__(self) -> str: ...
    @staticmethod
    def nil() -> rti.connextdds.InstanceHandle: 
        """
        Create a nil InstanceHandle.
        """
    @builtins.property
    def is_nil(self) -> bool:
        """
        Nil status of InstanceStatus

        :type: bool
        """
    pass
class InstanceHandleSeq():
    def __add__(self, arg0: rti.connextdds.InstanceHandleSeq) -> rti.connextdds.InstanceHandleSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.InstanceHandle) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.InstanceHandleSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.InstanceHandleSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.InstanceHandle: ...
    def __iadd__(self, arg0: rti.connextdds.InstanceHandleSeq) -> rti.connextdds.InstanceHandleSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.InstanceHandleSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.InstanceHandleSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.InstanceHandle]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.InstanceHandleSeq: ...
    def __ne__(self, arg0: rti.connextdds.InstanceHandleSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.InstanceHandleSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.InstanceHandle) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.InstanceHandleSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.InstanceHandle) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.InstanceHandle) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.InstanceHandleSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.InstanceHandle) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.InstanceHandle: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.InstanceHandle: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.InstanceHandle) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class InstanceState():
    def __and__(self, arg0: rti.connextdds.InstanceState) -> rti.connextdds.InstanceState: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> rti.connextdds.InstanceState: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.InstanceState) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.InstanceState) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.InstanceState) -> rti.connextdds.InstanceState: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.InstanceState: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an InstanceState with no bits set.
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.InstanceState) -> rti.connextdds.InstanceState: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.InstanceState: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.InstanceState) -> rti.connextdds.InstanceState: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.InstanceState: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.InstanceState) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.InstanceState) -> rti.connextdds.InstanceState: 
        """
        Bitwise logical OR of masks.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.InstanceState: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: ...
    def __xor__(self, arg0: rti.connextdds.InstanceState) -> rti.connextdds.InstanceState: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.InstanceState: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.InstanceState: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.InstanceState: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.InstanceState: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.InstanceState: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.InstanceState: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ALIVE: rti.connextdds.InstanceState
    ANY: rti.connextdds.InstanceState
    NOT_ALIVE_DISPOSED: rti.connextdds.InstanceState
    NOT_ALIVE_MASK: rti.connextdds.InstanceState
    NOT_ALIVE_NO_WRITERS: rti.connextdds.InstanceState
    __hash__: NoneType
    pass
class InstanceStateConsistencyKind():
    """
    Members:

      NONE : Instance states on the DataReader are not guaranteed to be correct after liveliness is regained after a disconnect

      RECOVER_STATE : Instance states on the DataReader are guaranteed to be correct after liveliness is regained after a disconnect.
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @builtins.property
    def name(self) -> str:
        """
        :type: str
        """
    @builtins.property
    def value(self) -> int:
        """
        :type: int
        """
    NONE: rti.connextdds.InstanceStateConsistencyKind
    RECOVER_STATE: rti.connextdds.InstanceStateConsistencyKind
    __members__: dict
    pass
class Int16Seq():
    def __add__(self, arg0: rti.connextdds.Int16Seq) -> rti.connextdds.Int16Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: int) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Int16Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Int16Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> int: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Int16Seq) -> rti.connextdds.Int16Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Int16Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Int16Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Int16Seq: ...
    def __ne__(self, arg0: rti.connextdds.Int16Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Int16Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Int16Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: int) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: int) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Int16Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: int) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> int: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> int: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: int) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Int16Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Int16Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Int16Type
        """
    def __ne__(self, arg0: rti.connextdds.Int16Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class Int32Seq():
    def __add__(self, arg0: rti.connextdds.Int32Seq) -> rti.connextdds.Int32Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: int) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Int32Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Int32Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> int: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Int32Seq) -> rti.connextdds.Int32Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Int32Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Int32Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Int32Seq: ...
    def __ne__(self, arg0: rti.connextdds.Int32Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Int32Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Int32Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: int) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: int) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Int32Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: int) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> int: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> int: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: int) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Int32Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Int32Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Int32Type
        """
    def __ne__(self, arg0: rti.connextdds.Int32Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class Int32Vector():
    """
    A DDS standard container with functionality similar to a C++ vector.
    """
    def __eq__(self, arg0: rti.connextdds.Int32Vector) -> bool: 
        """
        Compare Int32Vectors for equality.
        """
    def __getitem__(self, arg0: int) -> int: 
        """
        Get the value at the specified index.
        """
    @typing.overload
    def __init__(self, buffer: Buffer) -> None: 
        """
        Create a Int32Vector from another Python buffer.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty Int32Vector
        """
    @typing.overload
    def __init__(self, size: int) -> None: 
        """
        Create a Int32Vector with a preallocated size.
        """
    @typing.overload
    def __init__(self, vector: rti.connextdds.Int32Vector) -> None: 
        """
        Create a copy from another Int32Vector.
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, list: rti.connextdds.Int32Seq) -> None: 
        """
        Create a Int32Vector from a list of values.
        """
    def __iter__(self) -> typing.Iterator[int]: 
        """
        Iterate over the contents of the vector.
        """
    def __len__(self) -> int: 
        """
        Get the length of the Int32Vector.
        """
    def __ne__(self, arg0: rti.connextdds.Int32Vector) -> bool: 
        """
        Compare Int32Vectors for inequality.
        """
    def __setitem__(self, arg0: int, arg1: int) -> None: 
        """
        Set the value at the specified index.
        """
    def clear(self) -> None: 
        """
        Resize Int32Vector to 0.
        """
    def resize(self, size: int) -> None: 
        """
        Resize Int32Vector.
        """
    __hash__: NoneType
    pass
class Int64Seq():
    def __add__(self, arg0: rti.connextdds.Int64Seq) -> rti.connextdds.Int64Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: int) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Int64Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Int64Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> int: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Int64Seq) -> rti.connextdds.Int64Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Int64Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Int64Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Int64Seq: ...
    def __ne__(self, arg0: rti.connextdds.Int64Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Int64Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Int64Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: int) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: int) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Int64Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: int) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> int: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> int: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: int) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Int64Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Int64Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Int64Type
        """
    def __ne__(self, arg0: rti.connextdds.Int64Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class Int8Seq():
    def __add__(self, arg0: rti.connextdds.Int8Seq) -> rti.connextdds.Int8Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: int) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Int8Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Int8Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> int: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Int8Seq) -> rti.connextdds.Int8Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Int8Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Int8Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Int8Seq: ...
    def __ne__(self, arg0: rti.connextdds.Int8Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the string representation of this list. Values are printed as integers.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Int8Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Int8Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: int) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: int) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Int8Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: int) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> int: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> int: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: int) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Int8Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Int8Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Int8Type
        """
    def __ne__(self, arg0: rti.connextdds.Int8Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class InvalidArgumentError(Exception, Exception, BaseException):
    pass
class InvalidDowncastError(Exception, Exception, BaseException):
    pass
class InvalidLocalIdentityAdvanceNoticeStatus():
    @builtins.property
    def expiration_time(self) -> Time:
        """
        Get the expiration time of the status

        :type: Time
        """
    pass
class ItemsView():
    def __iter__(self) -> typing.Iterator: ...
    def __len__(self) -> int: ...
    pass
class KeysView():
    def __contains__(self, arg0: object) -> bool: ...
    def __iter__(self) -> typing.Iterator: ...
    def __len__(self) -> int: ...
    pass
class LatencyBudget():
    def __eq__(self, arg0: rti.connextdds.LatencyBudget) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a latency budget with zero duration.
        """
    @typing.overload
    def __init__(self, duration: rti.connextdds.Duration) -> None: 
        """
        Creates an instance with the specified duration.
        """
    def __ne__(self, arg0: rti.connextdds.LatencyBudget) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def duration(self) -> Duration:
        """
        The duration of the maximum acceptable delay.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @duration.setter
    def duration(self, arg1: Duration) -> None:
        """
        The duration of the maximum acceptable delay.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class Lifespan():
    def __eq__(self, arg0: rti.connextdds.Lifespan) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy with an infinite lifespan.
        """
    @typing.overload
    def __init__(self, duration: rti.connextdds.Duration) -> None: 
        """
        Creates a policy with the specified lifespan duration.
        """
    def __ne__(self, arg0: rti.connextdds.Lifespan) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def duration(self) -> Duration:
        """
        Sets the maximum duration for which the data is valid.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @duration.setter
    def duration(self, arg1: Duration) -> None:
        """
        Sets the maximum duration for which the data is valid.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class Liveliness():
    def __eq__(self, arg0: rti.connextdds.Liveliness) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an automatic liveliness policy with infinite lease duration.
        """
    @typing.overload
    def __init__(self, kind: rti.connextdds.LivelinessKind, duration: rti.connextdds.Duration) -> None: 
        """
        Creates an instance with the specified liveliness kind and lease duration.
        """
    def __ne__(self, arg0: rti.connextdds.Liveliness) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    def manual_by_participant(lease: rti.connextdds.Duration = Duration.infinite) -> rti.connextdds.Liveliness: 
        """
        Creates a Liveliness instance with LivelinessKind.MANUAL_BY_PARTICIPANT.
        """
    @staticmethod
    def manual_by_topic(lease: rti.connextdds.Duration = Duration.infinite) -> rti.connextdds.Liveliness: 
        """
        Creates a Liveliness instance with LivelinessKind.MANUAL_BY_TOPIC.
        """
    @builtins.property
    def assertions_per_lease_duration(self) -> int:
        """
        The number of assertions to send during the lease duration.

        :type: int
        """
    @assertions_per_lease_duration.setter
    def assertions_per_lease_duration(self, arg1: int) -> None:
        """
        The number of assertions to send during the lease duration.
        """
    @builtins.property
    def kind(self) -> LivelinessKind:
        """
        The liveliness kind.

        :type: LivelinessKind
        """
    @kind.setter
    def kind(self, arg1: LivelinessKind) -> None:
        """
        The liveliness kind.
        """
    @builtins.property
    def lease_duration(self) -> Duration:
        """
        The duration within which a Entity must be asserted or else it is considered not alive.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @lease_duration.setter
    def lease_duration(self, arg1: Duration) -> None:
        """
        The duration within which a Entity must be asserted or else it is considered not alive.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    automatic: rti.connextdds.Liveliness
    pass
class LivelinessChangedStatus():
    @builtins.property
    def alive_count(self) -> int:
        """
        The number of currently alive DataWriters that write to the Topic of the DataReader.

        :type: int
        """
    @builtins.property
    def alive_count_change(self) -> int:
        """
        The delta in the alive count since the last time the listener fired or the status was read.

        :type: int
        """
    @builtins.property
    def last_publication_handle(self) -> InstanceHandle:
        """
        The instance handle of the DataWriter with the most recent change in liveliness.

        :type: InstanceHandle
        """
    @builtins.property
    def not_alive_count(self) -> int:
        """
        The number of currently NOT_ALIVE DataWriters that write to the Topic of the DataReader.

        :type: int
        """
    @builtins.property
    def not_alive_count_change(self) -> int:
        """
        The delta in the NOT_ALIVE count since the last time the listener fired or the status was read.

        :type: int
        """
    pass
class LivelinessKind():
    class LivelinessKind():
        """
        Members:

          AUTOMATIC : [default] The infrastructure will automatically signal liveliness for the DataWriter (s) at least as often as required by the DataWriter (S) lease_duration.

        A DataWriter with this setting does not need to take any specific action in order to be considered 'alive.' The DataWriter is only 'not alive' when the participant to which it belongs terminates (gracefully or not), or when there is a network problem that prevents the current participant from contacting that remote participant.

          MANUAL_BY_PARTICIPANT : RTI Connext will assume that as long as at least one DataWriter belonging to the DomainParticipant (or the DomainParticipant itself) has asserted its liveliness, then the other DataWriters belonging to that same DomainParticipant are also alive.

        The user application takes responsibility to signal liveliness to RTI Connext either by calling DomainParticipant.assert_liveliness, or by calling DataWriter.assert_liveliness, or DataWriter.write() on any DataWriter belonging to the DomainParticipant.

          MANUAL_BY_TOPIC : RTI Connext will only assume liveliness of the DataWriter if the application has asserted liveliness of that DataWriter itself.

        The user application takes responsibility to signal liveliness to RTI Connext using the DataWriter.assert_liveliness method, or by writing some data.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        AUTOMATIC: rti.connextdds.LivelinessKind.LivelinessKind
        MANUAL_BY_PARTICIPANT: rti.connextdds.LivelinessKind.LivelinessKind
        MANUAL_BY_TOPIC: rti.connextdds.LivelinessKind.LivelinessKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.LivelinessKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.LivelinessKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.LivelinessKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.LivelinessKind.LivelinessKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.LivelinessKind.LivelinessKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.LivelinessKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.LivelinessKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.LivelinessKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> LivelinessKind.LivelinessKind:
        """
        Retrieves the actual enumerated value.

        :type: LivelinessKind.LivelinessKind
        """
    AUTOMATIC: rti.connextdds.LivelinessKind.LivelinessKind
    MANUAL_BY_PARTICIPANT: rti.connextdds.LivelinessKind.LivelinessKind
    MANUAL_BY_TOPIC: rti.connextdds.LivelinessKind.LivelinessKind
    __hash__: NoneType
    pass
class LivelinessLostStatus():
    @builtins.property
    def total_count(self) -> int:
        """
        Total count of times that a previously alive DataWriter became not alive due to a failure to assert its liveliness signal within the agreed lease duration.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta number of times liveliness has been lost since the last time the listener callback fired or this status was checked.

        :type: int
        """
    pass
class LoanedDynamicData():
    def __enter__(self) -> rti.connextdds.LoanedDynamicData: 
        """
        Enter a context for the loaned field, loan returned on context exit.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
        """
        Exit the context for the loaned field, returning the resources.
        """
    def return_loan(self) -> None: 
        """
        Explicitly return a dynamic data loan.
        """
    @builtins.property
    def data(self) -> DynamicData:
        """
        Obtains the DynamicData object representing a member of a DynamicData object.

        :type: DynamicData
        """
    pass
class Locator():
    """
    Type used to represent the addressing information needed to send a message to an RTPS Endpoint using one of the supported transports.
    """
    def __eq__(self, arg0: rti.connextdds.Locator) -> bool: 
        """
        Compare Locators for equality.
        """
    def __init__(self, kind: rti.connextdds.LocatorKind.LocatorKind, port: int, address: rti.connextdds.Uint8Seq) -> None: 
        """
        Construct a Locator with the provided kind, port, and address.
        """
    def __ne__(self, arg0: rti.connextdds.Locator) -> bool: 
        """
        Compare Locators for inequality.
        """
    @builtins.property
    def address(self) -> Uint8Seq:
        """
        Get/set the address for this Locator.

        :type: Uint8Seq
        """
    @address.setter
    def address(self, arg1: Uint8Seq) -> None:
        """
        Get/set the address for this Locator.
        """
    @builtins.property
    def kind(self) -> LocatorKind.LocatorKind:
        """
        Get/set the kind for this Locator.

        :type: LocatorKind.LocatorKind
        """
    @kind.setter
    def kind(self, arg1: LocatorKind.LocatorKind) -> None:
        """
        Get/set the kind for this Locator.
        """
    @builtins.property
    def port(self) -> int:
        """
        Get/set the port for this Locator.

        :type: int
        """
    @port.setter
    def port(self, arg1: int) -> None:
        """
        Get/set the port for this Locator.
        """
    __hash__: NoneType
    invalid: rti.connextdds.Locator
    pass
class LocatorFilter():
    def __eq__(self, arg0: rti.connextdds.LocatorFilter) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, locator_filters: rti.connextdds.LocatorFilterElementSeq, filter_name: str = Filter.stringmatch_filter_name) -> None: 
        """
        Creates an instance with a sequence of filters and a filter name.
        """
    def __ne__(self, arg0: rti.connextdds.LocatorFilter) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def filter_name(self) -> str:
        """
        The filter name.

        :type: str
        """
    @filter_name.setter
    def filter_name(self, arg1: str) -> None:
        """
        The filter name.
        """
    @builtins.property
    def locator_filters(self) -> LocatorFilterElementSeq:
        """
        The locator filters.

        This property's getter returns a deep copy.

        :type: LocatorFilterElementSeq
        """
    @locator_filters.setter
    def locator_filters(self, arg1: LocatorFilterElementSeq) -> None:
        """
        The locator filters.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class LocatorFilterElement():
    def __eq__(self, arg0: rti.connextdds.LocatorFilterElement) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, arg0: str, arg1: rti.connextdds.LocatorSeq) -> None: 
        """
        Creates an instance with the provided filter_expression and locators.
        """
    def __ne__(self, arg0: rti.connextdds.LocatorFilterElement) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def filter_expression(self) -> str:
        """
        The filter expression.

        :type: str
        """
    @filter_expression.setter
    def filter_expression(self, arg1: str) -> None:
        """
        The filter expression.
        """
    @builtins.property
    def locators(self) -> LocatorSeq:
        """
        The locators associated with this filter.

        This property's getter returns a deep copy.

        :type: LocatorSeq
        """
    @locators.setter
    def locators(self, arg1: LocatorSeq) -> None:
        """
        The locators associated with this filter.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class LocatorFilterElementSeq():
    def __add__(self, arg0: rti.connextdds.LocatorFilterElementSeq) -> rti.connextdds.LocatorFilterElementSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.LocatorFilterElement) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.LocatorFilterElementSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.LocatorFilterElementSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.LocatorFilterElement: ...
    def __iadd__(self, arg0: rti.connextdds.LocatorFilterElementSeq) -> rti.connextdds.LocatorFilterElementSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.LocatorFilterElementSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.LocatorFilterElementSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.LocatorFilterElement]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.LocatorFilterElementSeq: ...
    def __ne__(self, arg0: rti.connextdds.LocatorFilterElementSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.LocatorFilterElementSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.LocatorFilterElement) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.LocatorFilterElementSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.LocatorFilterElement) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.LocatorFilterElement) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.LocatorFilterElementSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.LocatorFilterElement) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.LocatorFilterElement: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.LocatorFilterElement: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.LocatorFilterElement) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class LocatorKind():
    class LocatorKind():
        """
        Members:

          INVALID : An invalid locator

          ANY : A special value for any kind of locator.

          UDPv4 : A locator for a UDPv4 address.

          SHMEM : A locator for an address accessed via shared memory.

          SHMEM_510 : A locator for an address accessed via shared memory with backwards compatibility for Connext 5.1.0 or earlier.

          INTRA : A locator for the Connext INTRA transport.

          UDPv6 : A locator for a UDPv6 address.

          UDPv6_510 : A locator for a UDPv6 address with backwards compatibility for Connext 5.1.0 or earlier.

          TCPV4_LAN : A locator for an address that communicates using TCP on a LAN.

          TCPV4_WAN : A locator for an address that communicates using TCP over a WAN.

          TLSV4_LAN : A locator for an address that communicates using TLS over a LAN.

          TLSV4_WAN : A locator for an address that communicates using TLS over a WAN.

          RESERVED : Reserved locator kind.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        ANY: rti.connextdds.LocatorKind.LocatorKind
        INTRA: rti.connextdds.LocatorKind.LocatorKind
        INVALID: rti.connextdds.LocatorKind.LocatorKind
        RESERVED: rti.connextdds.LocatorKind.LocatorKind
        SHMEM: rti.connextdds.LocatorKind.LocatorKind
        SHMEM_510: rti.connextdds.LocatorKind.LocatorKind
        TCPV4_LAN: rti.connextdds.LocatorKind.LocatorKind
        TCPV4_WAN: rti.connextdds.LocatorKind.LocatorKind
        TLSV4_LAN: rti.connextdds.LocatorKind.LocatorKind
        TLSV4_WAN: rti.connextdds.LocatorKind.LocatorKind
        UDPv4: rti.connextdds.LocatorKind.LocatorKind
        UDPv6: rti.connextdds.LocatorKind.LocatorKind
        UDPv6_510: rti.connextdds.LocatorKind.LocatorKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.LocatorKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.LocatorKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.LocatorKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.LocatorKind.LocatorKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.LocatorKind.LocatorKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.LocatorKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.LocatorKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.LocatorKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> LocatorKind.LocatorKind:
        """
        Retrieves the actual enumerated value.

        :type: LocatorKind.LocatorKind
        """
    ANY: rti.connextdds.LocatorKind.LocatorKind
    INTRA: rti.connextdds.LocatorKind.LocatorKind
    INVALID: rti.connextdds.LocatorKind.LocatorKind
    RESERVED: rti.connextdds.LocatorKind.LocatorKind
    SHMEM: rti.connextdds.LocatorKind.LocatorKind
    SHMEM_510: rti.connextdds.LocatorKind.LocatorKind
    TCPV4_LAN: rti.connextdds.LocatorKind.LocatorKind
    TCPV4_WAN: rti.connextdds.LocatorKind.LocatorKind
    TLSV4_LAN: rti.connextdds.LocatorKind.LocatorKind
    TLSV4_WAN: rti.connextdds.LocatorKind.LocatorKind
    UDPv4: rti.connextdds.LocatorKind.LocatorKind
    UDPv6: rti.connextdds.LocatorKind.LocatorKind
    UDPv6_510: rti.connextdds.LocatorKind.LocatorKind
    __hash__: NoneType
    pass
class LocatorSeq():
    def __add__(self, arg0: rti.connextdds.LocatorSeq) -> rti.connextdds.LocatorSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.Locator) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.LocatorSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.LocatorSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Locator: ...
    def __iadd__(self, arg0: rti.connextdds.LocatorSeq) -> rti.connextdds.LocatorSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.LocatorSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.LocatorSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.Locator]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.LocatorSeq: ...
    def __ne__(self, arg0: rti.connextdds.LocatorSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.LocatorSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Locator) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.LocatorSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.Locator) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.Locator) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.LocatorSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.Locator) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.Locator: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.Locator: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.Locator) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class LocatorVector():
    """
    A DDS standard container with functionality similar to a C++ vector.
    """
    def __eq__(self, arg0: rti.connextdds.LocatorVector) -> bool: 
        """
        Compare LocatorVectors for equality.
        """
    def __getitem__(self, arg0: int) -> rti.connextdds.Locator: 
        """
        Get the value at the specified index.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty LocatorVector
        """
    @typing.overload
    def __init__(self, size: int) -> None: 
        """
        Create a LocatorVector with a preallocated size.
        """
    @typing.overload
    def __init__(self, vector: rti.connextdds.LocatorVector) -> None: 
        """
        Create a copy from another LocatorVector.
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, list: rti.connextdds.LocatorSeq) -> None: 
        """
        Create a LocatorVector from a list of values.
        """
    def __iter__(self) -> typing.Iterator[rti.connextdds.Locator]: 
        """
        Iterate over the contents of the vector.
        """
    def __len__(self) -> int: 
        """
        Get the length of the LocatorVector.
        """
    def __ne__(self, arg0: rti.connextdds.LocatorVector) -> bool: 
        """
        Compare LocatorVectors for inequality.
        """
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Locator) -> None: 
        """
        Set the value at the specified index.
        """
    def clear(self) -> None: 
        """
        Resize LocatorVector to 0.
        """
    def resize(self, size: int) -> None: 
        """
        Resize LocatorVector.
        """
    __hash__: NoneType
    pass
class LogCategory():
    class LogCategory():
        """
        Members:

          platform : Log messages pertaining to the underlying platform (hardware and OS) on which RTI Connext is running are in this category.

          communication : Log messages pertaining to data serialization and deserialization and network traffic are in this category.

          database : Log messages pertaining to the internal database in which RTI Connext objects are stored are in this category.

          entities : Log messages pertaining to local and remote entities and to the discovery process are in this category.

          api : Log messages pertaining to the API layer of RTI Connext (such as method argument validation) are in this category.

          discovery : Log messages pertaining to discovery are in this category.

          security : Log messages pertaining to Security Plugins are in this category.

          user : Log messages that are generated by the user via the public log APIs are in this category.

          all_categories : Log messages pertaining to all category of RTI Connext.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        __members__: dict
        all_categories: rti.connextdds.LogCategory.LogCategory
        api: rti.connextdds.LogCategory.LogCategory
        communication: rti.connextdds.LogCategory.LogCategory
        database: rti.connextdds.LogCategory.LogCategory
        discovery: rti.connextdds.LogCategory.LogCategory
        entities: rti.connextdds.LogCategory.LogCategory
        platform: rti.connextdds.LogCategory.LogCategory
        security: rti.connextdds.LogCategory.LogCategory
        user: rti.connextdds.LogCategory.LogCategory
        pass
    def __eq__(self, arg0: rti.connextdds.LogCategory) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.LogCategory) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.LogCategory) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.LogCategory.LogCategory) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.LogCategory.LogCategory: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.LogCategory) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.LogCategory) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.LogCategory) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> LogCategory.LogCategory:
        """
        Retrieves the actual enumerated value.

        :type: LogCategory.LogCategory
        """
    __hash__: NoneType
    all_categories: rti.connextdds.LogCategory.LogCategory
    api: rti.connextdds.LogCategory.LogCategory
    communication: rti.connextdds.LogCategory.LogCategory
    database: rti.connextdds.LogCategory.LogCategory
    discovery: rti.connextdds.LogCategory.LogCategory
    entities: rti.connextdds.LogCategory.LogCategory
    platform: rti.connextdds.LogCategory.LogCategory
    security: rti.connextdds.LogCategory.LogCategory
    user: rti.connextdds.LogCategory.LogCategory
    pass
class Logger():
    def _log_dds_warning(self, arg0: str) -> None: ...
    def alert(self, msg: str) -> None: 
        """
        Logs an alert message in the user category.
        """
    def critical(self, msg: str) -> None: 
        """
        Logs a critical message in the user category.
        """
    def debug(self, msg: str) -> None: 
        """
        Logs a debug message in the user category.
        """
    def emergency(self, msg: str) -> None: 
        """
        Logs an emergency message in the user category.
        """
    def error(self, msg: str) -> None: 
        """
        Logs an error message in the user category.
        """
    def informational(self, msg: str) -> None: 
        """
        Logs an informational message in the user category.
        """
    def notice(self, msg: str) -> None: 
        """
        Logs a notice message in the user category.
        """
    def output_file(self, file_name: str) -> None: 
        """
        Set the name of the file to which the logged output is redirected.
        """
    def output_file_set(self, file_prefix: str, file_suffix: str, max_bytes: int, max_files: int = LENGTH_UNLIMITED) -> None: 
        """
        Set the name of the file to which the logged output is redirected.
        """
    def output_handler(self, callable_handler: object) -> None: 
        """
        Assigns a callable to which log messages (strings) are directed
        """
    def reset_output_handler(self) -> None: 
        """
        Removes the current log handler and sends logging back to the standard output.
        """
    @typing.overload
    def verbosity_by_category(self, category: rti.connextdds.LogCategory) -> rti.connextdds.Verbosity: 
        """
        Get the verbosity at which RTI Connext is currently logging diagnostic information in the given category.
        """
    @typing.overload
    def verbosity_by_category(self, category: rti.connextdds.LogCategory, verbosity: rti.connextdds.Verbosity) -> None: 
        """
        Set the verbosity at which RTI Connext will log diagnostic information in the given category.
        """
    def warning(self, msg: str) -> None: 
        """
        Logs a warning message in the user category.
        """
    @builtins.property
    def print_format(self) -> PrintFormat:
        """
        The message format that RTI Connext will use to log diagnostic information.

        :type: PrintFormat
        """
    @print_format.setter
    def print_format(self, arg1: PrintFormat) -> None:
        """
        The message format that RTI Connext will use to log diagnostic information.
        """
    @builtins.property
    def verbosity(self) -> Verbosity:
        """
        The verbosity at which RTI Connext is currently logging diagnostic information.

        :type: Verbosity
        """
    @verbosity.setter
    def verbosity(self, arg1: Verbosity) -> None:
        """
        The verbosity at which RTI Connext is currently logging diagnostic information.
        """
    instance: rti.connextdds.Logger
    pass
class LongDouble():
    def __eq__(self, arg0: rti.connextdds.LongDouble) -> bool: 
        """
        Test for equality
        """
    def __getitem__(self, arg0: int) -> int: 
        """
        Get a byte from the LongDouble buffer.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a LongDouble with value 0.
        """
    @typing.overload
    def __init__(self, byte_sequence: rti.connextdds.Uint8Seq) -> None: 
        """
        Creates a LongDouble from a sequence of bytes.
        """
    def __ne__(self, arg0: rti.connextdds.LongDouble) -> bool: 
        """
        Test for inequality
        """
    def __setitem__(self, arg0: int, arg1: int) -> None: 
        """
        Set a byte in the LongDouble buffer.
        """
    def __str__(self) -> str: ...
    __hash__: NoneType
    pass
LongDoubleType = Float128Type
LongLongSeq = Int64Seq
LongLongType = Int64Type
LongSeq = Int32Seq
LongType = Int32Type
class Member():
    def __eq__(self, arg0: rti.connextdds.Member) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, name: str, data_type: rti.connextdds.DynamicType) -> None: ...
    @typing.overload
    def __init__(self, name: str, data_type: rti.connextdds.DynamicType, id: int = -1, is_key: bool = False, is_optional: bool = False, is_pointer: bool = False) -> None: 
        """
        Create a Member with specified properties
        """
    def __ne__(self, arg0: rti.connextdds.Member) -> bool: 
        """
        Test for inequality.
        """
    def set_name(self, arg0: str) -> rti.connextdds.Member: 
        """
        Set the member name.
        """
    @builtins.property
    def bitset(self) -> bool:
        """
        Checks if member is a bitset

        :type: bool
        """
    @builtins.property
    def id(self) -> int:
        """
        The member ID.

        :type: int
        """
    @id.setter
    def id(self, arg1: int) -> None:
        """
        The member ID.
        """
    @builtins.property
    def is_key(self) -> bool:
        """
        Member key field status.

        :type: bool
        """
    @is_key.setter
    def is_key(self, arg1: bool) -> None:
        """
        Member key field status.
        """
    @builtins.property
    def name(self) -> str:
        """
        The member name.

        :type: str
        """
    @name.setter
    def name(self, arg1: str) -> None:
        """
        The member name.
        """
    @builtins.property
    def optional(self) -> bool:
        """
        Member optional status

        :type: bool
        """
    @optional.setter
    def optional(self, arg1: bool) -> None:
        """
        Member optional status
        """
    @builtins.property
    def pointer(self) -> bool:
        """
        Member pointer status

        :type: bool
        """
    @pointer.setter
    def pointer(self, arg1: bool) -> None:
        """
        Member pointer status
        """
    @builtins.property
    def type(self) -> object:
        """
        Gets the member type.

        :type: object
        """
    INVALID_ID: int
    __hash__: NoneType
    pass
class MemberSeq():
    def __add__(self, arg0: rti.connextdds.MemberSeq) -> rti.connextdds.MemberSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.Member) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.MemberSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.MemberSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Member: ...
    def __iadd__(self, arg0: rti.connextdds.MemberSeq) -> rti.connextdds.MemberSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.MemberSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.MemberSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.Member]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.MemberSeq: ...
    def __ne__(self, arg0: rti.connextdds.MemberSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.MemberSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Member) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.MemberSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.Member) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.Member) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.MemberSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.Member) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.Member: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.Member: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.Member) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class Monitoring():
    def __eq__(self, arg0: rti.connextdds.Monitoring) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates the default policy (monitoring is disabled).
        """
    def __ne__(self, arg0: rti.connextdds.Monitoring) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def application_name(self) -> typing.Optional[str]:
        """
        The name of the resource that represents this Connext application.

        :type: typing.Optional[str]
        """
    @application_name.setter
    def application_name(self, arg1: typing.Optional[str]) -> None:
        """
        The name of the resource that represents this Connext application.
        """
    @builtins.property
    def distribution_settings(self) -> MonitoringDistributionSettings:
        """
        Configures the distribution of telemetry data.

        :type: MonitoringDistributionSettings
        """
    @distribution_settings.setter
    def distribution_settings(self, arg1: MonitoringDistributionSettings) -> None:
        """
        Configures the distribution of telemetry data.
        """
    @builtins.property
    def enable(self) -> bool:
        """
        Enables the collection and distribution of telemetry data for a Connext application using the Monitoring Library 2.0.

        :type: bool
        """
    @enable.setter
    def enable(self, arg1: bool) -> None:
        """
        Enables the collection and distribution of telemetry data for a Connext application using the Monitoring Library 2.0.
        """
    @builtins.property
    def telemetry_data(self) -> MonitoringTelemetryData:
        """
        Configures the collection of telemetry data.

        :type: MonitoringTelemetryData
        """
    @telemetry_data.setter
    def telemetry_data(self, arg1: MonitoringTelemetryData) -> None:
        """
        Configures the collection of telemetry data.
        """
    __hash__: NoneType
    disabled: rti.connextdds.Monitoring
    enabled: rti.connextdds.Monitoring
    pass
class MonitoringDedicatedParticipantSettings():
    def __eq__(self, arg0: rti.connextdds.MonitoringDedicatedParticipantSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.MonitoringDedicatedParticipantSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def collector_initial_peers(self) -> tuple:
        """
        Determines the initial list of peers that the discovery process will contact to send announcements about the presence of the dedicated_participant.

        :type: tuple
        """
    @collector_initial_peers.setter
    def collector_initial_peers(self, arg1: StringSeq) -> None:
        """
        Determines the initial list of peers that the discovery process will contact to send announcements about the presence of the dedicated_participant.
        """
    @builtins.property
    def domain_id(self) -> int:
        """
        The domain ID used in the creation of the Monitoring Library 2.0 DomainParticipant.

        :type: int
        """
    @domain_id.setter
    def domain_id(self, arg1: int) -> None:
        """
        The domain ID used in the creation of the Monitoring Library 2.0 DomainParticipant.
        """
    @builtins.property
    def enable(self) -> bool:
        """
        Enables the use of a dedicated DomainParticipant to distribute the Connext application telemetry data.

        :type: bool
        """
    @enable.setter
    def enable(self, arg1: bool) -> None:
        """
        Enables the use of a dedicated DomainParticipant to distribute the Connext application telemetry data.
        """
    @builtins.property
    def participant_qos_profile_name(self) -> typing.Optional[str]:
        """
        The fully qualified name of the profile used to configure the DomainParticipant that will be used to distribute telemetry data.

        :type: typing.Optional[str]
        """
    @participant_qos_profile_name.setter
    def participant_qos_profile_name(self, arg1: typing.Optional[str]) -> None:
        """
        The fully qualified name of the profile used to configure the DomainParticipant that will be used to distribute telemetry data.
        """
    __hash__: NoneType
    pass
class MonitoringDistributionSettings():
    def __eq__(self, arg0: rti.connextdds.MonitoringDistributionSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.MonitoringDistributionSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def dedicated_participant(self) -> MonitoringDedicatedParticipantSettings:
        """
        Configures the use of a dedicated DomainParticipant to distribute the Connext application telemetry data.

        :type: MonitoringDedicatedParticipantSettings
        """
    @dedicated_participant.setter
    def dedicated_participant(self, arg1: MonitoringDedicatedParticipantSettings) -> None:
        """
        Configures the use of a dedicated DomainParticipant to distribute the Connext application telemetry data.
        """
    @builtins.property
    def event_settings(self) -> MonitoringEventDistributionSettings:
        """
        Configures the distribution of event metrics.

        :type: MonitoringEventDistributionSettings
        """
    @event_settings.setter
    def event_settings(self, arg1: MonitoringEventDistributionSettings) -> None:
        """
        Configures the distribution of event metrics.
        """
    @builtins.property
    def logging_settings(self) -> MonitoringLoggingDistributionSettings:
        """
        Configures the distribution of logging messages.

        :type: MonitoringLoggingDistributionSettings
        """
    @logging_settings.setter
    def logging_settings(self, arg1: MonitoringLoggingDistributionSettings) -> None:
        """
        Configures the distribution of logging messages.
        """
    @builtins.property
    def periodic_settings(self) -> MonitoringPeriodicDistributionSettings:
        """
        Configures the distribution of periodic metrics.

        :type: MonitoringPeriodicDistributionSettings
        """
    @periodic_settings.setter
    def periodic_settings(self, arg1: MonitoringPeriodicDistributionSettings) -> None:
        """
        Configures the distribution of periodic metrics.
        """
    @builtins.property
    def publisher_qos_profile_name(self) -> typing.Optional[str]:
        """
        The fully qualified name of the profile used to configure the Publishers that distribute telemetry data.

        :type: typing.Optional[str]
        """
    @publisher_qos_profile_name.setter
    def publisher_qos_profile_name(self, arg1: typing.Optional[str]) -> None:
        """
        The fully qualified name of the profile used to configure the Publishers that distribute telemetry data.
        """
    __hash__: NoneType
    pass
class MonitoringEventDistributionSettings():
    def __eq__(self, arg0: rti.connextdds.MonitoringEventDistributionSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.MonitoringEventDistributionSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def concurrency_level(self) -> int:
        """
        Defines how concurrent the push of event metrics to the Monitoring Library 2.0 is

        :type: int
        """
    @concurrency_level.setter
    def concurrency_level(self, arg1: int) -> None:
        """
        Defines how concurrent the push of event metrics to the Monitoring Library 2.0 is
        """
    @builtins.property
    def datawriter_qos_profile_name(self) -> typing.Optional[str]:
        """
        The fully qualified name of the profile used to configure the DataWriter that distributes event metrics.

        :type: typing.Optional[str]
        """
    @datawriter_qos_profile_name.setter
    def datawriter_qos_profile_name(self, arg1: typing.Optional[str]) -> None:
        """
        The fully qualified name of the profile used to configure the DataWriter that distributes event metrics.
        """
    @builtins.property
    def publication_period(self) -> Duration:
        """
        Period at which the event metric thread publishes the event metrics that have changed since the last time they were published.

        :type: Duration
        """
    @publication_period.setter
    def publication_period(self, arg1: Duration) -> None:
        """
        Period at which the event metric thread publishes the event metrics that have changed since the last time they were published.
        """
    @builtins.property
    def thread(self) -> ThreadSettings:
        """
        The settings of the event metric thread.

        :type: ThreadSettings
        """
    @thread.setter
    def thread(self, arg1: ThreadSettings) -> None:
        """
        The settings of the event metric thread.
        """
    __hash__: NoneType
    pass
class MonitoringLoggingDistributionSettings():
    def __eq__(self, arg0: rti.connextdds.MonitoringLoggingDistributionSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.MonitoringLoggingDistributionSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def concurrency_level(self) -> int:
        """
        Defines how concurrent the push of log messages to the Monitoring Library 2.0 is.

        :type: int
        """
    @concurrency_level.setter
    def concurrency_level(self, arg1: int) -> None:
        """
        Defines how concurrent the push of log messages to the Monitoring Library 2.0 is.
        """
    @builtins.property
    def datawriter_qos_profile_name(self) -> typing.Optional[str]:
        """
        The fully qualified name of the profile used to configure the DataWriter that distributes log messages.

        :type: typing.Optional[str]
        """
    @datawriter_qos_profile_name.setter
    def datawriter_qos_profile_name(self, arg1: typing.Optional[str]) -> None:
        """
        The fully qualified name of the profile used to configure the DataWriter that distributes log messages.
        """
    @builtins.property
    def max_historical_logs(self) -> int:
        """
        The number of log messages that the Monitoring Library 2.0 will keep as history.

        :type: int
        """
    @max_historical_logs.setter
    def max_historical_logs(self, arg1: int) -> None:
        """
        The number of log messages that the Monitoring Library 2.0 will keep as history.
        """
    @builtins.property
    def publication_period(self) -> Duration:
        """
        Period at which the logging thread publishes log messages.

        :type: Duration
        """
    @publication_period.setter
    def publication_period(self, arg1: Duration) -> None:
        """
        Period at which the logging thread publishes log messages.
        """
    @builtins.property
    def thread(self) -> ThreadSettings:
        """
        The settings of the logging thread.

        :type: ThreadSettings
        """
    @thread.setter
    def thread(self, arg1: ThreadSettings) -> None:
        """
        The settings of the logging thread.
        """
    __hash__: NoneType
    pass
class MonitoringLoggingForwardingSettings():
    def __eq__(self, arg0: rti.connextdds.MonitoringLoggingForwardingSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.MonitoringLoggingForwardingSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def middleware_forwarding_level(self) -> SyslogVerbosity:
        """
        The forwarding log level for LogFacility.MIDDLEWARE

        :type: SyslogVerbosity
        """
    @middleware_forwarding_level.setter
    def middleware_forwarding_level(self, arg1: SyslogVerbosity) -> None:
        """
        The forwarding log level for LogFacility.MIDDLEWARE
        """
    @builtins.property
    def security_event_forwarding_level(self) -> SyslogVerbosity:
        """
        The forwarding log level for LogFacility.SECURITY_EVENT

        :type: SyslogVerbosity
        """
    @security_event_forwarding_level.setter
    def security_event_forwarding_level(self, arg1: SyslogVerbosity) -> None:
        """
        The forwarding log level for LogFacility.SECURITY_EVENT
        """
    @builtins.property
    def service_forwarding_level(self) -> SyslogVerbosity:
        """
        The forwarding log level for LogFacility.SERVICE

        :type: SyslogVerbosity
        """
    @service_forwarding_level.setter
    def service_forwarding_level(self, arg1: SyslogVerbosity) -> None:
        """
        The forwarding log level for LogFacility.SERVICE
        """
    @builtins.property
    def user_forwarding_level(self) -> SyslogVerbosity:
        """
        The forwarding log level for LogFacility.USER

        :type: SyslogVerbosity
        """
    @user_forwarding_level.setter
    def user_forwarding_level(self, arg1: SyslogVerbosity) -> None:
        """
        The forwarding log level for LogFacility.USER
        """
    __hash__: NoneType
    pass
class MonitoringMetricSelection():
    def __eq__(self, arg0: rti.connextdds.MonitoringMetricSelection) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.MonitoringMetricSelection) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def disabled_metrics_selection(self) -> tuple:
        """
        A sequence of POSIX fnmatch patterns that match the names of the metrics that should not be collected and distributed for the observable resources selected by resource_selection.

        :type: tuple
        """
    @disabled_metrics_selection.setter
    def disabled_metrics_selection(self, arg1: StringSeq) -> None:
        """
        A sequence of POSIX fnmatch patterns that match the names of the metrics that should not be collected and distributed for the observable resources selected by resource_selection.
        """
    @builtins.property
    def enabled_metrics_selection(self) -> tuple:
        """
        A sequence of POSIX fnmatch patterns that match the names of the metrics that should be collected and distributed for the observable resources selected by resource_selection

        :type: tuple
        """
    @enabled_metrics_selection.setter
    def enabled_metrics_selection(self, arg1: StringSeq) -> None:
        """
        A sequence of POSIX fnmatch patterns that match the names of the metrics that should be collected and distributed for the observable resources selected by resource_selection
        """
    @builtins.property
    def resource_selection(self) -> str:
        """
        An expression pattern that selects a subset of resources by matching the pattern to the resource names. enabled_metrics_selection and disabled_metrics_selection are applied to this subset of resources.

        :type: str
        """
    @resource_selection.setter
    def resource_selection(self, arg1: str) -> None:
        """
        An expression pattern that selects a subset of resources by matching the pattern to the resource names. enabled_metrics_selection and disabled_metrics_selection are applied to this subset of resources.
        """
    __hash__: NoneType
    pass
class MonitoringMetricSelectionSeq():
    def __add__(self, arg0: rti.connextdds.MonitoringMetricSelectionSeq) -> rti.connextdds.MonitoringMetricSelectionSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.MonitoringMetricSelection) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.MonitoringMetricSelectionSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.MonitoringMetricSelectionSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.MonitoringMetricSelection: ...
    def __iadd__(self, arg0: rti.connextdds.MonitoringMetricSelectionSeq) -> rti.connextdds.MonitoringMetricSelectionSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.MonitoringMetricSelectionSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.MonitoringMetricSelectionSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.MonitoringMetricSelection]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.MonitoringMetricSelectionSeq: ...
    def __ne__(self, arg0: rti.connextdds.MonitoringMetricSelectionSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.MonitoringMetricSelectionSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.MonitoringMetricSelection) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.MonitoringMetricSelectionSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.MonitoringMetricSelection) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.MonitoringMetricSelection) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.MonitoringMetricSelectionSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.MonitoringMetricSelection) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.MonitoringMetricSelection: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.MonitoringMetricSelection: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.MonitoringMetricSelection) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class MonitoringPeriodicDistributionSettings():
    def __eq__(self, arg0: rti.connextdds.MonitoringPeriodicDistributionSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.MonitoringPeriodicDistributionSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def datawriter_qos_profile_name(self) -> typing.Optional[str]:
        """
        The fully qualified name of the profile used to configure the DataWriter that distributes periodic metrics.

        :type: typing.Optional[str]
        """
    @datawriter_qos_profile_name.setter
    def datawriter_qos_profile_name(self, arg1: typing.Optional[str]) -> None:
        """
        The fully qualified name of the profile used to configure the DataWriter that distributes periodic metrics.
        """
    @builtins.property
    def polling_period(self) -> Duration:
        """
        Period at which the periodic metric thread polls and publishes the periodic metrics.

        :type: Duration
        """
    @polling_period.setter
    def polling_period(self, arg1: Duration) -> None:
        """
        Period at which the periodic metric thread polls and publishes the periodic metrics.
        """
    @builtins.property
    def thread(self) -> ThreadSettings:
        """
        The settings of the periodic metric thread.

        :type: ThreadSettings
        """
    @thread.setter
    def thread(self, arg1: ThreadSettings) -> None:
        """
        The settings of the periodic metric thread.
        """
    __hash__: NoneType
    pass
class MonitoringTelemetryData():
    def __eq__(self, arg0: rti.connextdds.MonitoringTelemetryData) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates an instance with the default settings.
        """
    def __ne__(self, arg0: rti.connextdds.MonitoringTelemetryData) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def logs(self) -> MonitoringLoggingForwardingSettings:
        """
        The MonitoringLoggingForwardingSettings containing the SyslogVerbosity levels that will be forwarded for the different LogFacility.

        :type: MonitoringLoggingForwardingSettings
        """
    @logs.setter
    def logs(self, arg1: MonitoringLoggingForwardingSettings) -> None:
        """
        The MonitoringLoggingForwardingSettings containing the SyslogVerbosity levels that will be forwarded for the different LogFacility.
        """
    @builtins.property
    def metrics(self) -> MonitoringMetricSelectionSeq:
        """
        The sequence of MonitoringMetricSelection containing the event and periodic metrics that will be collected and distributed for a given set of observable resources.

        :type: MonitoringMetricSelectionSeq
        """
    @metrics.setter
    def metrics(self, arg1: MonitoringMetricSelectionSeq) -> None:
        """
        The sequence of MonitoringMetricSelection containing the event and periodic metrics that will be collected and distributed for a given set of observable resources.
        """
    __hash__: NoneType
    pass
class MultiChannel():
    def __eq__(self, arg0: rti.connextdds.MultiChannel) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, channels: rti.connextdds.ChannelSettingsSeq, filter_name: str = Filter.stringmatch_filter_name) -> None: 
        """
        Creates an instance with the specified channels and filter name.
        """
    def __ne__(self, arg0: rti.connextdds.MultiChannel) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def channels(self) -> ChannelSettingsSeq:
        """
        A sequence of ChannelSettings used to configure the channels' properties. If the length of the sequence is zero, the QoS policy will be ignored.

        This property's getter returns a deep copy.

        :type: ChannelSettingsSeq
        """
    @channels.setter
    def channels(self, arg1: ChannelSettingsSeq) -> None:
        """
        A sequence of ChannelSettings used to configure the channels' properties. If the length of the sequence is zero, the QoS policy will be ignored.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def filter_name(self) -> str:
        """
        Name of the filter class used to describe the filter expressions of a MultiChannel DataWriter.

        :type: str
        """
    @filter_name.setter
    def filter_name(self, arg1: str) -> None:
        """
        Name of the filter class used to describe the filter expressions of a MultiChannel DataWriter.
        """
    SQL_FILTER_NAME: str
    STRINGMATCH_FILTER_NAME: str
    __hash__: NoneType
    pass
class MulticastMapping():
    def __eq__(self, arg0: rti.connextdds.MulticastMapping) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default mapping
        """
    @typing.overload
    def __init__(self, addresses: str, topic_expression: str, mapping_function: rti.connextdds.TransportMulticastMappingFunction) -> None: 
        """
        Creates a mapping with the specified parameters
        """
    def __ne__(self, arg0: rti.connextdds.MulticastMapping) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def addresses(self) -> typing.Optional[str]:
        """
        Multicast mapping addresses.

        :type: typing.Optional[str]
        """
    @addresses.setter
    def addresses(self, arg1: str) -> None:
        """
        Multicast mapping addresses.
        """
    @builtins.property
    def mapping_function(self) -> TransportMulticastMappingFunction:
        """
        The mapping function.

        :type: TransportMulticastMappingFunction
        """
    @mapping_function.setter
    def mapping_function(self, arg1: TransportMulticastMappingFunction) -> None:
        """
        The mapping function.
        """
    @builtins.property
    def topic_expression(self) -> typing.Optional[str]:
        """
        The topic expression.

        :type: typing.Optional[str]
        """
    @topic_expression.setter
    def topic_expression(self, arg1: str) -> None:
        """
        The topic expression.
        """
    __hash__: NoneType
    pass
class MulticastMappingSeq():
    def __add__(self, arg0: rti.connextdds.MulticastMappingSeq) -> rti.connextdds.MulticastMappingSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.MulticastMapping) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.MulticastMappingSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.MulticastMappingSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.MulticastMapping: ...
    def __iadd__(self, arg0: rti.connextdds.MulticastMappingSeq) -> rti.connextdds.MulticastMappingSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.MulticastMappingSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.MulticastMappingSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.MulticastMapping]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.MulticastMappingSeq: ...
    def __ne__(self, arg0: rti.connextdds.MulticastMappingSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.MulticastMappingSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.MulticastMapping) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.MulticastMappingSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.MulticastMapping) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.MulticastMapping) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.MulticastMappingSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.MulticastMapping) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.MulticastMapping: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.MulticastMapping: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.MulticastMapping) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class NoOpAnyDataReaderListener(AnyDataReaderListener):
    def __init__(self) -> None: ...
    def on_data_available(self, arg0: rti.connextdds.AnyDataReader) -> None: 
        """
        Data available callback.
        """
    def on_liveliness_changed(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
        """
        Liveliness changed callback.
        """
    def on_requested_deadline_missed(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
        """
        Requested deadline missed callback.
        """
    def on_requested_incompatible_qos(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
        """
        Requested incompatible QoS callback.
        """
    def on_sample_lost(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
        """
        Sample lost callback.
        """
    def on_sample_rejected(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
        """
        Sample rejected callback.
        """
    def on_subscription_matched(self, arg0: rti.connextdds.AnyDataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
        """
        Subscription matched callback.
        """
    pass
class NoOpAnyDataWriterListener(AnyDataWriterListener):
    def __init__(self) -> None: ...
    def on_application_acknowledgment(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
        """
        On application acknowledgment callback
        """
    def on_instance_replaced(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
        """
        On instance replaced callback.
        """
    def on_liveliness_lost(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
        """
        Liveliness lost callback.
        """
    def on_offered_deadline_missed(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
        """
        Offered deadline missed callback.
        """
    def on_offered_incompatible_qos(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
        """
        Offered incompatible QoS callback.
        """
    def on_publication_matched(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
        """
        Publication matched callback.
        """
    def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
        """
        Reliable reader activity changed callback.
        """
    def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
        """
        Reliable writer cache changed callback.
        """
    def on_service_request_accepted(self, arg0: rti.connextdds.AnyDataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
        """
        On service request accepted callback.
        """
    pass
class NoOpAnyTopicListener(AnyTopicListener):
    def __init__(self) -> None: ...
    def on_inconsistent_topic(self, arg0: rti.connextdds.AnyTopic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
        """
        Inconsistent topic callback.
        """
    pass
class NoOpDataReaderListener(DataReaderListener):
    def __init__(self) -> None: ...
    def on_data_available(self, arg0: rti.connextdds.DataReader) -> None: 
        """
        Data available callback.
        """
    def on_liveliness_changed(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
        """
        Liveliness changed callback.
        """
    def on_requested_deadline_missed(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
        """
        Requested deadline missed callback.
        """
    def on_requested_incompatible_qos(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
        """
        Requested incompatible QoS callback.
        """
    def on_sample_lost(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
        """
        Sample lost callback.
        """
    def on_sample_rejected(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
        """
        Sample rejected callback.
        """
    def on_subscription_matched(self, arg0: rti.connextdds.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
        """
        Subscription matched callback.
        """
    pass
class NoOpDataWriterListener(DataWriterListener):
    def __init__(self) -> None: ...
    def on_application_acknowledgment(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
        """
        On application acknowledgment callback
        """
    def on_instance_replaced(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
        """
        On instance replaced callback.
        """
    def on_liveliness_lost(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
        """
        Liveliness lost callback.
        """
    def on_offered_deadline_missed(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
        """
        Offered deadline missed callback.
        """
    def on_offered_incompatible_qos(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
        """
        Offered incompatible QoS callback.
        """
    def on_publication_matched(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
        """
        Publication matched callback.
        """
    def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
        """
        Reliable reader activity changed callback.
        """
    def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
        """
        Reliable writer cache changed callback.
        """
    def on_service_request_accepted(self, arg0: rti.connextdds.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
        """
        On service request accepted callback.
        """
    pass
class SubscriberListener(AnyDataReaderListener):
    def __init__(self) -> None: ...
    def on_data_on_readers(self, arg0: rti.connextdds.Subscriber) -> None: 
        """
        Data on datareaders callback.
        """
    pass
class NoOpPublisherListener(PublisherListener, AnyDataWriterListener):
    def __init__(self) -> None: ...
    pass
class NoOpSubscriberListener(SubscriberListener, AnyDataReaderListener):
    def __init__(self) -> None: ...
    def on_data_on_readers(self, arg0: rti.connextdds.Subscriber) -> None: 
        """
        Data on datareaders callback.
        """
    pass
class TopicListener():
    def __init__(self) -> None: ...
    def on_inconsistent_topic(self, arg0: rti.connextdds.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
        """
        Inconsistent topic callback.
        """
    pass
class NotAllowedBySecurityError(Exception, Exception, BaseException):
    pass
class NotEnabledError(Exception, Exception, BaseException):
    pass
class NullReferenceError(Exception, Exception, BaseException):
    pass
class Uint8Seq():
    def __add__(self, arg0: rti.connextdds.Uint8Seq) -> rti.connextdds.Uint8Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: int) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Uint8Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Uint8Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> int: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Uint8Seq) -> rti.connextdds.Uint8Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Uint8Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Uint8Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Uint8Seq: ...
    def __ne__(self, arg0: rti.connextdds.Uint8Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the string representation of this list. Values are printed as integers.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Uint8Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Uint8Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: int) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: int) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Uint8Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: int) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> int: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> int: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: int) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Uint8Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Uint8Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Uint8Type
        """
    def __ne__(self, arg0: rti.connextdds.Uint8Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class OfferedDeadlineMissedStatus():
    @builtins.property
    def last_instance_handle(self) -> InstanceHandle:
        """
        Handle to the last instance in the DataWriter for which an offered deadline was missed.

        :type: InstanceHandle
        """
    @builtins.property
    def total_count(self) -> int:
        """
        The count of a DataWriter's failures to meet write deadlines.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta in total_count since the last time the listener was called or the status was read.

        :type: int
        """
    pass
class OfferedIncompatibleQosStatus():
    @builtins.property
    def last_policy(self) -> object:
        """
        The policy class of one of the policies that was found to be incompatible the last time an incompatibility was detected.

        :type: object
        """
    @builtins.property
    def policies(self) -> QosPolicyCountSeq:
        """
        A list containing for each policy the total number of times that the concerned DataWriter discovered a DataReader for the same Topic and common partition with a requested QoS that is incompatible with that offered by the DataWriter.

        :type: QosPolicyCountSeq
        """
    @builtins.property
    def total_count(self) -> int:
        """
        Total number of times the concerned DataWriter discovered a DataReader for the same Topic, common partition with a requested QoS that is incompatible with that offered by the DataWriter.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta in total_count since the last time the listener was called or the status was read.

        :type: int
        """
    pass
class OutOfResourcesError(Exception, Exception, BaseException):
    pass
class Ownership():
    def __eq__(self, arg0: rti.connextdds.Ownership) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an ownership policy set to shared.
        """
    @typing.overload
    def __init__(self, kind: rti.connextdds.OwnershipKind) -> None: 
        """
        Creates an instance with the specified ownership kind.
        """
    def __ne__(self, arg0: rti.connextdds.Ownership) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def kind(self) -> OwnershipKind:
        """
        The ownership kind.

        :type: OwnershipKind
        """
    @kind.setter
    def kind(self, arg1: OwnershipKind) -> None:
        """
        The ownership kind.
        """
    __hash__: NoneType
    exclusive: rti.connextdds.Ownership
    shared: rti.connextdds.Ownership
    pass
class OwnershipKind():
    class OwnershipKind():
        """
        Members:

          SHARED : [default] Indicates shared ownership for each instance.

        Multiple writers are allowed to update the same instance and all the updates are made available to the readers. In other words there is no concept of an owner for the instances.

        This is the default behavior if the OWNERSHIP policy is not specified or supported.

          EXCLUSIVE : Indicates each instance can only be owned by one DataWriter, but the owner of an instance can change dynamically.

        The selection of the owner is controlled by the setting of the OWNERSHIP_STRENGTH policy. The owner is always set to be the highest-strength DataWriter object among the ones currently active (as determined by the LIVELINESS).
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        EXCLUSIVE: rti.connextdds.OwnershipKind.OwnershipKind
        SHARED: rti.connextdds.OwnershipKind.OwnershipKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.OwnershipKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.OwnershipKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.OwnershipKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.OwnershipKind.OwnershipKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.OwnershipKind.OwnershipKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.OwnershipKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.OwnershipKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.OwnershipKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> OwnershipKind.OwnershipKind:
        """
        Retrieves the actual enumerated value.

        :type: OwnershipKind.OwnershipKind
        """
    EXCLUSIVE: rti.connextdds.OwnershipKind.OwnershipKind
    SHARED: rti.connextdds.OwnershipKind.OwnershipKind
    __hash__: NoneType
    pass
class OwnershipStrength():
    def __eq__(self, arg0: rti.connextdds.OwnershipStrength) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an instance with the default strength (0).
        """
    @typing.overload
    def __init__(self, strength: int) -> None: 
        """
        Creates an instance with the specified strength value.
        """
    def __ne__(self, arg0: rti.connextdds.OwnershipStrength) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> int:
        """
        The ownership kind.

        :type: int
        """
    @value.setter
    def value(self, arg1: int) -> None:
        """
        The ownership kind.
        """
    __hash__: NoneType
    pass
class ParticipantBuiltinTopicData():
    class ContentFilter(ContentFilterBase):
        def __init__(self) -> None: ...
        def compile(self, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, old_compile_data: typing.Optional[object]) -> typing.Optional[object]: 
            """
            Compile an instance of the content filter according to the filter expression and parameters of the given data type.
            """
        def evaluate(self, compile_data: typing.Optional[object], sample: rti.connextdds.ParticipantBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> bool: 
            """
            Evaluate whether the sample is passing the filter or not according to the sample content.
            """
        def finalize(self, compile_data: typing.Optional[object]) -> None: 
            """
            A previously compiled instance of the content filter is no longer in use and resources can now be cleaned up.
            """
        pass
    class ContentFilteredTopic(ParticipantBuiltinTopicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic, name: str, contentfilter: rti.connextdds.Filter) -> None: 
            """
            Create a ContentFilteredTopic with a name and Filter.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.ParticipantBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast a TopicDescription to a ContentFilteredTopic.
            """
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Test for inequality.
            """
        def append_to_expression_parameter(self, index: int, extension: str) -> None: 
            """
            Append the extension to the end of parameter at the provided index, separated by a comma.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic]: 
            """
            Look up a ContentFilteredTopic by its name in the DomainParticipant.
            """
        def remove_from_expression_parameter(self, index: int, remove_term: str) -> None: 
            """
            Removes the specified term from the parameter at the provided index.
            """
        def set_filter(self, arg0: rti.connextdds.Filter) -> None: 
            """
            Set the filter.
            """
        @builtins.property
        def filter_expression(self) -> str:
            """
            Get the filter expression

            :type: str
            """
        @builtins.property
        def filter_parameters(self) -> StringSeq:
            """
            Get/set the filter parameters.

            :type: StringSeq
            """
        @filter_parameters.setter
        def filter_parameters(self, arg1: StringSeq) -> None:
            """
            Get/set the filter parameters.
            """
        @builtins.property
        def topic(self) -> ParticipantBuiltinTopicData.Topic:
            """
            Get the underlying Topic.

            :type: ParticipantBuiltinTopicData.Topic
            """
        __hash__: NoneType
        pass
    class ContentFilteredTopicSeq():
        def __add__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic: ...
        def __iadd__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataReader(IDataReader, IEntity, IAnyDataReader):
        class Selector():
            def __init__(self, datareader: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> None: 
                """
                Create a Selector for a DataReader to read/take based on selected conditions
                """
            def condition(self, condition: rti.connextdds.IReadCondition) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader.Selector: 
                """
                Select samples based on a ReadCondition.
                """
            def content(self, query: rti.connextdds.Query) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader.Selector: 
                """
                Select samples based on a Query.
                """
            def instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader.Selector: 
                """
                Select a specific instance to read/take.
                """
            def max_samples(self, max: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader.Selector: 
                """
                Limit the number of samples read/taken by the Select.
                """
            def next_instance(self, previous: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader.Selector: 
                """
                Select the instance after the specified instance to read/take.
                """
            def read(self) -> list: 
                """
                Read copies of available samples (data and info) based on the Selector settings.
                """
            def read_data(self) -> list: 
                """
                Read copies of available valid data based on the Selector settings.
                """
            def read_loaned(self) -> rti.connextdds.ParticipantBuiltinTopicData.LoanedSamples: 
                """
                Take available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            def state(self, state: rti.connextdds.DataState) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader.Selector: 
                """
                Select samples with a specified data state.
                """
            def take(self) -> list: 
                """
                Take copies of available samples (data and info) based on the Selector settings.
                """
            def take_data(self) -> list: 
                """
                Take copies of available valid data based on the Selector settings.
                """
            def take_loaned(self) -> rti.connextdds.ParticipantBuiltinTopicData.LoanedSamples: 
                """
                Read available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            pass
        def __enter__(self) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader: 
            """
            Enter a context for this DataReader, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataReader, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> None: 
            """
            Create a DataReader in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.ParticipantBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in the implicit subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.ParticipantBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> None: 
            """
            Create a DataReader.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.ParticipantBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in a subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.ParticipantBuiltinTopicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.ParticipantBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
            """
            Get a typed DataReader from an AnyDataReader.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Get a typed DataReader from an Entity.
            """
        def __lshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader: 
            """
            Set the DataReaderQos for this DataReader.
            """
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader: 
            """
            Get the DataReaderQos from this DataReader
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Subscriber, arg1: rti.connextdds.ParticipantBuiltinTopicData.TopicDescription, arg2: rti.connextdds.DataReaderQos) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader: ...
        def _set_related_writer_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        @typing.overload
        def acknowledge_all(self) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_all(self, arg0: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo) -> None: 
            """
            Acknowledge a single sample.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo, ack_response_data: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge a single sample with ack response data.
            """
        def close(self) -> None: 
            """
            Close this DataReader.
            """
        @staticmethod
        def find_all_by_topic(subscriber: rti.connextdds.Subscriber, topic_name: str) -> rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq: 
            """
            Retrieve all DataReaders for the given topic name in the subscriber.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ParticipantBuiltinTopicData.DataReader]: 
            """
            Find DataReader in DomainParticipant with the DataReader's name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.ParticipantBuiltinTopicData.DataReader]: 
            """
            Find DataReader in Subscriber with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.ParticipantBuiltinTopicData.DataReader]: 
            """
            Find DataReader in Subscriber with a topic name, returning the first found.
            """
        def is_matched_publication_alive(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            Check if a matched publication is alive.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_publication_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Get the PublicationBuiltinTopicData for a publication matched to this DataReader.
            """
        def matched_publication_datareader_protocol_status(self, publication_handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReaderProtocolStatus: 
            """
            Get the DataReaderProtocolStatus for the DataReader based on the matched publication handle.
            """
        def matched_publication_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a publication matched to this DataReader.
            """
        def read(self) -> list: 
            """
            Read copies of all available samples (data and info).
            """
        def read_data(self) -> list: 
            """
            Read copies of all available valid data.
            """
        def read_loaned(self) -> rti.connextdds.ParticipantBuiltinTopicData.LoanedSamples: 
            """
            Read all available samples (data and info) and return them in a loaned container.
            """
        @staticmethod
        def select(*args, **kwargs) -> typing.Any: 
            """
            Get a Selector to perform complex data selections, such as per-instance selection, content, and status filtering.
            """
        def set_listener(self, listener: rti.connextdds.ParticipantBuiltinTopicData.DataReaderListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and associated event mask.
            """
        def take(self) -> list: 
            """
            Take copies of all available samples (data and info).
            """
        def take_data(self) -> list: 
            """
            Take copies of all available valid data.
            """
        def take_loaned(self) -> rti.connextdds.ParticipantBuiltinTopicData.LoanedSamples: 
            """
            Take all available samples (data and info) and return them in a loaned container.
            """
        def wait_for_historical_data(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind.
            """
        def wait_for_historical_data_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind. This call is awaitable and only for use with asyncio.
            """
        @builtins.property
        def _has_matched_publications_with_related_reader(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datareader_cache_status(self) -> DataReaderCacheStatus:
            """
            Get the DataReaderCacheStatus for the DataReader.

            :type: DataReaderCacheStatus
            """
        @builtins.property
        def datareader_protocol_status(self) -> DataReaderProtocolStatus:
            """
            Get the DataReaderProtocolStatus for the DataReader.

            :type: DataReaderProtocolStatus
            """
        @builtins.property
        def default_filter_state(self) -> DataState:
            """
            Returns the filter state for the read/take operations.

            :type: DataState
            """
        @default_filter_state.setter
        def default_filter_state(self, arg1: DataState) -> None:
            """
            Returns the filter state for the read/take operations.
            """
        @builtins.property
        def listener(self) -> ParticipantBuiltinTopicData.DataReaderListener:
            """
            Gets or sets the listener with StatusMask.ALL

            :type: ParticipantBuiltinTopicData.DataReaderListener
            """
        @listener.setter
        def listener(self, arg1: ParticipantBuiltinTopicData.DataReaderListener) -> None:
            """
            Gets or sets the listener with StatusMask.ALL
            """
        @builtins.property
        def liveliness_changed_status(self) -> LivelinessChangedStatus:
            """
            Get the LivelinessChangedStatus for this DataReader.

            :type: LivelinessChangedStatus
            """
        @builtins.property
        def matched_publications(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched publication handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def qos(self) -> DataReaderQos:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.

            :type: DataReaderQos
            """
        @qos.setter
        def qos(self, arg1: DataReaderQos) -> None:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.
            """
        @builtins.property
        def requested_deadline_missed_status(self) -> RequestedDeadlineMissedStatus:
            """
            Get the RequestedDeadlineMissed status for the DataReader

            :type: RequestedDeadlineMissedStatus
            """
        @builtins.property
        def requested_incompatible_qos_status(self) -> RequestedIncompatibleQosStatus:
            """
            Get the RequestedIncompatibleQosStatus for the DataReader.

            :type: RequestedIncompatibleQosStatus
            """
        @builtins.property
        def sample_lost_status(self) -> SampleLostStatus:
            """
            Get the SampleLostStatus for the DataReader.

            :type: SampleLostStatus
            """
        @builtins.property
        def sample_rejected_status(self) -> SampleRejectedStatus:
            """
            Get the SampleRejectedStatus for the DataReader.

            :type: SampleRejectedStatus
            """
        @builtins.property
        def subscriber(self) -> Subscriber:
            """
            Returns the parent Subscriber of the DataReader.

            :type: Subscriber
            """
        @builtins.property
        def subscription_matched_status(self) -> SubscriptionMatchedStatus:
            """
            Get the SubscriptionMatchedStatus for the DataReader.

            :type: SubscriptionMatchedStatus
            """
        @builtins.property
        def topic_description(self) -> ParticipantBuiltinTopicData.TopicDescription:
            """
            Returns the TopicDescription associated with the DataReader.

            :type: ParticipantBuiltinTopicData.TopicDescription
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataReader.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name associated with this DataReader.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataReaderListener():
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class DataReaderSeq():
        def __add__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq) -> rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader: ...
        def __iadd__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq) -> rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ParticipantBuiltinTopicData.DataReader]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq: ...
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.ParticipantBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataReader: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataWriter(IEntity, IAnyDataWriter):
        def __enter__(self) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Enter a context for this DataWriter, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataWriter, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> None: 
            """
            Creates a DataWriter in the implicit publisher with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.ParticipantBuiltinTopicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in the implicit publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> None: 
            """
            Creates a DataWriter in a publisher with default QoS.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.ParticipantBuiltinTopicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.ParticipantBuiltinTopicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in a publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
            """
            Create a typed DataWriter from an AnyDataWriter.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Create a typed DataWriter from an Entity.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Sets the DataWriterQos.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Writes a paired sample with a timestamp.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.InstanceHandle]) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Writes a paired sample with an instance handle.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Writes a sequence of pairs of samples with timestamps.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Writes a sequence of samples.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Writes a sample.
            """
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Get the DataWriterQos.
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Publisher, arg1: rti.connextdds.ParticipantBuiltinTopicData.Topic, arg2: rti.connextdds.DataWriterQos) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: ...
        def _set_related_reader_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        def _wait_for_sample_acknowledgment(self, sample_id: rti.connextdds.SampleIdentity, timeout: rti.connextdds.Duration) -> None: 
            """
            Wait for a sample to be acknowledged by the application.
            """
        def assert_liveliness(self) -> None: 
            """
            Manually asserts the liveliness of the DataWriter.
            """
        def close(self) -> None: 
            """
            Close this DataWriter.
            """
        def create_data(self) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Create data of the writer's associated type and initialize it.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Dispose an instance with params.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData) -> object: 
            """
            Dispose the instance associated with key_holder.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose the instance associated with key_holder using a timestamp
            """
        @typing.overload
        def dispose_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Dispose an instance with params.
            """
        @staticmethod
        def find_all_by_topic(publisher: rti.connextdds.Publisher, topic_name: str) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq: 
            """
            Retrieve all DataWriters for the given topic name in the publisher.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ParticipantBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in DomainParticipant with the provided name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.ParticipantBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in Publisher with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.ParticipantBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in publisher with a topic name, returning the first found.
            """
        def flush(self) -> None: 
            """
            Flushes the batch in progress in the context of thecalling thread.
            """
        def is_matched_subscription_active(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            A boolean indicating whether or not the matched subscription is active.
            """
        def is_sample_app_acknowledged(self, sample_id: rti.connextdds.SampleIdentity) -> bool: 
            """
            Indicates if a sample is considered application-acknowledged.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_subscription_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Get the SubscriptionBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription handle.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, locator: rti.connextdds.Locator) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription locator.
            """
        def matched_subscription_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData, timestamp: rti.connextdds.Time) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance and specified the timestamp.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData, params: rti.connextdds.WriteParams) -> rti.connextdds.InstanceHandle: 
            """
            Registers instance with parameters.
            """
        def set_listener(self, listener: rti.connextdds.ParticipantBuiltinTopicData.DataWriterListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask for the DataWriter.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Unregister an instance with parameters.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData) -> object: 
            """
            Unregister the instance associated with key_holder.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.ParticipantBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister the instance associate with key_holder using a timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Unregister an instance with parameters.
            """
        def wait_for_acknowledgments(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Blocks the calling thread until all data written by a reliable DataWriter is acknowledged or until the timeout expires.
            """
        def wait_for_asynchronous_publishing(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            This operation blocks the calling thread (up to max_wait) until all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        def wait_for_asynchronous_publishing_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            This function is awaitable until either a timeout of max_wait or all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.This function works with asyncio.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        @typing.overload
        def write(self, samples: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> None: 
            """
            Write a sequence of samples.
            """
        @typing.overload
        def write(self, samples: rti.connextdds.ParticipantBuiltinTopicDataSeq, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sequence of samples with a timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ParticipantBuiltinTopicData) -> None: 
            """
            Write a sample.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ParticipantBuiltinTopicData, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with a specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ParticipantBuiltinTopicData, handle: rti.connextdds.InstanceHandle) -> None: 
            """
            Write a sample with an instance handle.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ParticipantBuiltinTopicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with an instance handle and specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ParticipantBuiltinTopicData, params: rti.connextdds.WriteParams) -> None: 
            """
            Write with advanced parameters.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ParticipantBuiltinTopicData) -> object: 
            """
            Write a sample. This method is awaitable and is only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ParticipantBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with a specified timestamp. This methods is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ParticipantBuiltinTopicData, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Write a sample with an instance handle. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ParticipantBuiltinTopicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with an instance handle and specified timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> object: 
            """
            Write a sequence of samples. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.ParticipantBuiltinTopicDataSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.ParticipantBuiltinTopicDataSeq, handles: rti.connextdds.InstanceHandleSeq) -> object: 
            """
            Write a sequence of samples with their instance handles. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.ParticipantBuiltinTopicDataSeq, handles: rti.connextdds.InstanceHandleSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with their instance handles and a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ParticipantBuiltinTopicData, params: rti.connextdds.WriteParams) -> object: 
            """
            Write with advanced parameters.
            """
        @builtins.property
        def _has_matched_subscriptions_with_related_writer(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datawriter_cache_status(self) -> DataWriterCacheStatus:
            """
            Get a copy of the cache status for this writer.

            :type: DataWriterCacheStatus
            """
        @builtins.property
        def datawriter_protocol_status(self) -> DataWriterProtocolStatus:
            """
            Get a copy of the protocol status for this writer.

            :type: DataWriterProtocolStatus
            """
        @builtins.property
        def listener(self) -> ParticipantBuiltinTopicData.DataWriterListener:
            """
            Get the listener associated with the DataWriter or set the listener.

            :type: ParticipantBuiltinTopicData.DataWriterListener
            """
        @listener.setter
        def listener(self, arg1: ParticipantBuiltinTopicData.DataWriterListener) -> None:
            """
            Get the listener associated with the DataWriter or set the listener.
            """
        @builtins.property
        def liveliness_lost_status(self) -> LivelinessLostStatus:
            """
            Get a copy of the LivelinessLostStatus.

            :type: LivelinessLostStatus
            """
        @builtins.property
        def matched_subscriptions(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched subscription handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def matched_subscriptions_locators(self) -> LocatorSeq:
            """
            The locators used to communicate with matched DataReaders.

            :type: LocatorSeq
            """
        @builtins.property
        def offered_deadline_missed_status(self) -> OfferedDeadlineMissedStatus:
            """
            Get a copy of the OfferedDeadlineMissedStatus.

            :type: OfferedDeadlineMissedStatus
            """
        @builtins.property
        def offered_incompatible_qos_status(self) -> OfferedIncompatibleQosStatus:
            """
            Get a copy of the OfferedIncompatibleQosStatus

            :type: OfferedIncompatibleQosStatus
            """
        @builtins.property
        def publication_matched_status(self) -> PublicationMatchedStatus:
            """
            Get a copy of the PublicationMatchedStatus

            :type: PublicationMatchedStatus
            """
        @builtins.property
        def publisher(self) -> Publisher:
            """
            Get the Publisher that owns this DataWriter.

            :type: Publisher
            """
        @builtins.property
        def qos(self) -> DataWriterQos:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.

            :type: DataWriterQos
            """
        @qos.setter
        def qos(self, arg1: DataWriterQos) -> None:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.
            """
        @builtins.property
        def reliable_reader_activity_changed_status(self) -> ReliableReaderActivityChangedStatus:
            """
            Get a copy of the reliable reader activity changed status for this writer.

            :type: ReliableReaderActivityChangedStatus
            """
        @builtins.property
        def reliable_writer_cache_changed_status(self) -> ReliableWriterCacheChangedStatus:
            """
            Get a copy of the reliable cache status for this writer.

            :type: ReliableWriterCacheChangedStatus
            """
        @builtins.property
        def service_request_accepted_status(self) -> ServiceRequestAcceptedStatus:
            """
            Get a copy of the service request accepted status for this writer.

            :type: ServiceRequestAcceptedStatus
            """
        @builtins.property
        def topic(self) -> ParticipantBuiltinTopicData.Topic:
            """
            Get the Topic object associated with this DataWriter.

            :type: ParticipantBuiltinTopicData.Topic
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataWriter.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name for the topic object associated with this DataWriter.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataWriterListener():
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class DataWriterSeq():
        def __add__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.ParticipantBuiltinTopicData.DataWriter) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: ...
        def __iadd__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ParticipantBuiltinTopicData.DataWriter]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq: ...
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.ParticipantBuiltinTopicData.DataWriter) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.ParticipantBuiltinTopicData.DataWriter) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.ParticipantBuiltinTopicData.DataWriter) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.ParticipantBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.ParticipantBuiltinTopicData.DataWriter) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.ParticipantBuiltinTopicData.DataWriter: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.ParticipantBuiltinTopicData.DataWriter) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ITopicDescription(IEntity):
        @builtins.property
        def name(self) -> str:
            """
            The name of the entity conforming to the ITopicDescription interface.

            :type: str
            """
        @builtins.property
        def participant(self) -> DomainParticipant:
            """
            The parent DomainParticipant.

            :type: DomainParticipant
            """
        @builtins.property
        def type_name(self) -> str:
            """
            The name of the associated type.

            :type: str
            """
        pass
    class LoanedSample():
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, data: rti.connextdds.ParticipantBuiltinTopicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct LoanedSample with data and info.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> ParticipantBuiltinTopicData:
            """
            Get the data associated with the sample.

            :type: ParticipantBuiltinTopicData
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        pass
    class LoanedSamples():
        def __enter__(self) -> rti.connextdds.ParticipantBuiltinTopicData.LoanedSamples: 
            """
            Enter a context for the loaned samples, loan returned on context exit.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for the loaned samples, returning the resources.
            """
        def __getitem__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.LoanedSample: 
            """
            Access a LoanedSample object in an array-like syntax
            """
        def __init__(self) -> None: 
            """
            Create an empty LoanedSamples object.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.ParticipantBuiltinTopicData.LoanedSample]: ...
        def __len__(self) -> int: 
            """
            Get the number of samples in the loan.
            """
        def return_loan(self) -> None: 
            """
            Returns the loan to the DataReader.
            """
        @builtins.property
        def length(self) -> int:
            """
            Get the number of samples in the loan.

            :type: int
            """
        pass
    class NoOpDataReaderListener(ParticipantBuiltinTopicData.DataReaderListener):
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class NoOpDataWriterListener(ParticipantBuiltinTopicData.DataWriterListener):
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class NoOpTopicListener(ParticipantBuiltinTopicData.TopicListener):
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class Sample():
        @typing.overload
        def __init__(self, data: rti.connextdds.ParticipantBuiltinTopicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct Sample with data and info.
            """
        @typing.overload
        def __init__(self, sample: rti.connextdds.ParticipantBuiltinTopicData.Sample) -> None: 
            """
            Copy constructor.
            """
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, loaned_sample: rti.connextdds.ParticipantBuiltinTopicData.LoanedSample) -> None: 
            """
            Construct a sample with a loaned sample.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> ParticipantBuiltinTopicData:
            """
            The data associated with the sample.

            :type: ParticipantBuiltinTopicData
            """
        @data.setter
        def data(self, arg1: ParticipantBuiltinTopicData) -> None:
            """
            The data associated with the sample.
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        @info.setter
        def info(self, arg1: SampleInfo) -> None:
            """
            Get the info associated with the sample.
            """
        pass
    class SharedSamples():
        def __getitem__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.LoanedSample: 
            """
            Get the sample at the specified index.
            """
        def __init__(self, loaned_samples: rti.connextdds.ParticipantBuiltinTopicData.LoanedSamples) -> None: 
            """
            Constructs an instance of SharedSamples, removing ownership of the loan from the Loaned Samples.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.ParticipantBuiltinTopicData.LoanedSample]: 
            """
            Make a sample iterator
            """
        def __len__(self) -> int: 
            """
            Returns the number of samples.
            """
        pass
    class Topic(ParticipantBuiltinTopicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast an Entity to a Topic.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.ParticipantBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast an ITopicDescription to a Topic.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
            """
            Create a typed Topic from an AnyTopic.
            """
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> bool: 
            """
            Test for inequality.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ParticipantBuiltinTopicData.Topic]: 
            """
            Look up a Topic by its name in the DomainParticipant.
            """
        def set_listener(self, listener: rti.connextdds.ParticipantBuiltinTopicData.TopicListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask.
            """
        @builtins.property
        def inconsistent_topic_status(self) -> InconsistentTopicStatus:
            """
            Get a copy of the current InconsistentTopicStatus for this Topic.

            :type: InconsistentTopicStatus
            """
        @builtins.property
        def listener(self) -> ParticipantBuiltinTopicData.TopicListener:
            """
            The listener.

            :type: ParticipantBuiltinTopicData.TopicListener
            """
        @listener.setter
        def listener(self, arg1: ParticipantBuiltinTopicData.TopicListener) -> None:
            """
            The listener.
            """
        @builtins.property
        def qos(self) -> TopicQos:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.

            :type: TopicQos
            """
        @qos.setter
        def qos(self, arg1: TopicQos) -> None:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.
            """
        __hash__: NoneType
        pass
    class TopicDescription(ParticipantBuiltinTopicData.ITopicDescription, IEntity):
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.TopicDescription) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ParticipantBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.TopicDescription) -> bool: 
            """
            Test for inequality.
            """
        __hash__: NoneType
        pass
    class TopicListener():
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class TopicSeq():
        def __add__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.TopicSeq) -> rti.connextdds.ParticipantBuiltinTopicData.TopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.TopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.ParticipantBuiltinTopicData.TopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.Topic: ...
        def __iadd__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.TopicSeq) -> rti.connextdds.ParticipantBuiltinTopicData.TopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.TopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.TopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ParticipantBuiltinTopicData.Topic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.TopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData.TopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData.TopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.ParticipantBuiltinTopicData.TopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.ParticipantBuiltinTopicData.TopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.ParticipantBuiltinTopicData.Topic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.ParticipantBuiltinTopicData.Topic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.ParticipantBuiltinTopicData.Topic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ValidLoanedSamples():
        def __enter__(self) -> rti.connextdds.ParticipantBuiltinTopicData.ValidLoanedSamples: ...
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ParticipantBuiltinTopicData.LoanedSample]: ...
        pass
    class WriterContentFilter(ParticipantBuiltinTopicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def writer_attach(self) -> typing.Optional[object]: 
            """
            A writer-side filtering API to create some state that can facilitate filtering on the writer side.
            """
        def writer_compile(self, writer_filter_data: typing.Optional[object], property: rti.connextdds.ExpressionProperty, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_detach(self, writer_filter_data: typing.Optional[object]) -> None: 
            """
            A writer-side filtering API to clean up a previously created state using writer_attach.
            """
        def writer_evaluate(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.ParticipantBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> rti.connextdds.CookieVector: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_finalize(self, writer_filter_data: typing.Optional[object], cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to clean up a previously compiled instance of the content filter.
            """
        def writer_return_loan(self, writer_filter_data: typing.Optional[object], cookies: rti.connextdds.CookieVector) -> None: 
            """
            A writer-side filtering API to return the loan on the list of DataReaders returned by writer_evaluate.
            """
        pass
    class WriterContentFilterHelper(ParticipantBuiltinTopicData.WriterContentFilter, ParticipantBuiltinTopicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def add_cookie(self, cookie: rti.connextdds.Cookie) -> None: 
            """
            A helper function which will add a Cookie to the Cookie sequence that is then returned by the writer_evaluate function.
            """
        def writer_evaluate_helper(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.ParticipantBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        pass
    def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default ParticipantBuiltinTopicData.
        """
    def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicData) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def dds_builtin_endpoints(self) -> int:
        """
        Bitmap of builtin endpoints supported by the participant.

        :type: int
        """
    @builtins.property
    def default_unicast_locators(self) -> LocatorVector:
        """
        Get the unicast locators used when individual entities do not specify unicast locators.

        :type: LocatorVector
        """
    @builtins.property
    def domain_id(self) -> int:
        """
        Get the domain ID associated with the discovered DomainParticipant.

        :type: int
        """
    @builtins.property
    def key(self) -> BuiltinTopicKey:
        """
        Get the DCPS key to distinguish entries.

        :type: BuiltinTopicKey
        """
    @builtins.property
    def partial_configuration(self) -> int:
        """
        Indicates whether the ParticipantBuiltinTopicData only contains bootstrapping information.

        :type: int
        """
    @builtins.property
    def participant_name(self) -> EntityName:
        """
        Get the participant name and role name.

        :type: EntityName
        """
    @builtins.property
    def product_version(self) -> ProductVersion:
        """
        Get the current version for RTI Connext.

        :type: ProductVersion
        """
    @builtins.property
    def property(self) -> Property:
        """
        Get the Property policy of the corresponding DomainParticipant.

        :type: Property
        """
    @builtins.property
    def reachability_lease_duration(self) -> Duration:
        """
        The reachability lease duration.

        :type: Duration
        """
    @builtins.property
    def rtps_protocol_version(self) -> ProtocolVersion:
        """
        Get the version number of the RTPS wire protocol used.

        :type: ProtocolVersion
        """
    @builtins.property
    def rtps_vendor_id(self) -> VendorId:
        """
        Get the ID of the vendor implementing the RTPS wire protocol.

        :type: VendorId
        """
    @builtins.property
    def transport_info(self) -> TransportInfoVector:
        """
        Get the sequence of TransportInfo containing information about each of the installed transports of the discovered DomainParticipant.

        :type: TransportInfoVector
        """
    @builtins.property
    def user_data(self) -> UserData:
        """
        Get the UserData policy of the corresponding DomainParticipant.

        :type: UserData
        """
    @builtins.property
    def vendor_builtin_endpoints(self) -> int:
        """
        Bitmap of vendor-specific builtin endpoints supported by the participant.

        :type: int
        """
    __hash__: NoneType
    topic_name: str
    pass
class ParticipantBuiltinTopicDataSeq():
    def __add__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> rti.connextdds.ParticipantBuiltinTopicDataSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.ParticipantBuiltinTopicData) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.ParticipantBuiltinTopicDataSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicData: ...
    def __iadd__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> rti.connextdds.ParticipantBuiltinTopicDataSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicDataSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.ParticipantBuiltinTopicData]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicDataSeq: ...
    def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicDataSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.ParticipantBuiltinTopicData) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.ParticipantBuiltinTopicData) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.ParticipantBuiltinTopicData) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.ParticipantBuiltinTopicDataSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.ParticipantBuiltinTopicData) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.ParticipantBuiltinTopicData: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.ParticipantBuiltinTopicData: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.ParticipantBuiltinTopicData) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class ParticipantBuiltinTopicDataTimestampedSeq():
    def __add__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq) -> rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]: ...
    def __iadd__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq) -> rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq: ...
    def __ne__(self, arg0: rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.ParticipantBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: tuple[rti.connextdds.ParticipantBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class Partition():
    def __eq__(self, arg0: rti.connextdds.Partition) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a policy with the default partition.
        """
    @typing.overload
    def __init__(self, partition: str) -> None: 
        """
        Creates a policy with a single partition with the specified name.
        """
    @typing.overload
    def __init__(self, partitions: rti.connextdds.StringSeq) -> None: 
        """
        Creates a policy with the partitions specified in a sequence.
        """
    def __ne__(self, arg0: rti.connextdds.Partition) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def name(self) -> StringSeq:
        """
        The partition names specified in a sequence.

        :type: StringSeq
        """
    @name.setter
    def name(self, arg1: StringSeq) -> None:
        """
        The partition names specified in a sequence.
        """
    __hash__: NoneType
    pass
class PersistentJournalKind():
    """
    Members:

      DELETE : Deletes the rollback journal at the conclusion of each transaction

      TRUNCATE : Commits transactions by truncating the rollback journal to zero-length instead of deleting it

      PERSIST : Prevents the rollback journal from being deleted at the end of each transaction. Instead, the header of the journal is overwritten with zeros

      MEMORY : Stores the rollback journal in volatile RAM. This saves disk I/O

      WAL : Uses a write-ahead log instead of a rollback journal to implement transactions

      OFF : Completely disables the rollback journal
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @builtins.property
    def name(self) -> str:
        """
        :type: str
        """
    @builtins.property
    def value(self) -> int:
        """
        :type: int
        """
    DELETE: rti.connextdds.PersistentJournalKind
    MEMORY: rti.connextdds.PersistentJournalKind
    OFF: rti.connextdds.PersistentJournalKind
    PERSIST: rti.connextdds.PersistentJournalKind
    TRUNCATE: rti.connextdds.PersistentJournalKind
    WAL: rti.connextdds.PersistentJournalKind
    __members__: dict
    pass
class PersistentStorageSettings():
    def __eq__(self, arg0: rti.connextdds.PersistentStorageSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a PersistentStorageSettings with default settings.
        """
    def __ne__(self, arg0: rti.connextdds.PersistentStorageSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def enable(self) -> bool:
        """
        Enables durable writer history in a DataWriter and durable reader state in a DataReader.

        :type: bool
        """
    @enable.setter
    def enable(self, arg1: bool) -> None:
        """
        Enables durable writer history in a DataWriter and durable reader state in a DataReader.
        """
    @builtins.property
    def file_name(self) -> typing.Optional[str]:
        """
        The file name where the durable writer history or durable reader state will be stored.

        :type: typing.Optional[str]
        """
    @file_name.setter
    def file_name(self, arg1: typing.Optional[str]) -> None:
        """
        The file name where the durable writer history or durable reader state will be stored.
        """
    @builtins.property
    def journal_kind(self) -> PersistentJournalKind:
        """
        Sets the journal mode of the persistent storage.

        :type: PersistentJournalKind
        """
    @journal_kind.setter
    def journal_kind(self, arg1: PersistentJournalKind) -> None:
        """
        Sets the journal mode of the persistent storage.
        """
    @builtins.property
    def reader_checkpoint_frequency(self) -> int:
        """
        Controls how often the reader state is stored into the database.

        :type: int
        """
    @reader_checkpoint_frequency.setter
    def reader_checkpoint_frequency(self, arg1: int) -> None:
        """
        Controls how often the reader state is stored into the database.
        """
    @builtins.property
    def restore(self) -> bool:
        """
        Indicates if the persisted writer history or reader state must be restored.

        :type: bool
        """
    @restore.setter
    def restore(self, arg1: bool) -> None:
        """
        Indicates if the persisted writer history or reader state must be restored.
        """
    @builtins.property
    def synchronization_kind(self) -> PersistentSynchronizationKind:
        """
        Sets the journal mode of the persistent storage.

        :type: PersistentSynchronizationKind
        """
    @synchronization_kind.setter
    def synchronization_kind(self, arg1: PersistentSynchronizationKind) -> None:
        """
        Sets the journal mode of the persistent storage.
        """
    @builtins.property
    def trace_file_name(self) -> typing.Optional[str]:
        """
        The file name where to store the SQL statements executed when loading and storing the durable writer history or durable reader state.

        :type: typing.Optional[str]
        """
    @trace_file_name.setter
    def trace_file_name(self, arg1: typing.Optional[str]) -> None:
        """
        The file name where to store the SQL statements executed when loading and storing the durable writer history or durable reader state.
        """
    @builtins.property
    def vacuum(self) -> bool:
        """
        Sets the auto-vacuum status of the storage.

        :type: bool
        """
    @vacuum.setter
    def vacuum(self, arg1: bool) -> None:
        """
        Sets the auto-vacuum status of the storage.
        """
    @builtins.property
    def writer_instance_cache_allocation(self) -> AllocationSettings:
        """
        Configures the resource limits associated with the instance durable writer history cache.

        :type: AllocationSettings
        """
    @writer_instance_cache_allocation.setter
    def writer_instance_cache_allocation(self, arg1: AllocationSettings) -> None:
        """
        Configures the resource limits associated with the instance durable writer history cache.
        """
    @builtins.property
    def writer_memory_state(self) -> bool:
        """
        Determines how much state will be kept in memory by the durable writer history in order to avoid accessing the persistent storage in disk.

        :type: bool
        """
    @writer_memory_state.setter
    def writer_memory_state(self, arg1: bool) -> None:
        """
        Determines how much state will be kept in memory by the durable writer history in order to avoid accessing the persistent storage in disk.
        """
    @builtins.property
    def writer_sample_cache_allocation(self) -> AllocationSettings:
        """
        Configures the resource limits associated with the sample durable writer history cache.

        :type: AllocationSettings
        """
    @writer_sample_cache_allocation.setter
    def writer_sample_cache_allocation(self, arg1: AllocationSettings) -> None:
        """
        Configures the resource limits associated with the sample durable writer history cache.
        """
    __hash__: NoneType
    pass
class PersistentSynchronizationKind():
    """
    Members:

      NORMAL : Data (e.g., new sample) is written to disk at critical moments

      FULL : Data (e.g., new sample) is written to physical disk immediately

      OFF : No synchronization is enforced
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @builtins.property
    def name(self) -> str:
        """
        :type: str
        """
    @builtins.property
    def value(self) -> int:
        """
        :type: int
        """
    FULL: rti.connextdds.PersistentSynchronizationKind
    NORMAL: rti.connextdds.PersistentSynchronizationKind
    OFF: rti.connextdds.PersistentSynchronizationKind
    __members__: dict
    pass
class PreconditionNotMetError(Exception, Exception, BaseException):
    pass
class Presentation():
    def __eq__(self, arg0: rti.connextdds.Presentation) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an instance with the default value.
        """
    @typing.overload
    def __init__(self, access_scope: rti.connextdds.PresentationAccessScopeKind, coherent_access: bool, ordered_access: bool) -> None: 
        """
        Creates an instance with the specified access scope and coherent and ordered access.
        """
    def __ne__(self, arg0: rti.connextdds.Presentation) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    def group_access_scope(coherent: bool, ordered: bool) -> rti.connextdds.Presentation: 
        """
        Creates a Presentation instance with group access scope.
        """
    @staticmethod
    def instance_access_scope(coherent: bool, ordered: bool) -> rti.connextdds.Presentation: 
        """
        Creates a Presentation instance with instance access scope.
        """
    @staticmethod
    def topic_access_scope(coherent: bool, ordered: bool) -> rti.connextdds.Presentation: 
        """
        Creates a Presentation instance with topic access scope.
        """
    @builtins.property
    def access_scope(self) -> PresentationAccessScopeKind:
        """
        Determines the largest scope spanning the entities for which the order and coherency of changes can be preserved.

        :type: PresentationAccessScopeKind
        """
    @access_scope.setter
    def access_scope(self, arg1: PresentationAccessScopeKind) -> None:
        """
        Determines the largest scope spanning the entities for which the order and coherency of changes can be preserved.
        """
    @builtins.property
    def coherent_access(self) -> bool:
        """
        Controls whether coherent access is supported within the access_scope.

        :type: bool
        """
    @coherent_access.setter
    def coherent_access(self, arg1: bool) -> None:
        """
        Controls whether coherent access is supported within the access_scope.
        """
    @builtins.property
    def drop_incomplete_coherent_set(self) -> bool:
        """
        Indicates whether or not a DataReader should drop samples from an incomplete coherent set

        :type: bool
        """
    @drop_incomplete_coherent_set.setter
    def drop_incomplete_coherent_set(self, arg1: bool) -> None:
        """
        Indicates whether or not a DataReader should drop samples from an incomplete coherent set
        """
    @builtins.property
    def ordered_access(self) -> bool:
        """
        Controls whether ordered access is supported within the access_scope.

        :type: bool
        """
    @ordered_access.setter
    def ordered_access(self, arg1: bool) -> None:
        """
        Controls whether ordered access is supported within the access_scope.
        """
    __hash__: NoneType
    pass
class PresentationAccessScopeKind():
    class PresentationAccessScopeKind():
        """
        Members:

          INSTANCE : [default] Scope spans only a single instance.

        Indicates that changes to one instance need not be coherent nor ordered with respect to changes to any other instance. In other words, order and coherent changes apply to each instance separately.

          TOPIC : Scope spans to all instances within the same DataWriter (or DataReader), but not across instances in different DataWriter (or DataReader).

          GROUP : Scope spans to all instances belonging to DataWriter (or DataReader) entities within the same Publisher (or Subscriber).

          HIGHEST_OFFERED : This value only applies to a Subscriber. The Subscriber will use the access scope specified by each remote Publisher.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        GROUP: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind
        HIGHEST_OFFERED: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind
        INSTANCE: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind
        TOPIC: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.PresentationAccessScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.PresentationAccessScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.PresentationAccessScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.PresentationAccessScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.PresentationAccessScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.PresentationAccessScopeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> PresentationAccessScopeKind.PresentationAccessScopeKind:
        """
        Retrieves the actual enumerated value.

        :type: PresentationAccessScopeKind.PresentationAccessScopeKind
        """
    GROUP: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind
    HIGHEST_OFFERED: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind
    INSTANCE: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind
    TOPIC: rti.connextdds.PresentationAccessScopeKind.PresentationAccessScopeKind
    __hash__: NoneType
    pass
class PrintFormat():
    class PrintFormat():
        """
        Members:

          DEFAULT : Print message, method name, and activity context (default).

          TIMESTAMPED : Print message, method name, activity context, and timestamp.

          VERBOSE : Print message with all available context information (includes thread identifier, activity context).

          VERBOSE_TIMESTAMPED : Print message with all available context information, and timestamp.

          DEBUG : Print a set of field that may be useful for internal debug.

          MINIMAL : Print only message number and method name.

          MAXIMAL : Print all available fields.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        DEBUG: rti.connextdds.PrintFormat.PrintFormat
        DEFAULT: rti.connextdds.PrintFormat.PrintFormat
        MAXIMAL: rti.connextdds.PrintFormat.PrintFormat
        MINIMAL: rti.connextdds.PrintFormat.PrintFormat
        TIMESTAMPED: rti.connextdds.PrintFormat.PrintFormat
        VERBOSE: rti.connextdds.PrintFormat.PrintFormat
        VERBOSE_TIMESTAMPED: rti.connextdds.PrintFormat.PrintFormat
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.PrintFormat) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.PrintFormat) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.PrintFormat) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.PrintFormat.PrintFormat) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.PrintFormat.PrintFormat: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.PrintFormat) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.PrintFormat) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.PrintFormat) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> PrintFormat.PrintFormat:
        """
        Retrieves the actual enumerated value.

        :type: PrintFormat.PrintFormat
        """
    DEBUG: rti.connextdds.PrintFormat.PrintFormat
    DEFAULT: rti.connextdds.PrintFormat.PrintFormat
    MAXIMAL: rti.connextdds.PrintFormat.PrintFormat
    MINIMAL: rti.connextdds.PrintFormat.PrintFormat
    TIMESTAMPED: rti.connextdds.PrintFormat.PrintFormat
    VERBOSE: rti.connextdds.PrintFormat.PrintFormat
    VERBOSE_TIMESTAMPED: rti.connextdds.PrintFormat.PrintFormat
    __hash__: NoneType
    pass
class PrintFormatKind():
    class PrintFormatKind():
        """
        Members:

          DEFAULT : Use a default format specific to RTI Connext to represent the data when converting a data sample to a string.

          XML : Use an XML format to represent the data when converting a data sample to a string.

          JSON : Use an JSON format to represent the data when converting a data sample to a string.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        DEFAULT: rti.connextdds.PrintFormatKind.PrintFormatKind
        JSON: rti.connextdds.PrintFormatKind.PrintFormatKind
        XML: rti.connextdds.PrintFormatKind.PrintFormatKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.PrintFormatKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.PrintFormatKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.PrintFormatKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.PrintFormatKind.PrintFormatKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.PrintFormatKind.PrintFormatKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.PrintFormatKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.PrintFormatKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.PrintFormatKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> PrintFormatKind.PrintFormatKind:
        """
        Retrieves the actual enumerated value.

        :type: PrintFormatKind.PrintFormatKind
        """
    DEFAULT: rti.connextdds.PrintFormatKind.PrintFormatKind
    JSON: rti.connextdds.PrintFormatKind.PrintFormatKind
    XML: rti.connextdds.PrintFormatKind.PrintFormatKind
    __hash__: NoneType
    pass
class PrintFormatProperty():
    def __init__(self, kind: rti.connextdds.PrintFormatKind = PrintFormatKind.DEFAULT, is_pretty_print: bool = True, is_enum_as_int: bool = False, is_include_root_elements: bool = True) -> None: 
        """
        Initalize PrintFormatProperty object.
        """
    @builtins.property
    def enum_as_int(self) -> bool:
        """
        Get/set the value of enum_as_int.

        :type: bool
        """
    @enum_as_int.setter
    def enum_as_int(self, arg1: bool) -> None:
        """
        Get/set the value of enum_as_int.
        """
    @builtins.property
    def include_root_elements(self) -> bool:
        """
        Get/set the value of include_root_elements.

        :type: bool
        """
    @include_root_elements.setter
    def include_root_elements(self, arg1: bool) -> None:
        """
        Get/set the value of include_root_elements.
        """
    @builtins.property
    def kind(self) -> PrintFormatKind:
        """
        Get/set the kind value.

        :type: PrintFormatKind
        """
    @kind.setter
    def kind(self, arg1: PrintFormatKind) -> None:
        """
        Get/set the kind value.
        """
    @builtins.property
    def pretty_print(self) -> bool:
        """
        Get/set the value of pretty_print.

        :type: bool
        """
    @pretty_print.setter
    def pretty_print(self, arg1: bool) -> None:
        """
        Get/set the value of pretty_print.
        """
    default: rti.connextdds.PrintFormatProperty
    json: rti.connextdds.PrintFormatProperty
    xml: rti.connextdds.PrintFormatProperty
    pass
class ProductVersion():
    def __eq__(self, arg0: rti.connextdds.ProductVersion) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates the unknown product version.
        """
    def __ne__(self, arg0: rti.connextdds.ProductVersion) -> bool: 
        """
        Test for inequality.
        """
    def __str__(self) -> str: ...
    @builtins.property
    def major_version(self) -> int:
        """
        The major product version.

        :type: int
        """
    @builtins.property
    def minor_version(self) -> int:
        """
        The minor product version.

        :type: int
        """
    @builtins.property
    def native_build_id(self) -> str:
        """
        A string with the build ID of the native Connext libraries.

        :type: str
        """
    @builtins.property
    def release_version(self) -> int:
        """
        The release letter of the product version.

        :type: int
        """
    @builtins.property
    def revision_version(self) -> int:
        """
        The revision number of product.

        :type: int
        """
    __hash__: NoneType
    current: rti.connextdds.ProductVersion
    unknown: rti.connextdds.ProductVersion
    pass
class Property():
    def __contains__(self, arg0: str) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.Property) -> bool: 
        """
        Test for equality.
        """
    def __getitem__(self, arg0: str) -> str: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an empty Property container.
        """
    @typing.overload
    def __init__(self, entries: dict, propagate: bool = False) -> None: 
        """
        Creates a Property container with entries from a dictionary of entries
        """
    @typing.overload
    def __init__(self, entries: rti.connextdds.StringPairSeq, propagate: bool = False) -> None: 
        """
        Creates a Property container with entries from a sequence of entries
        """
    def __len__(self) -> int: ...
    def __ne__(self, arg0: rti.connextdds.Property) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __setitem__(self, arg0: str, arg1: str) -> rti.connextdds.Property: ...
    @typing.overload
    def __setitem__(self, arg0: str, arg1: tuple[str, bool]) -> rti.connextdds.Property: ...
    def exists(self, key: str) -> bool: 
        """
        Returns true if a property exists.
        """
    def get(self, key: str) -> str: 
        """
        Returns the value of a property identified by a key if it exists.
        """
    def get_all(self) -> rti.connextdds.StringMap: 
        """
        Retrieves a copy of all the entries in a map.
        """
    def propagate(self, key: str) -> bool: 
        """
        Returns whether the 'propagate' attribute for a property is set or not.
        """
    def remove(self, key: str) -> bool: 
        """
        Removes the property identified by a key.
        """
    @typing.overload
    def set(self, entry: tuple[str, str], propagate: bool = False) -> rti.connextdds.Property: 
        """
        Adds or assigns a property from a pair of strings.
        """
    @typing.overload
    def set(self, key: str, value: str, propagate: bool = False) -> rti.connextdds.Property: 
        """
        Adds or assigns a property from a key and a value.
        """
    @typing.overload
    def set(self, entries: rti.connextdds.StringPairSeq, propagate: bool = False) -> rti.connextdds.Property: 
        """
        Adds a range of properties.
        """
    @typing.overload
    def set(self, entries: dict, propagate: bool = False) -> None: 
        """
        Adds a range of properties.
        """
    def size(self) -> int: 
        """
        Returns the number of properties.
        """
    def try_get(self, key: str) -> typing.Optional[str]: 
        """
        Returns the value of a property identified by a key if it exists.
        """
    __hash__: NoneType
    pass
class ProtocolVersion():
    def __eq__(self, arg0: rti.connextdds.ProtocolVersion) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an invalid protocol version.
        """
    @typing.overload
    def __init__(self, major: int, minor: int) -> None: 
        """
        Creates a version with the given major and minor values.
        """
    def __ne__(self, arg0: rti.connextdds.ProtocolVersion) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def major_version(self) -> int:
        """
        The major version number.

        :type: int
        """
    @builtins.property
    def minor_version(self) -> int:
        """
        The minor version number.

        :type: int
        """
    __hash__: NoneType
    current: rti.connextdds.ProtocolVersion
    pass
class PublicationBuiltinTopicData():
    class ContentFilter(ContentFilterBase):
        def __init__(self) -> None: ...
        def compile(self, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, old_compile_data: typing.Optional[object]) -> typing.Optional[object]: 
            """
            Compile an instance of the content filter according to the filter expression and parameters of the given data type.
            """
        def evaluate(self, compile_data: typing.Optional[object], sample: rti.connextdds.PublicationBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> bool: 
            """
            Evaluate whether the sample is passing the filter or not according to the sample content.
            """
        def finalize(self, compile_data: typing.Optional[object]) -> None: 
            """
            A previously compiled instance of the content filter is no longer in use and resources can now be cleaned up.
            """
        pass
    class ContentFilteredTopic(PublicationBuiltinTopicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.PublicationBuiltinTopicData.Topic, name: str, contentfilter: rti.connextdds.Filter) -> None: 
            """
            Create a ContentFilteredTopic with a name and Filter.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.PublicationBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast a TopicDescription to a ContentFilteredTopic.
            """
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Test for inequality.
            """
        def append_to_expression_parameter(self, index: int, extension: str) -> None: 
            """
            Append the extension to the end of parameter at the provided index, separated by a comma.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic]: 
            """
            Look up a ContentFilteredTopic by its name in the DomainParticipant.
            """
        def remove_from_expression_parameter(self, index: int, remove_term: str) -> None: 
            """
            Removes the specified term from the parameter at the provided index.
            """
        def set_filter(self, arg0: rti.connextdds.Filter) -> None: 
            """
            Set the filter.
            """
        @builtins.property
        def filter_expression(self) -> str:
            """
            Get the filter expression

            :type: str
            """
        @builtins.property
        def filter_parameters(self) -> StringSeq:
            """
            Get/set the filter parameters.

            :type: StringSeq
            """
        @filter_parameters.setter
        def filter_parameters(self, arg1: StringSeq) -> None:
            """
            Get/set the filter parameters.
            """
        @builtins.property
        def topic(self) -> PublicationBuiltinTopicData.Topic:
            """
            Get the underlying Topic.

            :type: PublicationBuiltinTopicData.Topic
            """
        __hash__: NoneType
        pass
    class ContentFilteredTopicSeq():
        def __add__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic: ...
        def __iadd__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataReader(IDataReader, IEntity, IAnyDataReader):
        class Selector():
            def __init__(self, datareader: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> None: 
                """
                Create a Selector for a DataReader to read/take based on selected conditions
                """
            def condition(self, condition: rti.connextdds.IReadCondition) -> rti.connextdds.PublicationBuiltinTopicData.DataReader.Selector: 
                """
                Select samples based on a ReadCondition.
                """
            def content(self, query: rti.connextdds.Query) -> rti.connextdds.PublicationBuiltinTopicData.DataReader.Selector: 
                """
                Select samples based on a Query.
                """
            def instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData.DataReader.Selector: 
                """
                Select a specific instance to read/take.
                """
            def max_samples(self, max: int) -> rti.connextdds.PublicationBuiltinTopicData.DataReader.Selector: 
                """
                Limit the number of samples read/taken by the Select.
                """
            def next_instance(self, previous: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData.DataReader.Selector: 
                """
                Select the instance after the specified instance to read/take.
                """
            def read(self) -> list: 
                """
                Read copies of available samples (data and info) based on the Selector settings.
                """
            def read_data(self) -> list: 
                """
                Read copies of available valid data based on the Selector settings.
                """
            def read_loaned(self) -> rti.connextdds.PublicationBuiltinTopicData.LoanedSamples: 
                """
                Take available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            def state(self, state: rti.connextdds.DataState) -> rti.connextdds.PublicationBuiltinTopicData.DataReader.Selector: 
                """
                Select samples with a specified data state.
                """
            def take(self) -> list: 
                """
                Take copies of available samples (data and info) based on the Selector settings.
                """
            def take_data(self) -> list: 
                """
                Take copies of available valid data based on the Selector settings.
                """
            def take_loaned(self) -> rti.connextdds.PublicationBuiltinTopicData.LoanedSamples: 
                """
                Read available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            pass
        def __enter__(self) -> rti.connextdds.PublicationBuiltinTopicData.DataReader: 
            """
            Enter a context for this DataReader, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataReader, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.PublicationBuiltinTopicData.Topic) -> None: 
            """
            Create a DataReader in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.PublicationBuiltinTopicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.PublicationBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in the implicit subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.PublicationBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.PublicationBuiltinTopicData.Topic) -> None: 
            """
            Create a DataReader.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.PublicationBuiltinTopicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.PublicationBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in a subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.PublicationBuiltinTopicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.PublicationBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
            """
            Get a typed DataReader from an AnyDataReader.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Get a typed DataReader from an Entity.
            """
        def __lshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.PublicationBuiltinTopicData.DataReader: 
            """
            Set the DataReaderQos for this DataReader.
            """
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.PublicationBuiltinTopicData.DataReader: 
            """
            Get the DataReaderQos from this DataReader
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Subscriber, arg1: rti.connextdds.PublicationBuiltinTopicData.TopicDescription, arg2: rti.connextdds.DataReaderQos) -> rti.connextdds.PublicationBuiltinTopicData.DataReader: ...
        def _set_related_writer_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        @typing.overload
        def acknowledge_all(self) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_all(self, arg0: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo) -> None: 
            """
            Acknowledge a single sample.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo, ack_response_data: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge a single sample with ack response data.
            """
        def close(self) -> None: 
            """
            Close this DataReader.
            """
        @staticmethod
        def find_all_by_topic(subscriber: rti.connextdds.Subscriber, topic_name: str) -> rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq: 
            """
            Retrieve all DataReaders for the given topic name in the subscriber.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.PublicationBuiltinTopicData.DataReader]: 
            """
            Find DataReader in DomainParticipant with the DataReader's name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.PublicationBuiltinTopicData.DataReader]: 
            """
            Find DataReader in Subscriber with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.PublicationBuiltinTopicData.DataReader]: 
            """
            Find DataReader in Subscriber with a topic name, returning the first found.
            """
        def is_matched_publication_alive(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            Check if a matched publication is alive.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.PublicationBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_publication_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Get the PublicationBuiltinTopicData for a publication matched to this DataReader.
            """
        def matched_publication_datareader_protocol_status(self, publication_handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReaderProtocolStatus: 
            """
            Get the DataReaderProtocolStatus for the DataReader based on the matched publication handle.
            """
        def matched_publication_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a publication matched to this DataReader.
            """
        def read(self) -> list: 
            """
            Read copies of all available samples (data and info).
            """
        def read_data(self) -> list: 
            """
            Read copies of all available valid data.
            """
        def read_loaned(self) -> rti.connextdds.PublicationBuiltinTopicData.LoanedSamples: 
            """
            Read all available samples (data and info) and return them in a loaned container.
            """
        @staticmethod
        def select(*args, **kwargs) -> typing.Any: 
            """
            Get a Selector to perform complex data selections, such as per-instance selection, content, and status filtering.
            """
        def set_listener(self, listener: rti.connextdds.PublicationBuiltinTopicData.DataReaderListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and associated event mask.
            """
        def take(self) -> list: 
            """
            Take copies of all available samples (data and info).
            """
        def take_data(self) -> list: 
            """
            Take copies of all available valid data.
            """
        def take_loaned(self) -> rti.connextdds.PublicationBuiltinTopicData.LoanedSamples: 
            """
            Take all available samples (data and info) and return them in a loaned container.
            """
        def wait_for_historical_data(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind.
            """
        def wait_for_historical_data_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind. This call is awaitable and only for use with asyncio.
            """
        @builtins.property
        def _has_matched_publications_with_related_reader(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datareader_cache_status(self) -> DataReaderCacheStatus:
            """
            Get the DataReaderCacheStatus for the DataReader.

            :type: DataReaderCacheStatus
            """
        @builtins.property
        def datareader_protocol_status(self) -> DataReaderProtocolStatus:
            """
            Get the DataReaderProtocolStatus for the DataReader.

            :type: DataReaderProtocolStatus
            """
        @builtins.property
        def default_filter_state(self) -> DataState:
            """
            Returns the filter state for the read/take operations.

            :type: DataState
            """
        @default_filter_state.setter
        def default_filter_state(self, arg1: DataState) -> None:
            """
            Returns the filter state for the read/take operations.
            """
        @builtins.property
        def listener(self) -> PublicationBuiltinTopicData.DataReaderListener:
            """
            Gets or sets the listener with StatusMask.ALL

            :type: PublicationBuiltinTopicData.DataReaderListener
            """
        @listener.setter
        def listener(self, arg1: PublicationBuiltinTopicData.DataReaderListener) -> None:
            """
            Gets or sets the listener with StatusMask.ALL
            """
        @builtins.property
        def liveliness_changed_status(self) -> LivelinessChangedStatus:
            """
            Get the LivelinessChangedStatus for this DataReader.

            :type: LivelinessChangedStatus
            """
        @builtins.property
        def matched_publications(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched publication handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def qos(self) -> DataReaderQos:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.

            :type: DataReaderQos
            """
        @qos.setter
        def qos(self, arg1: DataReaderQos) -> None:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.
            """
        @builtins.property
        def requested_deadline_missed_status(self) -> RequestedDeadlineMissedStatus:
            """
            Get the RequestedDeadlineMissed status for the DataReader

            :type: RequestedDeadlineMissedStatus
            """
        @builtins.property
        def requested_incompatible_qos_status(self) -> RequestedIncompatibleQosStatus:
            """
            Get the RequestedIncompatibleQosStatus for the DataReader.

            :type: RequestedIncompatibleQosStatus
            """
        @builtins.property
        def sample_lost_status(self) -> SampleLostStatus:
            """
            Get the SampleLostStatus for the DataReader.

            :type: SampleLostStatus
            """
        @builtins.property
        def sample_rejected_status(self) -> SampleRejectedStatus:
            """
            Get the SampleRejectedStatus for the DataReader.

            :type: SampleRejectedStatus
            """
        @builtins.property
        def subscriber(self) -> Subscriber:
            """
            Returns the parent Subscriber of the DataReader.

            :type: Subscriber
            """
        @builtins.property
        def subscription_matched_status(self) -> SubscriptionMatchedStatus:
            """
            Get the SubscriptionMatchedStatus for the DataReader.

            :type: SubscriptionMatchedStatus
            """
        @builtins.property
        def topic_description(self) -> PublicationBuiltinTopicData.TopicDescription:
            """
            Returns the TopicDescription associated with the DataReader.

            :type: PublicationBuiltinTopicData.TopicDescription
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataReader.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name associated with this DataReader.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataReaderListener():
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class DataReaderSeq():
        def __add__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq) -> rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.DataReader: ...
        def __iadd__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq) -> rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.PublicationBuiltinTopicData.DataReader]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq: ...
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.PublicationBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.PublicationBuiltinTopicData.DataReader: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.PublicationBuiltinTopicData.DataReader: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataWriter(IEntity, IAnyDataWriter):
        def __enter__(self) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Enter a context for this DataWriter, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataWriter, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.PublicationBuiltinTopicData.Topic) -> None: 
            """
            Creates a DataWriter in the implicit publisher with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.PublicationBuiltinTopicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.PublicationBuiltinTopicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in the implicit publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.PublicationBuiltinTopicData.Topic) -> None: 
            """
            Creates a DataWriter in a publisher with default QoS.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.PublicationBuiltinTopicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.PublicationBuiltinTopicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in a publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
            """
            Create a typed DataWriter from an AnyDataWriter.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Create a typed DataWriter from an Entity.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Sets the DataWriterQos.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Writes a paired sample with a timestamp.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.InstanceHandle]) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Writes a paired sample with an instance handle.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Writes a sequence of pairs of samples with timestamps.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataSeq) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Writes a sequence of samples.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.PublicationBuiltinTopicData) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Writes a sample.
            """
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Get the DataWriterQos.
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Publisher, arg1: rti.connextdds.PublicationBuiltinTopicData.Topic, arg2: rti.connextdds.DataWriterQos) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: ...
        def _set_related_reader_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        def _wait_for_sample_acknowledgment(self, sample_id: rti.connextdds.SampleIdentity, timeout: rti.connextdds.Duration) -> None: 
            """
            Wait for a sample to be acknowledged by the application.
            """
        def assert_liveliness(self) -> None: 
            """
            Manually asserts the liveliness of the DataWriter.
            """
        def close(self) -> None: 
            """
            Close this DataWriter.
            """
        def create_data(self) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Create data of the writer's associated type and initialize it.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Dispose an instance with params.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.PublicationBuiltinTopicData) -> object: 
            """
            Dispose the instance associated with key_holder.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.PublicationBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose the instance associated with key_holder using a timestamp
            """
        @typing.overload
        def dispose_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Dispose an instance with params.
            """
        @staticmethod
        def find_all_by_topic(publisher: rti.connextdds.Publisher, topic_name: str) -> rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq: 
            """
            Retrieve all DataWriters for the given topic name in the publisher.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.PublicationBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in DomainParticipant with the provided name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.PublicationBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in Publisher with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.PublicationBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in publisher with a topic name, returning the first found.
            """
        def flush(self) -> None: 
            """
            Flushes the batch in progress in the context of thecalling thread.
            """
        def is_matched_subscription_active(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            A boolean indicating whether or not the matched subscription is active.
            """
        def is_sample_app_acknowledged(self, sample_id: rti.connextdds.SampleIdentity) -> bool: 
            """
            Indicates if a sample is considered application-acknowledged.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.PublicationBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_subscription_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Get the SubscriptionBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription handle.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, locator: rti.connextdds.Locator) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription locator.
            """
        def matched_subscription_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.PublicationBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.PublicationBuiltinTopicData, timestamp: rti.connextdds.Time) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance and specified the timestamp.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.PublicationBuiltinTopicData, params: rti.connextdds.WriteParams) -> rti.connextdds.InstanceHandle: 
            """
            Registers instance with parameters.
            """
        def set_listener(self, listener: rti.connextdds.PublicationBuiltinTopicData.DataWriterListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask for the DataWriter.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Unregister an instance with parameters.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.PublicationBuiltinTopicData) -> object: 
            """
            Unregister the instance associated with key_holder.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.PublicationBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister the instance associate with key_holder using a timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Unregister an instance with parameters.
            """
        def wait_for_acknowledgments(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Blocks the calling thread until all data written by a reliable DataWriter is acknowledged or until the timeout expires.
            """
        def wait_for_asynchronous_publishing(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            This operation blocks the calling thread (up to max_wait) until all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        def wait_for_asynchronous_publishing_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            This function is awaitable until either a timeout of max_wait or all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.This function works with asyncio.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        @typing.overload
        def write(self, samples: rti.connextdds.PublicationBuiltinTopicDataSeq) -> None: 
            """
            Write a sequence of samples.
            """
        @typing.overload
        def write(self, samples: rti.connextdds.PublicationBuiltinTopicDataSeq, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sequence of samples with a timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.PublicationBuiltinTopicData) -> None: 
            """
            Write a sample.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.PublicationBuiltinTopicData, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with a specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.PublicationBuiltinTopicData, handle: rti.connextdds.InstanceHandle) -> None: 
            """
            Write a sample with an instance handle.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.PublicationBuiltinTopicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with an instance handle and specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.PublicationBuiltinTopicData, params: rti.connextdds.WriteParams) -> None: 
            """
            Write with advanced parameters.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.PublicationBuiltinTopicData) -> object: 
            """
            Write a sample. This method is awaitable and is only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.PublicationBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with a specified timestamp. This methods is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.PublicationBuiltinTopicData, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Write a sample with an instance handle. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.PublicationBuiltinTopicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with an instance handle and specified timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.PublicationBuiltinTopicDataSeq) -> object: 
            """
            Write a sequence of samples. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.PublicationBuiltinTopicDataSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.PublicationBuiltinTopicDataSeq, handles: rti.connextdds.InstanceHandleSeq) -> object: 
            """
            Write a sequence of samples with their instance handles. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.PublicationBuiltinTopicDataSeq, handles: rti.connextdds.InstanceHandleSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with their instance handles and a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.PublicationBuiltinTopicData, params: rti.connextdds.WriteParams) -> object: 
            """
            Write with advanced parameters.
            """
        @builtins.property
        def _has_matched_subscriptions_with_related_writer(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datawriter_cache_status(self) -> DataWriterCacheStatus:
            """
            Get a copy of the cache status for this writer.

            :type: DataWriterCacheStatus
            """
        @builtins.property
        def datawriter_protocol_status(self) -> DataWriterProtocolStatus:
            """
            Get a copy of the protocol status for this writer.

            :type: DataWriterProtocolStatus
            """
        @builtins.property
        def listener(self) -> PublicationBuiltinTopicData.DataWriterListener:
            """
            Get the listener associated with the DataWriter or set the listener.

            :type: PublicationBuiltinTopicData.DataWriterListener
            """
        @listener.setter
        def listener(self, arg1: PublicationBuiltinTopicData.DataWriterListener) -> None:
            """
            Get the listener associated with the DataWriter or set the listener.
            """
        @builtins.property
        def liveliness_lost_status(self) -> LivelinessLostStatus:
            """
            Get a copy of the LivelinessLostStatus.

            :type: LivelinessLostStatus
            """
        @builtins.property
        def matched_subscriptions(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched subscription handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def matched_subscriptions_locators(self) -> LocatorSeq:
            """
            The locators used to communicate with matched DataReaders.

            :type: LocatorSeq
            """
        @builtins.property
        def offered_deadline_missed_status(self) -> OfferedDeadlineMissedStatus:
            """
            Get a copy of the OfferedDeadlineMissedStatus.

            :type: OfferedDeadlineMissedStatus
            """
        @builtins.property
        def offered_incompatible_qos_status(self) -> OfferedIncompatibleQosStatus:
            """
            Get a copy of the OfferedIncompatibleQosStatus

            :type: OfferedIncompatibleQosStatus
            """
        @builtins.property
        def publication_matched_status(self) -> PublicationMatchedStatus:
            """
            Get a copy of the PublicationMatchedStatus

            :type: PublicationMatchedStatus
            """
        @builtins.property
        def publisher(self) -> Publisher:
            """
            Get the Publisher that owns this DataWriter.

            :type: Publisher
            """
        @builtins.property
        def qos(self) -> DataWriterQos:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.

            :type: DataWriterQos
            """
        @qos.setter
        def qos(self, arg1: DataWriterQos) -> None:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.
            """
        @builtins.property
        def reliable_reader_activity_changed_status(self) -> ReliableReaderActivityChangedStatus:
            """
            Get a copy of the reliable reader activity changed status for this writer.

            :type: ReliableReaderActivityChangedStatus
            """
        @builtins.property
        def reliable_writer_cache_changed_status(self) -> ReliableWriterCacheChangedStatus:
            """
            Get a copy of the reliable cache status for this writer.

            :type: ReliableWriterCacheChangedStatus
            """
        @builtins.property
        def service_request_accepted_status(self) -> ServiceRequestAcceptedStatus:
            """
            Get a copy of the service request accepted status for this writer.

            :type: ServiceRequestAcceptedStatus
            """
        @builtins.property
        def topic(self) -> PublicationBuiltinTopicData.Topic:
            """
            Get the Topic object associated with this DataWriter.

            :type: PublicationBuiltinTopicData.Topic
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataWriter.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name for the topic object associated with this DataWriter.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataWriterListener():
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class DataWriterSeq():
        def __add__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq) -> rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.PublicationBuiltinTopicData.DataWriter) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: ...
        def __iadd__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq) -> rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.PublicationBuiltinTopicData.DataWriter]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq: ...
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.PublicationBuiltinTopicData.DataWriter) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.PublicationBuiltinTopicData.DataWriter) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.PublicationBuiltinTopicData.DataWriter) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.PublicationBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.PublicationBuiltinTopicData.DataWriter) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.PublicationBuiltinTopicData.DataWriter: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.PublicationBuiltinTopicData.DataWriter) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ITopicDescription(IEntity):
        @builtins.property
        def name(self) -> str:
            """
            The name of the entity conforming to the ITopicDescription interface.

            :type: str
            """
        @builtins.property
        def participant(self) -> DomainParticipant:
            """
            The parent DomainParticipant.

            :type: DomainParticipant
            """
        @builtins.property
        def type_name(self) -> str:
            """
            The name of the associated type.

            :type: str
            """
        pass
    class LoanedSample():
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, data: rti.connextdds.PublicationBuiltinTopicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct LoanedSample with data and info.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> PublicationBuiltinTopicData:
            """
            Get the data associated with the sample.

            :type: PublicationBuiltinTopicData
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        pass
    class LoanedSamples():
        def __enter__(self) -> rti.connextdds.PublicationBuiltinTopicData.LoanedSamples: 
            """
            Enter a context for the loaned samples, loan returned on context exit.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for the loaned samples, returning the resources.
            """
        def __getitem__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.LoanedSample: 
            """
            Access a LoanedSample object in an array-like syntax
            """
        def __init__(self) -> None: 
            """
            Create an empty LoanedSamples object.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.PublicationBuiltinTopicData.LoanedSample]: ...
        def __len__(self) -> int: 
            """
            Get the number of samples in the loan.
            """
        def return_loan(self) -> None: 
            """
            Returns the loan to the DataReader.
            """
        @builtins.property
        def length(self) -> int:
            """
            Get the number of samples in the loan.

            :type: int
            """
        pass
    class NoOpDataReaderListener(PublicationBuiltinTopicData.DataReaderListener):
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class NoOpDataWriterListener(PublicationBuiltinTopicData.DataWriterListener):
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.PublicationBuiltinTopicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class NoOpTopicListener(PublicationBuiltinTopicData.TopicListener):
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.PublicationBuiltinTopicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class Sample():
        @typing.overload
        def __init__(self, data: rti.connextdds.PublicationBuiltinTopicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct Sample with data and info.
            """
        @typing.overload
        def __init__(self, sample: rti.connextdds.PublicationBuiltinTopicData.Sample) -> None: 
            """
            Copy constructor.
            """
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, loaned_sample: rti.connextdds.PublicationBuiltinTopicData.LoanedSample) -> None: 
            """
            Construct a sample with a loaned sample.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> PublicationBuiltinTopicData:
            """
            The data associated with the sample.

            :type: PublicationBuiltinTopicData
            """
        @data.setter
        def data(self, arg1: PublicationBuiltinTopicData) -> None:
            """
            The data associated with the sample.
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        @info.setter
        def info(self, arg1: SampleInfo) -> None:
            """
            Get the info associated with the sample.
            """
        pass
    class SharedSamples():
        def __getitem__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.LoanedSample: 
            """
            Get the sample at the specified index.
            """
        def __init__(self, loaned_samples: rti.connextdds.PublicationBuiltinTopicData.LoanedSamples) -> None: 
            """
            Constructs an instance of SharedSamples, removing ownership of the loan from the Loaned Samples.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.PublicationBuiltinTopicData.LoanedSample]: 
            """
            Make a sample iterator
            """
        def __len__(self) -> int: 
            """
            Returns the number of samples.
            """
        pass
    class Topic(PublicationBuiltinTopicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.Topic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast an Entity to a Topic.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.PublicationBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast an ITopicDescription to a Topic.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
            """
            Create a typed Topic from an AnyTopic.
            """
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.Topic) -> bool: 
            """
            Test for inequality.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.PublicationBuiltinTopicData.Topic]: 
            """
            Look up a Topic by its name in the DomainParticipant.
            """
        def set_listener(self, listener: rti.connextdds.PublicationBuiltinTopicData.TopicListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask.
            """
        @builtins.property
        def inconsistent_topic_status(self) -> InconsistentTopicStatus:
            """
            Get a copy of the current InconsistentTopicStatus for this Topic.

            :type: InconsistentTopicStatus
            """
        @builtins.property
        def listener(self) -> PublicationBuiltinTopicData.TopicListener:
            """
            The listener.

            :type: PublicationBuiltinTopicData.TopicListener
            """
        @listener.setter
        def listener(self, arg1: PublicationBuiltinTopicData.TopicListener) -> None:
            """
            The listener.
            """
        @builtins.property
        def qos(self) -> TopicQos:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.

            :type: TopicQos
            """
        @qos.setter
        def qos(self, arg1: TopicQos) -> None:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.
            """
        __hash__: NoneType
        pass
    class TopicDescription(PublicationBuiltinTopicData.ITopicDescription, IEntity):
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.TopicDescription) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.PublicationBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.TopicDescription) -> bool: 
            """
            Test for inequality.
            """
        __hash__: NoneType
        pass
    class TopicListener():
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.PublicationBuiltinTopicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class TopicSeq():
        def __add__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.TopicSeq) -> rti.connextdds.PublicationBuiltinTopicData.TopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.PublicationBuiltinTopicData.Topic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.TopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.PublicationBuiltinTopicData.TopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.Topic: ...
        def __iadd__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.TopicSeq) -> rti.connextdds.PublicationBuiltinTopicData.TopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.TopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.TopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.PublicationBuiltinTopicData.Topic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.TopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData.TopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData.TopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.PublicationBuiltinTopicData.Topic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.PublicationBuiltinTopicData.TopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.PublicationBuiltinTopicData.Topic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.PublicationBuiltinTopicData.Topic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.PublicationBuiltinTopicData.TopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.PublicationBuiltinTopicData.Topic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.PublicationBuiltinTopicData.Topic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.PublicationBuiltinTopicData.Topic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.PublicationBuiltinTopicData.Topic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ValidLoanedSamples():
        def __enter__(self) -> rti.connextdds.PublicationBuiltinTopicData.ValidLoanedSamples: ...
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.PublicationBuiltinTopicData.LoanedSample]: ...
        pass
    class WriterContentFilter(PublicationBuiltinTopicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def writer_attach(self) -> typing.Optional[object]: 
            """
            A writer-side filtering API to create some state that can facilitate filtering on the writer side.
            """
        def writer_compile(self, writer_filter_data: typing.Optional[object], property: rti.connextdds.ExpressionProperty, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_detach(self, writer_filter_data: typing.Optional[object]) -> None: 
            """
            A writer-side filtering API to clean up a previously created state using writer_attach.
            """
        def writer_evaluate(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.PublicationBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> rti.connextdds.CookieVector: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_finalize(self, writer_filter_data: typing.Optional[object], cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to clean up a previously compiled instance of the content filter.
            """
        def writer_return_loan(self, writer_filter_data: typing.Optional[object], cookies: rti.connextdds.CookieVector) -> None: 
            """
            A writer-side filtering API to return the loan on the list of DataReaders returned by writer_evaluate.
            """
        pass
    class WriterContentFilterHelper(PublicationBuiltinTopicData.WriterContentFilter, PublicationBuiltinTopicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def add_cookie(self, cookie: rti.connextdds.Cookie) -> None: 
            """
            A helper function which will add a Cookie to the Cookie sequence that is then returned by the writer_evaluate function.
            """
        def writer_evaluate_helper(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.PublicationBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        pass
    def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicData) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default PublicationBuiltinTopicData.
        """
    def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicData) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def data_tag(self) -> DataTag:
        """
        The DataTag policy of the corresponding DataWriter.

        :type: DataTag
        """
    @builtins.property
    def deadline(self) -> Deadline:
        """
        The Deadline policy of the corresponding DataWriter.

        :type: Deadline
        """
    @builtins.property
    def destination_order(self) -> DestinationOrder:
        """
        The DestinationOrder policy of the corresponding DataWriter.

        :type: DestinationOrder
        """
    @builtins.property
    def disable_positive_acks(self) -> bool:
        """
        See whether or not a matching DataReader will send positive acknowledgments for reliability.

        :type: bool
        """
    @builtins.property
    def durability(self) -> Durability:
        """
        The Durability policy of the corresponding DataWriter.

        :type: Durability
        """
    @builtins.property
    def durability_service(self) -> DurabilityService:
        """
        The DurabilityService policy of the corresponding DataWriter.

        :type: DurabilityService
        """
    @builtins.property
    def group_data(self) -> GroupData:
        """
        The GroupData policy of the corresponding DataWriter's Publisher.

        :type: GroupData
        """
    @builtins.property
    def key(self) -> BuiltinTopicKey:
        """
        The DCPS key to distinguish entries.

        :type: BuiltinTopicKey
        """
    @builtins.property
    def latency_budget(self) -> LatencyBudget:
        """
        The LatencyBudget policy of the corresponding DataWriter.

        :type: LatencyBudget
        """
    @builtins.property
    def lifespan(self) -> Lifespan:
        """
        The Lifespan policy of the corresponding DataWriter.

        :type: Lifespan
        """
    @builtins.property
    def liveliness(self) -> Liveliness:
        """
        The Liveliness policy of the corresponding DataWriter.

        :type: Liveliness
        """
    @builtins.property
    def locator_filter(self) -> LocatorFilter:
        """
        The locator filters of the corresponding DataWriter.

        :type: LocatorFilter
        """
    @builtins.property
    def ownership(self) -> Ownership:
        """
        The Ownership policy of the corresponding DataWriter.

        :type: Ownership
        """
    @builtins.property
    def ownership_strength(self) -> OwnershipStrength:
        """
        The OwnershipStrength policy of the corresponding DataWriter.

        :type: OwnershipStrength
        """
    @builtins.property
    def participant_key(self) -> BuiltinTopicKey:
        """
        The DCPS key of the DomainParticipant to which the DataWriter belongs.

        :type: BuiltinTopicKey
        """
    @builtins.property
    def partition(self) -> Partition:
        """
        The Partition policy of the corresponding DataWriter's Publisher.

        :type: Partition
        """
    @builtins.property
    def presentation(self) -> Presentation:
        """
        The Presentation policy of the corresponding DataWriter's Publisher.

        :type: Presentation
        """
    @builtins.property
    def product_version(self) -> ProductVersion:
        """
        The current version for RTI Connext.

        :type: ProductVersion
        """
    @builtins.property
    def property(self) -> Property:
        """
        The propagated name-value properties of the corresponding DataWriter.

        :type: Property
        """
    @builtins.property
    def publication_name(self) -> EntityName:
        """
        The publication name and role name.

        :type: EntityName
        """
    @builtins.property
    def publisher_key(self) -> BuiltinTopicKey:
        """
        The DCPS key of the Publisher to which the DataWriter belongs.

        :type: BuiltinTopicKey
        """
    @builtins.property
    def reliability(self) -> Reliability:
        """
        The Reliability policy of the corresponding DataWriter.

        :type: Reliability
        """
    @builtins.property
    def representation(self) -> DataRepresentation:
        """
        The Representation policy of the corresponding DataWriter.

        :type: DataRepresentation
        """
    @builtins.property
    def rtps_protocol_version(self) -> ProtocolVersion:
        """
        The version number of the RTPS wire protocol used.

        :type: ProtocolVersion
        """
    @builtins.property
    def rtps_vendor_id(self) -> VendorId:
        """
        The ID of the vendor implementing the RTPS wire protocol.

        :type: VendorId
        """
    @builtins.property
    def service(self) -> Service:
        """
        The Service policy

        :type: Service
        """
    @builtins.property
    def topic_data(self) -> TopicData:
        """
        The TopicData policy of the corresponding DataWriter's Topic.

        :type: TopicData
        """
    @builtins.property
    def topic_name(self) -> str:
        """
        The name of the related Topic.

        :type: str
        """
    @builtins.property
    def type(self) -> typing.Optional[object]:
        """
        The type.

        :type: typing.Optional[object]
        """
    @builtins.property
    def type_name(self) -> str:
        """
        The name of the type attached to the Topic.

        :type: str
        """
    @builtins.property
    def unicast_locators(self) -> LocatorVector:
        """
        The custom unicast locators that the endpoint can specify.

        :type: LocatorVector
        """
    @builtins.property
    def user_data(self) -> UserData:
        """
        The UserData policy of the corresponding DataWriter.

        :type: UserData
        """
    @builtins.property
    def virtual_guid(self) -> Guid:
        """
        The virtual Guid associated to the DataWriter.

        :type: Guid
        """
    __hash__: NoneType
    builtin_topic_name: str
    pass
class PublicationBuiltinTopicDataSeq():
    def __add__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataSeq) -> rti.connextdds.PublicationBuiltinTopicDataSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.PublicationBuiltinTopicData) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.PublicationBuiltinTopicDataSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicData: ...
    def __iadd__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataSeq) -> rti.connextdds.PublicationBuiltinTopicDataSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicDataSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.PublicationBuiltinTopicData]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicDataSeq: ...
    def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicDataSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.PublicationBuiltinTopicData) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.PublicationBuiltinTopicDataSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.PublicationBuiltinTopicData) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.PublicationBuiltinTopicData) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.PublicationBuiltinTopicDataSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.PublicationBuiltinTopicData) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.PublicationBuiltinTopicData: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.PublicationBuiltinTopicData: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.PublicationBuiltinTopicData) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class PublicationBuiltinTopicDataTimestampedSeq():
    def __add__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq) -> rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]: ...
    def __iadd__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq) -> rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq: ...
    def __ne__(self, arg0: rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.PublicationBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: tuple[rti.connextdds.PublicationBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class PublicationMatchedStatus():
    @builtins.property
    def current_count(self) -> int:
        """
        The number of DataReaders that are currently matched with this DataWriter.

        :type: int
        """
    @builtins.property
    def current_count_change(self) -> int:
        """
        The delta for the current count since the last time the listener fired or the status was read.

        :type: int
        """
    @builtins.property
    def current_count_peak(self) -> int:
        """
        The highest value that the current count has reached.

        :type: int
        """
    @builtins.property
    def last_subscription_handle(self) -> InstanceHandle:
        """
        A handle to the DataReader that caused the most recent change to to this status.

        :type: InstanceHandle
        """
    @builtins.property
    def total_count(self) -> int:
        """
        Total count of times the DataWriter matched with a DataReader.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta in the total count since the last time the listener fired or the status was read.

        :type: int
        """
    pass
class PublishMode():
    def __eq__(self, arg0: rti.connextdds.PublishMode) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates a PublishMode qos policy of synchronous kind.
        """
    def __ne__(self, arg0: rti.connextdds.PublishMode) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    @typing.overload
    def asynchronous() -> rti.connextdds.PublishMode: 
        """
        Creates a PublishMode qos policy of asynchronous kind with default flow controller and undefined priority.
        """
    @staticmethod
    @typing.overload
    def asynchronous(flow_controller_name: str) -> rti.connextdds.PublishMode: 
        """
        Creates a PublishMode qos policy of asynchronous kind with a specific flow controller and undefined priority.
        """
    @staticmethod
    @typing.overload
    def asynchronous(flow_controller_name: str, priority: int) -> rti.connextdds.PublishMode: 
        """
        Creates a PublishMode qos policy of asynchronous kind with specific flow controller and priority.
        """
    @builtins.property
    def flow_controller_name(self) -> str:
        """
        The flow controller name associated to a DataWriter.

        :type: str
        """
    @flow_controller_name.setter
    def flow_controller_name(self, arg1: str) -> None:
        """
        The flow controller name associated to a DataWriter.
        """
    @builtins.property
    def kind(self) -> PublishModeKind:
        """
        The publish mode (synchronous or asynchronous) for a DataWriter.

        :type: PublishModeKind
        """
    @kind.setter
    def kind(self, arg1: PublishModeKind) -> None:
        """
        The publish mode (synchronous or asynchronous) for a DataWriter.
        """
    @builtins.property
    def priority(self) -> int:
        """
        The priority of all samples written by a DataWriter.

        :type: int
        """
    @priority.setter
    def priority(self, arg1: int) -> None:
        """
        The priority of all samples written by a DataWriter.
        """
    PUBLICATION_PRIORITY_UNDEFINED: int
    __hash__: NoneType
    synchronous: rti.connextdds.PublishMode
    pass
class PublishModeKind():
    class PublishModeKind():
        """
        Members:

          SYNCHRONOUS : Indicates to send data synchronously.

        If DataWriterProtocol.push_on_write is true, data is sent immediately in the context of DataWriter.write().

        As data is sent immediately in the context of the user thread, no flow control is applied.

          ASYNCHRONOUS : Indicates to send data asynchronously.

        Configures the DataWriter to delegate the task of data transmission to a separate publishing thread. The DataWriter.write() call does not send the data, but instead schedules the data to be sent later by its associated Publisher.

        Each Publisher uses its dedicated publishing thread (AsynchronousPublisher) to send data for all its asynchronous DataWriters. For each asynchronous DataWriter, the associated FlowController determines when the publishing thread is allowed to send the data.

        DataWriter.wait_for_asynchronous_publishing and Publisher.wait_for_asynchronous_publishing enable you to determine when the data has actually been sent.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        ASYNCHRONOUS: rti.connextdds.PublishModeKind.PublishModeKind
        SYNCHRONOUS: rti.connextdds.PublishModeKind.PublishModeKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.PublishModeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.PublishModeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.PublishModeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.PublishModeKind.PublishModeKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.PublishModeKind.PublishModeKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.PublishModeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.PublishModeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.PublishModeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> PublishModeKind.PublishModeKind:
        """
        Retrieves the actual enumerated value.

        :type: PublishModeKind.PublishModeKind
        """
    ASYNCHRONOUS: rti.connextdds.PublishModeKind.PublishModeKind
    SYNCHRONOUS: rti.connextdds.PublishModeKind.PublishModeKind
    __hash__: NoneType
    pass
class Publisher(IEntity):
    def __eq__(self, arg0: rti.connextdds.Publisher) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, participant: rti.connextdds.DomainParticipant) -> None: 
        """
        Create a publisher.
        """
    @typing.overload
    def __init__(self, participant: rti.connextdds.DomainParticipant, qos: rti.connextdds.PublisherQos, listener: rti.connextdds.PublisherListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Create a Publisher with the desired QoS policies and specified listener
        """
    @typing.overload
    def __init__(self, entity: rti.connextdds.IEntity) -> None: 
        """
        Cast an Entity to a Publisher.
        """
    def __lshift__(self, arg0: rti.connextdds.PublisherQos) -> rti.connextdds.Publisher: 
        """
        Set the PublisherQos.
        """
    def __ne__(self, arg0: rti.connextdds.Publisher) -> bool: 
        """
        Test for inequality.
        """
    def __rshift__(self, arg0: rti.connextdds.PublisherQos) -> rti.connextdds.Publisher: 
        """
        Copy the PublisherQos.
        """
    def find_datawriter(self, name: str) -> typing.Optional[rti.connextdds.AnyDataWriter]: 
        """
        Find a DataWriter in this Publisher by its name.
        """
    def find_datawriter_by_topic_name(self, topic_name: str) -> typing.Optional[rti.connextdds.AnyDataWriter]: 
        """
        Find a DataWriter in this Publisher by its topic name. If more than one exists for this Topic, the first one found is returned.
        """
    def find_datawriters(self) -> rti.connextdds.AnyDataWriterSeq: 
        """
        Find all DataWriters in the Publisher.
        """
    def set_listener(self, listener: rti.connextdds.PublisherListener, event_mask: rti.connextdds.StatusMask) -> None: 
        """
        Bind the listener and event mask to the Publisher.
        """
    def wait_for_acknowledgments(self, max_wait: rti.connextdds.Duration) -> None: 
        """
        Blocks until all data written by this Publisher's reliable DataWriters is acknowledged or the timeout expires.
        """
    def wait_for_asynchronous_publishing(self, max_wait: rti.connextdds.Duration) -> None: 
        """
        Blocks until asynchronous sending is complete or timeout expires.
        """
    @builtins.property
    def default_datawriter_qos(self) -> DataWriterQos:
        """
        The default DataWriterQos.

        This property's getter returns a deep copy.

        :type: DataWriterQos
        """
    @default_datawriter_qos.setter
    def default_datawriter_qos(self, arg1: DataWriterQos) -> None:
        """
        The default DataWriterQos.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def listener(self) -> PublisherListener:
        """
        Get/set the listener.

        :type: PublisherListener
        """
    @listener.setter
    def listener(self, arg1: PublisherListener) -> None:
        """
        Get/set the listener.
        """
    @builtins.property
    def participant(self) -> DomainParticipant:
        """
        Get the parent DomainParticipant of this Publisher.

        :type: DomainParticipant
        """
    @builtins.property
    def qos(self) -> PublisherQos:
        """
        The PublisherQos for this Publisher.

        This property's getter returns a deep copy.

        :type: PublisherQos
        """
    @qos.setter
    def qos(self, arg1: PublisherQos) -> None:
        """
        The PublisherQos for this Publisher.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class DomainParticipantListener(PublisherListener, AnyDataWriterListener, SubscriberListener, AnyDataReaderListener, AnyTopicListener):
    def __init__(self) -> None: ...
    def on_invalid_local_identity_status_advance_notice(self, arg0: rti.connextdds.DomainParticipant, arg1: rti.connextdds.InvalidLocalIdentityAdvanceNoticeStatus) -> None: 
        """
        On invalid local identity status advance notice callback
        """
    pass
class PublisherQos():
    def __eq__(self, arg0: rti.connextdds.PublisherQos) -> bool: 
        """
        Test for equality
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a PublisherQos with the default value for each policy.
        """
    @typing.overload
    def __init__(self, publisher: rti.connextdds.Publisher) -> None: 
        """
        Create a PublisherQos with the same settings as those applied to the provided Publisher object.
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.PublisherQos) -> None: 
        """
        Create a copy of a PublisherQos object.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Presentation) -> rti.connextdds.PublisherQos: 
        """
        Set the PresentationQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Partition) -> rti.connextdds.PublisherQos: 
        """
        Set the PartitionQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.GroupData) -> rti.connextdds.PublisherQos: 
        """
        Set the GroupDataQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityFactory) -> rti.connextdds.PublisherQos: 
        """
        Set the EntityFactoryQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.AsynchronousPublisher) -> rti.connextdds.PublisherQos: 
        """
        Set the AsynchronousPublisherQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.PublisherQos: 
        """
        Set the EntityNameQoS.
        """
    def __ne__(self, arg0: rti.connextdds.PublisherQos) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Presentation) -> rti.connextdds.PublisherQos: 
        """
        Get the PresentationQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Partition) -> rti.connextdds.PublisherQos: 
        """
        Get the PartitionQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.GroupData) -> rti.connextdds.PublisherQos: 
        """
        Get the GroupDataQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityFactory) -> rti.connextdds.PublisherQos: 
        """
        Get the EntityFactoryQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.AsynchronousPublisher) -> rti.connextdds.PublisherQos: 
        """
        Get the AsynchronousPublisherQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.PublisherQos: 
        """
        Get the EntityNameQoS.
        """
    def __str__(self) -> str: ...
    def to_string(self, format: rti.connextdds.QosPrintFormat = QosPrintFormat(), base: typing.Optional[rti.connextdds.PublisherQos] = None, print_all: bool = False) -> str: 
        """
        Convert QoS to string based on params.
        """
    @builtins.property
    def asynchronous_publisher(self) -> AsynchronousPublisher:
        """
        Get/set AsynchronousPublisher QoS.

        :type: AsynchronousPublisher
        """
    @asynchronous_publisher.setter
    def asynchronous_publisher(self, arg1: AsynchronousPublisher) -> None:
        """
        Get/set AsynchronousPublisher QoS.
        """
    @builtins.property
    def entity_factory(self) -> EntityFactory:
        """
        Get/set EntityFactory QoS.

        :type: EntityFactory
        """
    @entity_factory.setter
    def entity_factory(self, arg1: EntityFactory) -> None:
        """
        Get/set EntityFactory QoS.
        """
    @builtins.property
    def entity_name(self) -> EntityName:
        """
        Get/set EntityName QoS.

        :type: EntityName
        """
    @entity_name.setter
    def entity_name(self, arg1: EntityName) -> None:
        """
        Get/set EntityName QoS.
        """
    @builtins.property
    def group_data(self) -> GroupData:
        """
        Get/set GroupData QoS.

        :type: GroupData
        """
    @group_data.setter
    def group_data(self, arg1: GroupData) -> None:
        """
        Get/set GroupData QoS.
        """
    @builtins.property
    def partition(self) -> Partition:
        """
        Get/set Partition QoS.

        :type: Partition
        """
    @partition.setter
    def partition(self, arg1: Partition) -> None:
        """
        Get/set Partition QoS.
        """
    @builtins.property
    def presentation(self) -> Presentation:
        """
        Get/set Presentation QoS.

        :type: Presentation
        """
    @presentation.setter
    def presentation(self, arg1: Presentation) -> None:
        """
        Get/set Presentation QoS.
        """
    __hash__: NoneType
    pass
class PublisherSeq():
    def __add__(self, arg0: rti.connextdds.PublisherSeq) -> rti.connextdds.PublisherSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.Publisher) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.PublisherSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.PublisherSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Publisher: ...
    def __iadd__(self, arg0: rti.connextdds.PublisherSeq) -> rti.connextdds.PublisherSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.PublisherSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.PublisherSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.Publisher]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.PublisherSeq: ...
    def __ne__(self, arg0: rti.connextdds.PublisherSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.PublisherSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Publisher) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.PublisherSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.Publisher) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.Publisher) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.PublisherSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.Publisher) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.Publisher: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.Publisher: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.Publisher) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class QosPolicyCount():
    def __eq__(self, arg0: rti.connextdds.QosPolicyCount) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.QosPolicyCount) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def count(self) -> int:
        """
        The counter.

        :type: int
        """
    @builtins.property
    def policy(self) -> object:
        """
        The policy class.

        :type: object
        """
    __hash__: NoneType
    pass
class QosPolicyCountSeq():
    def __add__(self, arg0: rti.connextdds.QosPolicyCountSeq) -> rti.connextdds.QosPolicyCountSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.QosPolicyCount) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.QosPolicyCountSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.QosPolicyCountSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.QosPolicyCount: ...
    def __iadd__(self, arg0: rti.connextdds.QosPolicyCountSeq) -> rti.connextdds.QosPolicyCountSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.QosPolicyCountSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.QosPolicyCountSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.QosPolicyCount]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.QosPolicyCountSeq: ...
    def __ne__(self, arg0: rti.connextdds.QosPolicyCountSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.QosPolicyCountSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.QosPolicyCount) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.QosPolicyCountSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.QosPolicyCount) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.QosPolicyCount) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.QosPolicyCountSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.QosPolicyCount) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.QosPolicyCount: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.QosPolicyCount: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.QosPolicyCount) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class QosPrintFormat():
    def __eq__(self, arg0: rti.connextdds.QosPrintFormat) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes the properties with the default values.
        """
    @typing.overload
    def __init__(self, indent: int, private: bool, is_standalone: bool) -> None: 
        """
        Initializes the properties.
        """
    def __ne__(self, arg0: rti.connextdds.QosPrintFormat) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def indent(self) -> int:
        """
        The value of indent.

        :type: int
        """
    @indent.setter
    def indent(self, arg1: int) -> None:
        """
        The value of indent.
        """
    @builtins.property
    def is_standalone(self) -> bool:
        """
        Print XML preample toggle.

        :type: bool
        """
    @is_standalone.setter
    def is_standalone(self, arg1: bool) -> None:
        """
        Print XML preample toggle.
        """
    @builtins.property
    def print_private(self) -> bool:
        """
        Print private QoS field toggle.

        :type: bool
        """
    @print_private.setter
    def print_private(self, arg1: bool) -> None:
        """
        Print private QoS field toggle.
        """
    __hash__: NoneType
    pass
class QosProvider():
    def __eq__(self, arg0: rti.connextdds.QosProvider) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, uri: str, profile: str) -> None: 
        """
        Creates a QosProvider fetching QoS configuration from the specified URI.
        """
    @typing.overload
    def __init__(self, uri: str) -> None: 
        """
        Create a QosProvider fetching QoS configuration from the specified URI.
        """
    @typing.overload
    def __init__(self, params: rti.connextdds.QosProviderParams) -> None: 
        """
        Create a QosProvider with the specified parameters.
        """
    def __ne__(self, arg0: rti.connextdds.QosProvider) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def create_participant_from_config(self, config: str) -> rti.connextdds.DomainParticipant: 
        """
        Create a DomainParticipant given a configuration name from a description provided in an XML configuration file that has been loaded by this QosProvider with default parameters.
        """
    @typing.overload
    def create_participant_from_config(self, config: str, params: rti.connextdds.DomainParticipantConfigParams) -> rti.connextdds.DomainParticipant: 
        """
        Create a DomainParticipant given a configuration name from a description provided in an XML configuration file that has been loaded by this QosProvider.
        """
    def datareader_qos_from_profile(self, profile: str) -> rti.connextdds.DataReaderQos: 
        """
        Get the DataReaderQos from a qos profile.
        """
    def datawriter_qos_from_profile(self, profile: str) -> rti.connextdds.DataWriterQos: 
        """
        Get the DataWriterQos from a qos profile.
        """
    def get_topic_datareader_qos(self, topic_name: str) -> rti.connextdds.DataReaderQos: 
        """
        Get the DataReaderQos associated with a given Topic name.
        """
    def get_topic_datawriter_qos(self, topic_name: str) -> rti.connextdds.DataWriterQos: 
        """
        Get the DataWriterQos associated with a given Topic name.
        """
    def get_topic_name_qos(self, topic_name: str) -> rti.connextdds.TopicQos: 
        """
        Get the TopicQos associated with a given Topic name.
        """
    def load_profiles(self) -> None: 
        """
        Load the XML QoS profiles from this QosProvider.
        """
    def participant_qos_from_profile(self, profile_name: str) -> rti.connextdds.DomainParticipantQos: 
        """
        Get the DomainParticipantQos from a qos profile.
        """
    def publisher_qos_from_profile(self, profile: str) -> rti.connextdds.PublisherQos: 
        """
        Get the PublisherQos from a qos profile.
        """
    def qos_profiles(self, library: str) -> rti.connextdds.StringSeq: 
        """
        Get a list of the QoS profiles loaded the specified library of the QosProvider.
        """
    def reload_profiles(self) -> None: 
        """
        Reload the XML QoS profiles from this QosProvider.
        """
    @staticmethod
    def reset_default() -> None: 
        """
        Reset the settings of the default QosProvider.
        """
    def set_topic_datareader_qos(self, profile_name: str, topic_name: str) -> rti.connextdds.DataReaderQos: 
        """
        Set the DataReaderQos for a given Topic name.
        """
    def set_topic_datawriter_qos(self, profile_name: str, topic_name: str) -> rti.connextdds.DataWriterQos: 
        """
        Set the DataWriterQos for a given Topic name.
        """
    def set_topic_name_qos(self, profile_name: str, topic_name: str) -> rti.connextdds.TopicQos: 
        """
        Set the TopicQos for a given Topic name.
        """
    def subscriber_qos_from_profile(self, profile: str) -> rti.connextdds.SubscriberQos: 
        """
        Get the SubscriberQos from a qos profile.
        """
    def topic_qos_from_profile(self, profile_name: str) -> rti.connextdds.TopicQos: 
        """
        Get the TopicQos from a qos profile.
        """
    @typing.overload
    def type(self, library: str, name: str) -> object: 
        """
        Get a DynamicType from a type library in the QosProvider.
        """
    @typing.overload
    def type(self, name: str) -> object: 
        """
        Get a DynamicType from the QosProvider.
        """
    def unload_profiles(self) -> None: 
        """
        Unload the XML QoS profiles from this QosProvider.
        """
    @builtins.property
    def datareader_qos(self) -> DataReaderQos:
        """
        Get a copy of the DataReaderQos currently associated with the QosProvider.

        :type: DataReaderQos
        """
    @builtins.property
    def datawriter_qos(self) -> DataWriterQos:
        """
        Get a copy of the DataWriterQos currently associated with the QosProvider.

        :type: DataWriterQos
        """
    @builtins.property
    def default_library(self) -> typing.Optional[str]:
        """
        The default library associated with this QosProvider (None if not set).

        :type: typing.Optional[str]
        """
    @default_library.setter
    def default_library(self, arg1: str) -> None:
        """
        The default library associated with this QosProvider (None if not set).
        """
    @builtins.property
    def default_profile(self) -> typing.Optional[str]:
        """
        The default profile associated with this QosProvider (None if not set).

        :type: typing.Optional[str]
        """
    @default_profile.setter
    def default_profile(self, arg1: str) -> None:
        """
        The default profile associated with this QosProvider (None if not set).
        """
    @builtins.property
    def default_profile_library(self) -> typing.Optional[str]:
        """
        The library of the default profile associated with this QosProvider (None if not set).

        :type: typing.Optional[str]
        """
    @builtins.property
    def participant_qos(self) -> DomainParticipantQos:
        """
        Get a copy of the DomainParticipantQos currently associated with the QosProvider.

        :type: DomainParticipantQos
        """
    @builtins.property
    def profiles_loaded(self) -> bool:
        """
        Check if the profiles from this QosProvider have been loaded.

        :type: bool
        """
    @builtins.property
    def provider_params(self) -> QosProviderParams:
        """
        Get a copy of or set the QosProviderParams for this QosProvider.

        :type: QosProviderParams
        """
    @provider_params.setter
    def provider_params(self, arg1: QosProviderParams) -> None:
        """
        Get a copy of or set the QosProviderParams for this QosProvider.
        """
    @builtins.property
    def publisher_qos(self) -> PublisherQos:
        """
        Get a copy of the PublisherQos currently associated with the QosProvider.

        :type: PublisherQos
        """
    @builtins.property
    def qos_profile_libraries(self) -> StringSeq:
        """
        Get a list of the QoS profile libraries loaded by the QosProvider.

        :type: StringSeq
        """
    @builtins.property
    def subscriber_qos(self) -> SubscriberQos:
        """
        Get a copy of the SubscriberQos currently associated with this QosProvider.

        :type: SubscriberQos
        """
    @builtins.property
    def topic_qos(self) -> TopicQos:
        """
        Get a copy of the TopicQos currently associated with the QosProvider.

        :type: TopicQos
        """
    @builtins.property
    def type_libraries(self) -> StringSeq:
        """
        Get a list of the type libraries loaded by this QosProvider.

        :type: StringSeq
        """
    __hash__: NoneType
    default: rti.connextdds.QosProvider
    default_provider_params: rti.connextdds.QosProviderParams
    pass
class QosProviderParams():
    def __eq__(self, arg0: rti.connextdds.QosProviderParams) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a QosProviderParams with default settings.
        """
    @typing.overload
    def __init__(self, string_profile: rti.connextdds.StringSeq = [], url_profile: rti.connextdds.StringSeq = [], ignore_user_profile: bool = False, ignore_environment_profile: bool = False, ignore_resource_profile: bool = False) -> None: 
        """
        Create a QosProviderParams with the specified settings.
        """
    def __ne__(self, arg0: rti.connextdds.QosProviderParams) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def ignore_environment_profile(self) -> bool:
        """
        Choose whether or not to ignore the NDDS_QOS_PROFILES.

        :type: bool
        """
    @ignore_environment_profile.setter
    def ignore_environment_profile(self, arg1: bool) -> None:
        """
        Choose whether or not to ignore the NDDS_QOS_PROFILES.
        """
    @builtins.property
    def ignore_resource_profile(self) -> bool:
        """
        Choose whether or not to ignore NDDS_QOS_PROFILES.xml.

        :type: bool
        """
    @ignore_resource_profile.setter
    def ignore_resource_profile(self, arg1: bool) -> None:
        """
        Choose whether or not to ignore NDDS_QOS_PROFILES.xml.
        """
    @builtins.property
    def ignore_user_profile(self) -> bool:
        """
        Choose whether or not to ignore USER_QOS_PROFILES.xml.

        :type: bool
        """
    @ignore_user_profile.setter
    def ignore_user_profile(self, arg1: bool) -> None:
        """
        Choose whether or not to ignore USER_QOS_PROFILES.xml.
        """
    @builtins.property
    def string_profile(self) -> StringSeq:
        """
        Sequence of strings containing a XML document to load.

        :type: StringSeq
        """
    @string_profile.setter
    def string_profile(self, arg1: StringSeq) -> None:
        """
        Sequence of strings containing a XML document to load.
        """
    @builtins.property
    def url_profile(self) -> StringSeq:
        """
        Sequence of XML documents to load.

        :type: StringSeq
        """
    @url_profile.setter
    def url_profile(self, arg1: StringSeq) -> None:
        """
        Sequence of XML documents to load.
        """
    __hash__: NoneType
    pass
class Query():
    def __eq__(self, arg0: rti.connextdds.Query) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, reader: rti.connextdds.IDataReader, expression: str) -> None: 
        """
        Init a Query for a DataReader with an expression.
        """
    @typing.overload
    def __init__(self, reader: rti.connextdds.IDataReader, expression: str, params: rti.connextdds.StringSeq) -> None: 
        """
        Init a Query for a DataReader with an expression and parameters.
        """
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: rti.connextdds.Query) -> bool: 
        """
        Test for inequality.
        """
    def add_parameter(self, arg0: str) -> None: 
        """
        Appends a parameter.
        """
    @builtins.property
    def data_reader(self) -> AnyDataReader:
        """
        The DataReader as an AnyDataReader.

        :type: AnyDataReader
        """
    @builtins.property
    def expression(self) -> str:
        """
        The expression.

        :type: str
        """
    @builtins.property
    def name(self) -> str:
        """
        The filter name.

        :type: str
        """
    @name.setter
    def name(self, arg1: str) -> None:
        """
        The filter name.
        """
    @builtins.property
    def parameters(self) -> StringSeq:
        """
        The parameters for the expression.

        :type: StringSeq
        """
    @parameters.setter
    def parameters(self, arg1: StringSeq) -> None:
        """
        The parameters for the expression.
        """
    @builtins.property
    def parameters_length(self) -> int:
        """
        The parameter sequence length.

        :type: int
        """
    __hash__: NoneType
    pass
class QueryCondition(IReadCondition, ICondition):
    def __eq__(self, arg0: rti.connextdds.QueryCondition) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, query: rti.connextdds.Query, status: rti.connextdds.DataState) -> None: 
        """
        Create a QueryCondition.
        """
    @typing.overload
    def __init__(self, query: rti.connextdds.Query, status: rti.connextdds.DataState, handler: typing.Callable[[rti.connextdds.QueryCondition], None]) -> None: 
        """
        Create a QueryCondition.
        """
    @typing.overload
    def __init__(self, reader: rti.connextdds.Query, status: rti.connextdds.DataStateEx) -> None: 
        """
        Create a QueryCondition extended DataState.
        """
    @typing.overload
    def __init__(self, query: rti.connextdds.Query, status: rti.connextdds.DataStateEx, handler: typing.Callable[[rti.connextdds.QueryCondition], None]) -> None: 
        """
        Create a QueryCondition with extended DataState and a query.
        """
    @typing.overload
    def __init__(self, condition: rti.connextdds.ICondition) -> None: 
        """
        Cast a condition to a QueryCondition.
        """
    def __len__(self) -> int: ...
    def __ne__(self, arg0: rti.connextdds.QueryCondition) -> bool: 
        """
        Test for inequality.
        """
    def reset_handler(self) -> None: 
        """
        Resets the handler for this QueryCondition.
        """
    def set_handler(self, func: typing.Callable[[rti.connextdds.QueryCondition], None]) -> None: 
        """
        Set a handler function for this QueryCondition.
        """
    def set_handler_no_args(self, func: typing.Callable[[], None]) -> None: 
        """
        Set a handler function receiving no arguments.
        """
    @builtins.property
    def expression(self) -> str:
        """
        The expression.

        :type: str
        """
    @builtins.property
    def parameters(self) -> StringSeq:
        """
        The parameters for the expression.

        :type: StringSeq
        """
    @parameters.setter
    def parameters(self, arg1: StringSeq) -> None:
        """
        The parameters for the expression.
        """
    @builtins.property
    def parameters_length(self) -> int:
        """
        The parameter sequence length.

        :type: int
        """
    __hash__: NoneType
    pass
class Rank():
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default Rank object.
        """
    @typing.overload
    def __init__(self, sample_rank: int, generation_rank: int, absolute_generation_rank: int) -> None: 
        """
        Create a GenerationCount object with the provided disposed_count and no_writers count.
        """
    @builtins.property
    def absolute_generation(self) -> int:
        """
        Get the absolute generation rank of the sample.

        :type: int
        """
    @builtins.property
    def generation(self) -> int:
        """
        Get the generation rank of the sample.

        :type: int
        """
    @builtins.property
    def sample(self) -> int:
        """
        Get the sample rank of the sample.

        :type: int
        """
    pass
class ReadCondition(IReadCondition, ICondition):
    @typing.overload
    def __init__(self, reader: rti.connextdds.IAnyDataReader, status: rti.connextdds.DataState) -> None: 
        """
        Create a ReadCondition.
        """
    @typing.overload
    def __init__(self, reader: rti.connextdds.IAnyDataReader, status: rti.connextdds.DataStateEx) -> None: 
        """
        Create a ReadCondition extended DataState.
        """
    @typing.overload
    def __init__(self, reader: rti.connextdds.IAnyDataReader, status: rti.connextdds.DataState, handler: typing.Callable[[rti.connextdds.ReadCondition], None]) -> None: 
        """
        Create a ReadCondition with a callback.
        """
    @typing.overload
    def __init__(self, reader: rti.connextdds.IAnyDataReader, status: rti.connextdds.DataStateEx, handler: typing.Callable[[rti.connextdds.ReadCondition], None]) -> None: 
        """
        Create a ReadCondition with extended DataState and a callback.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ICondition) -> None: 
        """
        Cast a compatible Condition to a ReadCondition.
        """
    def reset_handler(self) -> None: 
        """
        Resets the handler for this ReadCondition.
        """
    def set_handler_no_args(self, func: typing.Callable[[], None]) -> None: 
        """
        Set a handler function receiving no arguments.
        """
    pass
class ReaderDataLifecycle():
    def __eq__(self, arg0: rti.connextdds.ReaderDataLifecycle) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, nowriter_delay: rti.connextdds.Duration, disposed_samples_delay: rti.connextdds.Duration) -> None: 
        """
        Creates an instance with the specified nowriter and disposed-samples purge delays.
        """
    def __ne__(self, arg0: rti.connextdds.ReaderDataLifecycle) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    def auto_purge_disposed_samples(delay: rti.connextdds.Duration) -> rti.connextdds.ReaderDataLifecycle: 
        """
        Returns a policy where only the disposed-samples purge delay is enabled with a specified duration.
        """
    @staticmethod
    def auto_purge_no_writer_samples(delay: rti.connextdds.Duration) -> rti.connextdds.ReaderDataLifecycle: 
        """
        Returns a policy where only the no-writer purge delay is enabled with a specified duration.
        """
    @builtins.property
    def autopurge_disposed_instances_delay(self) -> Duration:
        """
        Minimum duration for which the DataReader will maintain an instance once its instance_state becomes InstanceStateKind.NOT_ALIVE_DISPOSED.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @autopurge_disposed_instances_delay.setter
    def autopurge_disposed_instances_delay(self, arg1: Duration) -> None:
        """
        Minimum duration for which the DataReader will maintain an instance once its instance_state becomes InstanceStateKind.NOT_ALIVE_DISPOSED.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def autopurge_disposed_samples_delay(self) -> Duration:
        """
        Minimum duration for which the DataReader will maintain information regarding an instance once its instance_state becomes InstanceStateKind.NOT_ALIVE_DISPOSED.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @autopurge_disposed_samples_delay.setter
    def autopurge_disposed_samples_delay(self, arg1: Duration) -> None:
        """
        Minimum duration for which the DataReader will maintain information regarding an instance once its instance_state becomes InstanceStateKind.NOT_ALIVE_DISPOSED.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def autopurge_nowriter_instances_delay(self) -> Duration:
        """
        Minimum duration for which the DDSDataReader will maintain information about a received instance once its instance_state becomes DDS_NOT_ALIVE_NO_WRITERS_INSTANCE_STATE and there are no samples for the instance in the DataReader queue.

        :type: Duration
        """
    @autopurge_nowriter_instances_delay.setter
    def autopurge_nowriter_instances_delay(self, arg1: Duration) -> None:
        """
        Minimum duration for which the DDSDataReader will maintain information about a received instance once its instance_state becomes DDS_NOT_ALIVE_NO_WRITERS_INSTANCE_STATE and there are no samples for the instance in the DataReader queue.
        """
    @builtins.property
    def autopurge_nowriter_samples_delay(self) -> Duration:
        """
        Minimum duration for which the DataReader will maintain information regarding an instance once its instance_state becomes InstanceStateKind.NOT_ALIVE_NO_WRITERS.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @autopurge_nowriter_samples_delay.setter
    def autopurge_nowriter_samples_delay(self, arg1: Duration) -> None:
        """
        Minimum duration for which the DataReader will maintain information regarding an instance once its instance_state becomes InstanceStateKind.NOT_ALIVE_NO_WRITERS.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    no_auto_purge: rti.connextdds.ReaderDataLifecycle
    pass
class ReceiverPool():
    def __eq__(self, arg0: rti.connextdds.ReceiverPool) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, thread: rti.connextdds.ThreadSettings, buffer_size: int, buffer_alignment: int) -> None: 
        """
        Creates an instance with the thread settings, buffer size and buffer alignment configuration.
        """
    def __ne__(self, arg0: rti.connextdds.ReceiverPool) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def buffer_alignment(self) -> int:
        """
        The receive buffer alignment.

        :type: int
        """
    @buffer_alignment.setter
    def buffer_alignment(self, arg1: int) -> None:
        """
        The receive buffer alignment.
        """
    @builtins.property
    def buffer_size(self) -> int:
        """
        The length of the buffer used to store the incoming raw data.

        :type: int
        """
    @buffer_size.setter
    def buffer_size(self, arg1: int) -> None:
        """
        The length of the buffer used to store the incoming raw data.
        """
    @builtins.property
    def thread(self) -> ThreadSettings:
        """
        Configures the receiver pool thread(s).

        :type: ThreadSettings
        """
    @thread.setter
    def thread(self, arg1: ThreadSettings) -> None:
        """
        Configures the receiver pool thread(s).
        """
    __hash__: NoneType
    pass
class Reliability():
    def __eq__(self, arg0: rti.connextdds.Reliability) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a best-effort policy.
        """
    @typing.overload
    def __init__(self, kind: rti.connextdds.ReliabilityKind, max_blocking_time: rti.connextdds.Duration = Duration.from_milliseconds(100)) -> None: 
        """
        Creates an instance with the specified reliability kind and optionally a specific maximum blocking time.
        """
    def __ne__(self, arg0: rti.connextdds.Reliability) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    def reliable(max_blocking_time: rti.connextdds.Duration = Duration.from_milliseconds(100)) -> rti.connextdds.Reliability: 
        """
        Creates a policy with ReliabilityKind.RELIABLE and optionally a max blocking time.
        """
    @builtins.property
    def acknowledgment_kind(self) -> AcknowledgmentKind:
        """
        The kind of reliable acknowledgment.

        :type: AcknowledgmentKind
        """
    @acknowledgment_kind.setter
    def acknowledgment_kind(self, arg1: AcknowledgmentKind) -> None:
        """
        The kind of reliable acknowledgment.
        """
    @builtins.property
    def instance_state_consistency_kind(self) -> InstanceStateConsistencyKind:
        """
        Whether instance state consistency is enabled.

        :type: InstanceStateConsistencyKind
        """
    @instance_state_consistency_kind.setter
    def instance_state_consistency_kind(self, arg1: InstanceStateConsistencyKind) -> None:
        """
        Whether instance state consistency is enabled.
        """
    @builtins.property
    def kind(self) -> ReliabilityKind:
        """
        The reliability kind.

        :type: ReliabilityKind
        """
    @kind.setter
    def kind(self, arg1: ReliabilityKind) -> None:
        """
        The reliability kind.
        """
    @builtins.property
    def max_blocking_time(self) -> Duration:
        """
        The maximum time a DataWriter may block on a call to write().

        This property's getter returns a deep copy.

        :type: Duration
        """
    @max_blocking_time.setter
    def max_blocking_time(self, arg1: Duration) -> None:
        """
        The maximum time a DataWriter may block on a call to write().

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    best_effort: rti.connextdds.Reliability
    pass
class ReliabilityKind():
    class ReliabilityKind():
        """
        Members:

          BEST_EFFORT : Indicates that it is acceptable to not retry propagation of any samples.

        Presumably new values for the samples are generated often enough that it is not necessary to re-send or acknowledge any samples.

        [default] for DataReader and Topic.

          RELIABLE : Specifies that RTI Connext will attempt to deliver all samples in its history. Missed samples may be retried.

        In steady-state (no modifications communicated via the DataWriter), RTI Connext guarantees that all samples in the DataWriter history will eventually be delivered to all the DataReader objects (subject to timeouts that indicate loss of communication with a particular Subscriber).

        Outside steady state, the HISTORY and RESOURCE_LIMITS policies will determine how samples become part of the history and whether samples can be discarded from it.

        [default] for DataWriter.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        BEST_EFFORT: rti.connextdds.ReliabilityKind.ReliabilityKind
        RELIABLE: rti.connextdds.ReliabilityKind.ReliabilityKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.ReliabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.ReliabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.ReliabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ReliabilityKind.ReliabilityKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.ReliabilityKind.ReliabilityKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.ReliabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.ReliabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.ReliabilityKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> ReliabilityKind.ReliabilityKind:
        """
        Retrieves the actual enumerated value.

        :type: ReliabilityKind.ReliabilityKind
        """
    BEST_EFFORT: rti.connextdds.ReliabilityKind.ReliabilityKind
    RELIABLE: rti.connextdds.ReliabilityKind.ReliabilityKind
    __hash__: NoneType
    pass
class ReliableReaderActivityChangedStatus():
    @builtins.property
    def active_count(self) -> EventCount32:
        """
        The current number of reliable DataReaders currently matched with this reliable DataWriter.

        :type: EventCount32
        """
    @builtins.property
    def inactive_count(self) -> EventCount32:
        """
        The number of reliable DataReaders that have been dropped by this reliable DataWriter because they failed to send acknowledgments in a timely fashion.

        :type: EventCount32
        """
    @builtins.property
    def last_instance_handle(self) -> InstanceHandle:
        """
        The instance handle of the last reliable remote DataReader to be determined inactive.

        :type: InstanceHandle
        """
    pass
class ReliableWriterCacheChangedStatus():
    @builtins.property
    def empty_reliable_writer_cache(self) -> EventCount32:
        """
        The number of times the reliable DataWriters's cache of unacknowledged samples has become empty.

        :type: EventCount32
        """
    @builtins.property
    def full_reliable_writer_cache(self) -> EventCount32:
        """
        The number of times the reliable DataWriters's cache (or send window) of unacknowledged samples has become full.

        :type: EventCount32
        """
    @builtins.property
    def high_watermark_reliable_writer_cache(self) -> EventCount32:
        """
        The number of times the reliable DataWriter's cache of unacknowledged samples has risen to the high watermark.

        :type: EventCount32
        """
    @builtins.property
    def low_watermark_reliable_writer_cache(self) -> EventCount32:
        """
        The number of times the reliable DataWriter's cache of unacknowledged samples has fallen to the low watermark.

        :type: EventCount32
        """
    @builtins.property
    def replaced_unacknowledged_sample_count(self) -> int:
        """
        The number of unacknowledged samples that have been replaced in the writer's cache.

        :type: int
        """
    @builtins.property
    def unacknowledged_sample_count(self) -> int:
        """
        The current number of unacknowledged samples in the DataWriter's cache.

        :type: int
        """
    @builtins.property
    def unacknowledged_sample_count_peak(self) -> int:
        """
        The highest value that unacknowledged_sample_count has reached until now.

        :type: int
        """
    pass
class RemoteParticipantPurgeKind():
    class RemoteParticipantPurgeKind():
        """
        Members:

          LIVELINESS_BASED : [default] Maintain knowledge of the remote participant for as long as it maintains its liveliness contract.

        A participant will continue attempting communication with its peers, even if discovery communication with them is lost, as long as the remote participants maintain their liveliness. If both discovery communication and participant liveliness are lost, however, the local participant will remove all records of the remote participant and its contained endpoints, and no further data communication with them will occur until and unless they are rediscovered.

        The liveliness contract a participant promises to its peers (its "liveliness lease duration") is specified in its DiscoveryConfig.participant_liveliness_lease_duration QoS field. It maintains that contract by writing data to those other participants with a writer that has a LivelinessKind of LivelinessKind.AUTOMATIC or LivelinessKind.MANUAL_BY_PARTICIPANT and by asserting itself (at the DiscoveryConfig.participant_liveliness_assert_period) over the Simple Discovery Protocol.

          NO_PURGE : Never "forget" a remote participant with which discovery communication has been lost.

        If a participant with this behavior loses discovery communication with a remote participant, it will nevertheless remember that remote participant and its endpoints and continue attempting to communicate with them indefinitely.

        This value has consequences for a participant's resource usage. If discovery communication with a remote participant is lost, but the same participant is later rediscovered, any relevant records that remain in the database will be reused. However, if it is not rediscovered, the records will continue to take up space in the database for as long as the local participant remains in existence.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        LIVELINESS_BASED: rti.connextdds.RemoteParticipantPurgeKind.RemoteParticipantPurgeKind
        NO_PURGE: rti.connextdds.RemoteParticipantPurgeKind.RemoteParticipantPurgeKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.RemoteParticipantPurgeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.RemoteParticipantPurgeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.RemoteParticipantPurgeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.RemoteParticipantPurgeKind.RemoteParticipantPurgeKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.RemoteParticipantPurgeKind.RemoteParticipantPurgeKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.RemoteParticipantPurgeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.RemoteParticipantPurgeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.RemoteParticipantPurgeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> RemoteParticipantPurgeKind.RemoteParticipantPurgeKind:
        """
        Retrieves the actual enumerated value.

        :type: RemoteParticipantPurgeKind.RemoteParticipantPurgeKind
        """
    LIVELINESS_BASED: rti.connextdds.RemoteParticipantPurgeKind.RemoteParticipantPurgeKind
    NO_PURGE: rti.connextdds.RemoteParticipantPurgeKind.RemoteParticipantPurgeKind
    __hash__: NoneType
    pass
class RequestedDeadlineMissedStatus():
    @builtins.property
    def last_instance_handle(self) -> InstanceHandle:
        """
        Handle to the last instance in the DataReader for which a missed deadline was detected.

        :type: InstanceHandle
        """
    @builtins.property
    def total_count(self) -> int:
        """
        Total count of the missed deadlines detected for any instance read by the DataReader.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta in missed deadlines detected since the last time the listener was called or the status was read.

        :type: int
        """
    pass
class RequestedIncompatibleQosStatus():
    def total_count(self) -> int: 
        """
        Total count of how many times the concerned DataReader discovered a DataWriter for the same Topic with an offered QoS that is incompatible with that requested by the DataReader.
        """
    @builtins.property
    def last_policy(self) -> object:
        """
        The policy class of one of the policies that was found to be incompatible the last time an incompatibility was detected. 

        :type: object
        """
    @builtins.property
    def policies(self) -> QosPolicyCountSeq:
        """
        A list containing, for each policy, the total number of times that the concerned DataReader discovered a DataWriter for the same Topic with an offered QoS that is incompatible with that requested by the DataReader.

        :type: QosPolicyCountSeq
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta in total_count since the last time the listener was called or the status was read.

        :type: int
        """
    pass
class ResourceLimits():
    def __eq__(self, arg0: rti.connextdds.ResourceLimits) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, max_samples: int, max_instances: int, max_samples_per_instance: int) -> None: 
        """
        Creates the default policy.
        """
    def __ne__(self, arg0: rti.connextdds.ResourceLimits) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def initial_instances(self) -> int:
        """
        The number of instances that a DataWriter or a DataWriter will preallocate.

        :type: int
        """
    @initial_instances.setter
    def initial_instances(self, arg1: int) -> None:
        """
        The number of instances that a DataWriter or a DataWriter will preallocate.
        """
    @builtins.property
    def initial_samples(self) -> int:
        """
        The maximum number of data samples per instance that a DataWriter or a DataReader can manage.

        :type: int
        """
    @initial_samples.setter
    def initial_samples(self, arg1: int) -> None:
        """
        The maximum number of data samples per instance that a DataWriter or a DataReader can manage.
        """
    @builtins.property
    def instance_hash_buckets(self) -> int:
        """
        The number of instances that a DataWriter or a DataWriter will preallocate.

        :type: int
        """
    @instance_hash_buckets.setter
    def instance_hash_buckets(self, arg1: int) -> None:
        """
        The number of instances that a DataWriter or a DataWriter will preallocate.
        """
    @builtins.property
    def max_instances(self) -> int:
        """
        Sets the maximum number of instances that a DataWriter or a DataReader can manage.

        :type: int
        """
    @max_instances.setter
    def max_instances(self, arg1: int) -> None:
        """
        Sets the maximum number of instances that a DataWriter or a DataReader can manage.
        """
    @builtins.property
    def max_samples(self) -> int:
        """
        Sets the maximum number of data samples that a DataWriter or a DataReader can manage across all instances.

        :type: int
        """
    @max_samples.setter
    def max_samples(self, arg1: int) -> None:
        """
        Sets the maximum number of data samples that a DataWriter or a DataReader can manage across all instances.
        """
    @builtins.property
    def max_samples_per_instance(self) -> int:
        """
        Sets the maximum number of data samples per instance that a DataWriter or a DataReader can manage.

        :type: int
        """
    @max_samples_per_instance.setter
    def max_samples_per_instance(self, arg1: int) -> None:
        """
        Sets the maximum number of data samples per instance that a DataWriter or a DataReader can manage.
        """
    __hash__: NoneType
    pass
class RtpsReliableReaderProtocol():
    def __eq__(self, arg0: rti.connextdds.RtpsReliableReaderProtocol) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create an RtpsReliableReaderProtocol policy with default settings.
        """
    def __ne__(self, arg0: rti.connextdds.RtpsReliableReaderProtocol) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def app_ack_period(self) -> Duration:
        """
        Get/set the period at which application-level acknowledgment messages are sent.

        :type: Duration
        """
    @app_ack_period.setter
    def app_ack_period(self, arg1: Duration) -> None:
        """
        Get/set the period at which application-level acknowledgment messages are sent.
        """
    @builtins.property
    def heartbeat_suppression_duration(self) -> Duration:
        """
        Get/set the duration to ignore consecutive heartbeats from a DataWriter.

        :type: Duration
        """
    @heartbeat_suppression_duration.setter
    def heartbeat_suppression_duration(self, arg1: Duration) -> None:
        """
        Get/set the duration to ignore consecutive heartbeats from a DataWriter.
        """
    @builtins.property
    def max_heartbeat_response_delay(self) -> Duration:
        """
        Get/set the maximum time to respond with an ACKNACK to a DataWriter's heartbeat.

        :type: Duration
        """
    @max_heartbeat_response_delay.setter
    def max_heartbeat_response_delay(self, arg1: Duration) -> None:
        """
        Get/set the maximum time to respond with an ACKNACK to a DataWriter's heartbeat.
        """
    @builtins.property
    def min_heartbeat_response_delay(self) -> Duration:
        """
        Get/set the minimum time to respond with an ACKNACK to a DataWriter's heartbeat.

        :type: Duration
        """
    @min_heartbeat_response_delay.setter
    def min_heartbeat_response_delay(self, arg1: Duration) -> None:
        """
        Get/set the minimum time to respond with an ACKNACK to a DataWriter's heartbeat.
        """
    @builtins.property
    def nack_period(self) -> Duration:
        """
        Get/set the period at which to send NACKs for receiving historical data.

        :type: Duration
        """
    @nack_period.setter
    def nack_period(self, arg1: Duration) -> None:
        """
        Get/set the period at which to send NACKs for receiving historical data.
        """
    @builtins.property
    def receive_window_size(self) -> int:
        """
        Get/set the number of received out-of-order samples a reader can keep at a time.

        :type: int
        """
    @receive_window_size.setter
    def receive_window_size(self, arg1: int) -> None:
        """
        Get/set the number of received out-of-order samples a reader can keep at a time.
        """
    @builtins.property
    def round_trip_time(self) -> Duration:
        """
        Get/set the estimated duration from sending a NACK to receiving a repair of a sample.

        :type: Duration
        """
    @round_trip_time.setter
    def round_trip_time(self, arg1: Duration) -> None:
        """
        Get/set the estimated duration from sending a NACK to receiving a repair of a sample.
        """
    @builtins.property
    def samples_per_app_ack(self) -> int:
        """
        Get/set the minimum number of samples acknowledged by one application-level acknowledgment message.

        :type: int
        """
    @samples_per_app_ack.setter
    def samples_per_app_ack(self, arg1: int) -> None:
        """
        Get/set the minimum number of samples acknowledged by one application-level acknowledgment message.
        """
    __hash__: NoneType
    pass
class RtpsReliableWriterProtocol():
    def __eq__(self, arg0: rti.connextdds.RtpsReliableWriterProtocol) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default RtpsReliableWriterProtocol policy.
        """
    def __ne__(self, arg0: rti.connextdds.RtpsReliableWriterProtocol) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def disable_positive_acks_decrease_sample_keep_duration_factor(self) -> int:
        """
        Controls rate of contraction of dynamic sample keep duration.

        :type: int
        """
    @disable_positive_acks_decrease_sample_keep_duration_factor.setter
    def disable_positive_acks_decrease_sample_keep_duration_factor(self, arg1: int) -> None:
        """
        Controls rate of contraction of dynamic sample keep duration.
        """
    @builtins.property
    def disable_positive_acks_enable_adaptive_sample_keep_duration(self) -> bool:
        """
        Enables dynamic adjustment of sample keep duration in response to congestion.

        :type: bool
        """
    @disable_positive_acks_enable_adaptive_sample_keep_duration.setter
    def disable_positive_acks_enable_adaptive_sample_keep_duration(self, arg1: bool) -> None:
        """
        Enables dynamic adjustment of sample keep duration in response to congestion.
        """
    @builtins.property
    def disable_positive_acks_increase_sample_keep_duration_factor(self) -> int:
        """
        Controls rate of growth of dynamic sample keep duration.

        :type: int
        """
    @disable_positive_acks_increase_sample_keep_duration_factor.setter
    def disable_positive_acks_increase_sample_keep_duration_factor(self, arg1: int) -> None:
        """
        Controls rate of growth of dynamic sample keep duration.
        """
    @builtins.property
    def disable_positive_acks_max_sample_keep_duration(self) -> Duration:
        """
        The maximum duration a sample is queued for ACK-disabled readers.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @disable_positive_acks_max_sample_keep_duration.setter
    def disable_positive_acks_max_sample_keep_duration(self, arg1: Duration) -> None:
        """
        The maximum duration a sample is queued for ACK-disabled readers.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def disable_positive_acks_min_sample_keep_duration(self) -> Duration:
        """
        The minimum duration a sample is queued for ACK-disabled readers.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @disable_positive_acks_min_sample_keep_duration.setter
    def disable_positive_acks_min_sample_keep_duration(self, arg1: Duration) -> None:
        """
        The minimum duration a sample is queued for ACK-disabled readers.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def disable_repair_piggyback_heartbeat(self) -> bool:
        """
        Prevents piggyback heartbeats from being sent with repair samples.

        :type: bool
        """
    @disable_repair_piggyback_heartbeat.setter
    def disable_repair_piggyback_heartbeat(self, arg1: bool) -> None:
        """
        Prevents piggyback heartbeats from being sent with repair samples.
        """
    @builtins.property
    def enable_multicast_periodic_heartbeat(self) -> bool:
        """
        Whether periodic heartbeat messages are sent over multicast.

        :type: bool
        """
    @enable_multicast_periodic_heartbeat.setter
    def enable_multicast_periodic_heartbeat(self, arg1: bool) -> None:
        """
        Whether periodic heartbeat messages are sent over multicast.
        """
    @builtins.property
    def fast_heartbeat_period(self) -> Duration:
        """
        An alternative heartbeat period used when a reliable writer needs to flush its unacknowledged samples more quickly.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @fast_heartbeat_period.setter
    def fast_heartbeat_period(self, arg1: Duration) -> None:
        """
        An alternative heartbeat period used when a reliable writer needs to flush its unacknowledged samples more quickly.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def heartbeat_period(self) -> Duration:
        """
        The period at which to send heartbeats.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @heartbeat_period.setter
    def heartbeat_period(self, arg1: Duration) -> None:
        """
        The period at which to send heartbeats.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def heartbeats_per_max_samples(self) -> int:
        """
        The number of heartbeats per current send window.

        :type: int
        """
    @heartbeats_per_max_samples.setter
    def heartbeats_per_max_samples(self, arg1: int) -> None:
        """
        The number of heartbeats per current send window.
        """
    @builtins.property
    def high_watermark(self) -> int:
        """
        When the number of unacknowledged samples in the current send window of a reliable writer meets or exceeds this threshold, StatusMask.reliable_writer_cache_changed is considered to have changed.

        :type: int
        """
    @high_watermark.setter
    def high_watermark(self, arg1: int) -> None:
        """
        When the number of unacknowledged samples in the current send window of a reliable writer meets or exceeds this threshold, StatusMask.reliable_writer_cache_changed is considered to have changed.
        """
    @builtins.property
    def inactivate_nonprogressing_readers(self) -> bool:
        """
        Whether to treat remote readers as inactive when their NACKs do not progress.

        :type: bool
        """
    @inactivate_nonprogressing_readers.setter
    def inactivate_nonprogressing_readers(self, arg1: bool) -> None:
        """
        Whether to treat remote readers as inactive when their NACKs do not progress.
        """
    @builtins.property
    def late_joiner_heartbeat_period(self) -> Duration:
        """
        An alternative heartbeat period used when a reliable reader joins late and needs to be caught up on cached samples of a reliable writer more quickly than the normal heartbeat rate.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @late_joiner_heartbeat_period.setter
    def late_joiner_heartbeat_period(self, arg1: Duration) -> None:
        """
        An alternative heartbeat period used when a reliable reader joins late and needs to be caught up on cached samples of a reliable writer more quickly than the normal heartbeat rate.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def low_watermark(self) -> int:
        """
        When the number of unacknowledged samples in the current send window of a reliable writer meets or falls below this threshold, the StatusMask.reliable_writer_cache_changed is considered to have changed.

        :type: int
        """
    @low_watermark.setter
    def low_watermark(self, arg1: int) -> None:
        """
        When the number of unacknowledged samples in the current send window of a reliable writer meets or falls below this threshold, the StatusMask.reliable_writer_cache_changed is considered to have changed.
        """
    @builtins.property
    def max_bytes_per_nack_response(self) -> int:
        """
        The maximum total message size when resending dropped samples or data fragments.

        :type: int
        """
    @max_bytes_per_nack_response.setter
    def max_bytes_per_nack_response(self, arg1: int) -> None:
        """
        The maximum total message size when resending dropped samples or data fragments.
        """
    @builtins.property
    def max_heartbeat_retries(self) -> int:
        """
        The maximum number of periodic heartbeat retries before marking a remote reader as inactive.

        :type: int
        """
    @max_heartbeat_retries.setter
    def max_heartbeat_retries(self, arg1: int) -> None:
        """
        The maximum number of periodic heartbeat retries before marking a remote reader as inactive.
        """
    @builtins.property
    def max_nack_response_delay(self) -> Duration:
        """
        The maximum delay to respond to a NACK or NACK_FRAG.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @max_nack_response_delay.setter
    def max_nack_response_delay(self, arg1: Duration) -> None:
        """
        The maximum delay to respond to a NACK or NACK_FRAG.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def max_send_window_size(self) -> int:
        """
        Maximum size of send window of unacknowledged samples.

        :type: int
        """
    @max_send_window_size.setter
    def max_send_window_size(self, arg1: int) -> None:
        """
        Maximum size of send window of unacknowledged samples.
        """
    @builtins.property
    def min_nack_response_delay(self) -> Duration:
        """
        The minimum delay to respond to a NACK or NACK_FRAG.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @min_nack_response_delay.setter
    def min_nack_response_delay(self, arg1: Duration) -> None:
        """
        The minimum delay to respond to a NACK or NACK_FRAG.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def min_send_window_size(self) -> int:
        """
        Minimum size of send window of unacknowledged samples.

        :type: int
        """
    @min_send_window_size.setter
    def min_send_window_size(self, arg1: int) -> None:
        """
        Minimum size of send window of unacknowledged samples.
        """
    @builtins.property
    def multicast_resend_threshold(self) -> int:
        """
        The minimum number of requesting readers needed to trigger a multicast resend.

        :type: int
        """
    @multicast_resend_threshold.setter
    def multicast_resend_threshold(self, arg1: int) -> None:
        """
        The minimum number of requesting readers needed to trigger a multicast resend.
        """
    @builtins.property
    def nack_suppression_duration(self) -> Duration:
        """
        The duration for ignoring consecutive NACKs/NACK_FRAGs that may trigger redundant repairs.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @nack_suppression_duration.setter
    def nack_suppression_duration(self, arg1: Duration) -> None:
        """
        The duration for ignoring consecutive NACKs/NACK_FRAGs that may trigger redundant repairs.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def samples_per_virtual_heartbeat(self) -> int:
        """
        The number of samples that a reliable writer has to publish before sending a virtual heartbeat.

        :type: int
        """
    @samples_per_virtual_heartbeat.setter
    def samples_per_virtual_heartbeat(self, arg1: int) -> None:
        """
        The number of samples that a reliable writer has to publish before sending a virtual heartbeat.
        """
    @builtins.property
    def send_window_decrease_factor(self) -> int:
        """
        Decreases send window size by this percentage when reacting dynamically to network conditions.

        :type: int
        """
    @send_window_decrease_factor.setter
    def send_window_decrease_factor(self, arg1: int) -> None:
        """
        Decreases send window size by this percentage when reacting dynamically to network conditions.
        """
    @builtins.property
    def send_window_increase_factor(self) -> int:
        """
        Increases send window size by this percentage when reacting dynamically to network conditions.

        :type: int
        """
    @send_window_increase_factor.setter
    def send_window_increase_factor(self, arg1: int) -> None:
        """
        Increases send window size by this percentage when reacting dynamically to network conditions.
        """
    @builtins.property
    def send_window_update_period(self) -> Duration:
        """
        Period in which send window may be dynamically changed.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @send_window_update_period.setter
    def send_window_update_period(self, arg1: Duration) -> None:
        """
        Period in which send window may be dynamically changed.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def virtual_heartbeat_period(self) -> Duration:
        """
        The period at which to send virtual heartbeats. Virtual heartbeats inform the reliable reader about the range of samples currently present, for each virtual GUID, in the reliable writer's queue.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @virtual_heartbeat_period.setter
    def virtual_heartbeat_period(self, arg1: Duration) -> None:
        """
        The period at which to send virtual heartbeats. Virtual heartbeats inform the reliable reader about the range of samples currently present, for each virtual GUID, in the reliable writer's queue.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class RtpsReservedPortKindMask():
    def __and__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a RtpsReservedPortKindMask equivalent to RtpsReservedPortKindMask.NONE
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Bitwise logical OR of masks.
        """
    def __repr__(self) -> str: 
        """
        Convert mask to string.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: 
        """
        Convert mask to string.
        """
    def __xor__(self, arg0: rti.connextdds.RtpsReservedPortKindMask) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.RtpsReservedPortKindMask: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ALL: rti.connextdds.RtpsReservedPortKindMask
    BUILTIN_MULTICAST: rti.connextdds.RtpsReservedPortKindMask
    BUILTIN_UNICAST: rti.connextdds.RtpsReservedPortKindMask
    DEFAULT_MASK: rti.connextdds.RtpsReservedPortKindMask
    NONE: rti.connextdds.RtpsReservedPortKindMask
    USER_MULTICAST: rti.connextdds.RtpsReservedPortKindMask
    USER_UNICAST: rti.connextdds.RtpsReservedPortKindMask
    __hash__: NoneType
    pass
class RtpsWellKnownPorts():
    def __eq__(self, arg0: rti.connextdds.RtpsWellKnownPorts) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an instance that contains the default RTPS well-known ports.
        """
    @typing.overload
    def __init__(self, port_base: int, domain_id_gain: int, participant_id_gain: int, builtin_multicast_port_offset: int, builtin_unicast_port_offset: int, user_multicast_port_offset: int, user_unicast_port_offset: int) -> None: 
        """
        Creates an instance with the specified ports.
        """
    def __ne__(self, arg0: rti.connextdds.RtpsWellKnownPorts) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def builtin_multicast_port_offset(self) -> int:
        """
        Additional offset for metatraffic multicast port.

        :type: int
        """
    @builtin_multicast_port_offset.setter
    def builtin_multicast_port_offset(self, arg1: int) -> None:
        """
        Additional offset for metatraffic multicast port.
        """
    @builtins.property
    def builtin_unicast_port_offset(self) -> int:
        """
        Additional offset for metatraffic unicast port.

        :type: int
        """
    @builtin_unicast_port_offset.setter
    def builtin_unicast_port_offset(self, arg1: int) -> None:
        """
        Additional offset for metatraffic unicast port.
        """
    @builtins.property
    def domain_id_gain(self) -> int:
        """
        Tunable domain gain parameter.

        :type: int
        """
    @domain_id_gain.setter
    def domain_id_gain(self, arg1: int) -> None:
        """
        Tunable domain gain parameter.
        """
    @builtins.property
    def participant_id_gain(self) -> int:
        """
        Tunable participant gain parameter.

        :type: int
        """
    @participant_id_gain.setter
    def participant_id_gain(self, arg1: int) -> None:
        """
        Tunable participant gain parameter.
        """
    @builtins.property
    def port_base(self) -> int:
        """
        The port base offset.

        :type: int
        """
    @port_base.setter
    def port_base(self, arg1: int) -> None:
        """
        The port base offset.
        """
    @builtins.property
    def user_multicast_port_offset(self) -> int:
        """
        Additional offset for usertraffic multicast port.

        :type: int
        """
    @user_multicast_port_offset.setter
    def user_multicast_port_offset(self, arg1: int) -> None:
        """
        Additional offset for usertraffic multicast port.
        """
    @builtins.property
    def user_unicast_port_offset(self) -> int:
        """
        Additional offset for usertraffic unicast port.

        :type: int
        """
    @user_unicast_port_offset.setter
    def user_unicast_port_offset(self, arg1: int) -> None:
        """
        Additional offset for usertraffic unicast port.
        """
    __hash__: NoneType
    backwards_compatible: rti.connextdds.RtpsWellKnownPorts
    interoperable: rti.connextdds.RtpsWellKnownPorts
    pass
class SampleFlag():
    def __and__(self, arg0: rti.connextdds.SampleFlag) -> rti.connextdds.SampleFlag: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.SampleFlag) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.SampleFlag) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.SampleFlag) -> rti.connextdds.SampleFlag: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.SampleFlag: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Construct an empty SampleFlag with no bits set.
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.SampleFlag) -> rti.connextdds.SampleFlag: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.SampleFlag: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.SampleFlag) -> rti.connextdds.SampleFlag: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.SampleFlag: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.SampleFlag) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.SampleFlag) -> rti.connextdds.SampleFlag: 
        """
        Bitwise logical OR of masks.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.SampleFlag: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: ...
    def __xor__(self, arg0: rti.connextdds.SampleFlag) -> rti.connextdds.SampleFlag: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.SampleFlag: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.SampleFlag: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.SampleFlag: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.SampleFlag: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.SampleFlag: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.SampleFlag: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    INCOMPLETE_SNAPSHOT_TOPIC_QUERY: rti.connextdds.SampleFlag
    INTERMEDIATE_REPLY_SEQUENCE: rti.connextdds.SampleFlag
    INTERMEDIATE_TOPIC_QUERY_SAMPLE: rti.connextdds.SampleFlag
    LAST_SHARED_READER_QUEUE: rti.connextdds.SampleFlag
    REDELIVERED: rti.connextdds.SampleFlag
    REPLICATE: rti.connextdds.SampleFlag
    __hash__: NoneType
    pass
class SampleIdentity():
    def __eq__(self, arg0: rti.connextdds.SampleIdentity) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default SampleIdentity object.
        """
    @typing.overload
    def __init__(self, writer_guid: rti.connextdds.Guid, sequence_number: rti.connextdds.SequenceNumber) -> None: 
        """
        Create a SampleIdentity with the provided Guid and SequenceNumber.
        """
    def __ne__(self, arg0: rti.connextdds.SampleIdentity) -> bool: 
        """
        Test for inequality.
        """
    def __str__(self) -> str: ...
    @builtins.property
    def sequence_number(self) -> SequenceNumber:
        """
        Get the monotonically increasing 64-bit SequenceNumber that identifies the sample in the data source.

        :type: SequenceNumber
        """
    @builtins.property
    def writer_guid(self) -> Guid:
        """
        Get the 16-byte identifier identifying the virtual Guid.

        :type: Guid
        """
    __hash__: NoneType
    automatic: rti.connextdds.SampleIdentity
    unknown: rti.connextdds.SampleIdentity
    pass
class SampleInfo():
    def __eq__(self, arg0: rti.connextdds.SampleInfo) -> bool: 
        """
        Check if two SampleInfo are equal.
        """
    def __ne__(self, arg0: rti.connextdds.SampleInfo) -> bool: 
        """
        Check if two SampleInfo are not equal.
        """
    def __repr__(self) -> str: ...
    @builtins.property
    def coherent_set_info(self) -> typing.Optional[CoherentSetInfo]:
        """
        TWhen set, this field provides the information about the coherent set associated with the sample.

        :type: typing.Optional[CoherentSetInfo]
        """
    @builtins.property
    def encapsulation_id(self) -> int:
        """
        The encapsulation kind.

        :type: int
        """
    @builtins.property
    def flag(self) -> SampleFlag:
        """
        Flags associated with the sample.

        :type: SampleFlag
        """
    @builtins.property
    def generation_count(self) -> GenerationCount:
        """
        The GenerationCount of the sample.

        :type: GenerationCount
        """
    @builtins.property
    def instance_handle(self) -> InstanceHandle:
        """
        Identifies locally the corresponding instance.

        :type: InstanceHandle
        """
    @builtins.property
    def original_publication_virtual_guid(self) -> Guid:
        """
        Original publication virtual GUID.

        If the Publishers access_scope is GROUP, this field contains the Publisher virtual GUID that uniquely identifies the DataWriter group.

        :type: Guid
        """
    @builtins.property
    def original_publication_virtual_sample_identity(self) -> SampleIdentity:
        """
        Retrieves the information provided by original_publication_virtual_guid and original_publication_virtual_sequence_number combined in a SampleIdentity instance.

        :type: SampleIdentity
        """
    @builtins.property
    def original_publication_virtual_sequence_number(self) -> SequenceNumber:
        """
        Original publication virtual sequence number.

        If the Publishers access_scope is GROUP, this field contains the Publisher virtual sequence number that uniquely identifies a DDS sample within the DataWriter group.

        :type: SequenceNumber
        """
    @builtins.property
    def publication_handle(self) -> InstanceHandle:
        """
        Identifies locally the DataWriter that modified the instance.

        :type: InstanceHandle
        """
    @builtins.property
    def publication_sequence_number(self) -> SequenceNumber:
        """
        Publication sequence number assigned when the DDS sample was written by the DataWriter.

        :type: SequenceNumber
        """
    @builtins.property
    def rank(self) -> Rank:
        """
        Get the Rank of the sample.

        :type: Rank
        """
    @builtins.property
    def reception_sequence_number(self) -> SequenceNumber:
        """
        Reception sequence number assigned when the DDS sample was committed by the DataReader.

        :type: SequenceNumber
        """
    @builtins.property
    def reception_timestamp(self) -> Time:
        """
        The timestamp when the sample was committed by a DataReader.

        :type: Time
        """
    @builtins.property
    def related_original_publication_virtual_guid(self) -> Guid:
        """
        The original publication virtual GUID of a related sample.

        :type: Guid
        """
    @builtins.property
    def related_original_publication_virtual_sample_identity(self) -> SampleIdentity:
        """
        Retrieves the information provided by related_original_publication_virtual_guid and related_original_publication_virtual_sequence_number combined in a SampleIdentity instance.

        :type: SampleIdentity
        """
    @builtins.property
    def related_original_publication_virtual_sequence_number(self) -> SequenceNumber:
        """
        The original publication virtual sequence number of a related sample.

        :type: SequenceNumber
        """
    @builtins.property
    def related_source_guid(self) -> Guid:
        """
        The application logical data source that is related to the sample.

        :type: Guid
        """
    @builtins.property
    def related_subscription_guid(self) -> Guid:
        """
        The related_reader_guid associated with the sample.

        :type: Guid
        """
    @builtins.property
    def source_guid(self) -> Guid:
        """
        The application logical data source associated with the sample.

        :type: Guid
        """
    @builtins.property
    def source_timestamp(self) -> Time:
        """
        The DataWriter's write timestamp.

        :type: Time
        """
    @builtins.property
    def state(self) -> DataState:
        """
        Get the DataState of the sample.

        :type: DataState
        """
    @builtins.property
    def topic_query_guid(self) -> Guid:
        """
        The GUID of the TopicQuery that is related to the sample.

        :type: Guid
        """
    @builtins.property
    def valid(self) -> bool:
        """
        Indicates whether the DataSample contains data or else it is only used to communicate a change in the InstanceState of the instance.

        :type: bool
        """
    __hash__: NoneType
    pass
class SampleLostState():
    def __and__(self, arg0: rti.connextdds.SampleLostState) -> rti.connextdds.SampleLostState: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.SampleLostState) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.SampleLostState) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.SampleLostState) -> rti.connextdds.SampleLostState: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.SampleLostState: 
        """
        Left shift bits in mask.
        """
    def __init__(self) -> None: 
        """
        Creates SampleLostState.NOT_LOST
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.SampleLostState) -> rti.connextdds.SampleLostState: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.SampleLostState: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.SampleLostState) -> rti.connextdds.SampleLostState: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.SampleLostState: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.SampleLostState) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.SampleLostState) -> rti.connextdds.SampleLostState: 
        """
        Bitwise logical OR of masks.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.SampleLostState: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: ...
    def __xor__(self, arg0: rti.connextdds.SampleLostState) -> rti.connextdds.SampleLostState: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.SampleLostState: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.SampleLostState: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.SampleLostState: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.SampleLostState: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.SampleLostState: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.SampleLostState: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    LOST_BY_AVAILABILITY_WAITING_TIME: rti.connextdds.SampleLostState
    LOST_BY_DECODE_FAILURE: rti.connextdds.SampleLostState
    LOST_BY_DESERIALIZATION_FAILURE: rti.connextdds.SampleLostState
    LOST_BY_INCOMPLETE_COHERENT_SET: rti.connextdds.SampleLostState
    LOST_BY_INSTANCES_LIMIT: rti.connextdds.SampleLostState
    LOST_BY_LARGE_COHERENT_SET: rti.connextdds.SampleLostState
    LOST_BY_OUT_OF_MEMORY: rti.connextdds.SampleLostState
    LOST_BY_REMOTE_WRITERS_PER_INSTANCE_LIMIT: rti.connextdds.SampleLostState
    LOST_BY_REMOTE_WRITERS_PER_SAMPLE_LIMIT: rti.connextdds.SampleLostState
    LOST_BY_REMOTE_WRITERS_PER_VIRTUAL_QUEUE_LIMIT: rti.connextdds.SampleLostState
    LOST_BY_SAMPLES_LIMIT: rti.connextdds.SampleLostState
    LOST_BY_SAMPLES_PER_INSTANCE_LIMIT: rti.connextdds.SampleLostState
    LOST_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT: rti.connextdds.SampleLostState
    LOST_BY_UNKNOWN_INSTANCE: rti.connextdds.SampleLostState
    LOST_BY_VIRTUAL_WRITERS_LIMIT: rti.connextdds.SampleLostState
    LOST_BY_WRITER: rti.connextdds.SampleLostState
    NOT_LOST: rti.connextdds.SampleLostState
    __hash__: NoneType
    pass
class SampleLostStatus():
    @builtins.property
    def last_reason(self) -> SampleLostState:
        """
        The reason for the most recent sample loss.

        :type: SampleLostState
        """
    @builtins.property
    def total_count(self) -> int:
        """
        Total count of all samples lost across all instances of data published under the Topic.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The incremental number of samples lost since the last time the listener was called or the status was read.

        :type: int
        """
    pass
class SampleRejectedState():
    def __and__(self, arg0: rti.connextdds.SampleRejectedState) -> rti.connextdds.SampleRejectedState: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.SampleRejectedState) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.SampleRejectedState) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.SampleRejectedState) -> rti.connextdds.SampleRejectedState: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.SampleRejectedState: 
        """
        Left shift bits in mask.
        """
    def __init__(self) -> None: 
        """
        Creates SampleRejectedState.NOT_REJECTED
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.SampleRejectedState) -> rti.connextdds.SampleRejectedState: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.SampleRejectedState: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.SampleRejectedState) -> rti.connextdds.SampleRejectedState: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.SampleRejectedState: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.SampleRejectedState) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.SampleRejectedState) -> rti.connextdds.SampleRejectedState: 
        """
        Bitwise logical OR of masks.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.SampleRejectedState: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: ...
    def __xor__(self, arg0: rti.connextdds.SampleRejectedState) -> rti.connextdds.SampleRejectedState: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.SampleRejectedState: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.SampleRejectedState: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.SampleRejectedState: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.SampleRejectedState: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.SampleRejectedState: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.SampleRejectedState: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    NOT_REJECTED: rti.connextdds.SampleRejectedState
    REJECTED_BY_DECODE_FAILURE: rti.connextdds.SampleRejectedState
    REJECTED_BY_INSTANCES_LIMIT: rti.connextdds.SampleRejectedState
    REJECTED_BY_REMOTE_WRITERS_PER_VIRTUAL_QUEUE_LIMIT: rti.connextdds.SampleRejectedState
    REJECTED_BY_SAMPLES_LIMIT: rti.connextdds.SampleRejectedState
    REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT: rti.connextdds.SampleRejectedState
    REJECTED_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT: rti.connextdds.SampleRejectedState
    __hash__: NoneType
    pass
class SampleRejectedStatus():
    @builtins.property
    def last_instance_handle(self) -> InstanceHandle:
        """
        Handle for the instance of the sample that was most recently rejected.

        :type: InstanceHandle
        """
    @builtins.property
    def last_reason(self) -> SampleRejectedState:
        """
        Reason for the DataReader's most recent sample rejection.

        :type: SampleRejectedState
        """
    @builtins.property
    def total_count(self) -> int:
        """
        Total count of samples rejected by the DataReader.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta number of samples rejected since the last time the listener fired or the status was read.

        :type: int
        """
    pass
class SampleState():
    def __and__(self, arg0: rti.connextdds.SampleState) -> rti.connextdds.SampleState: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> rti.connextdds.SampleState: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.SampleState) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.SampleState) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.SampleState) -> rti.connextdds.SampleState: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.SampleState: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a SampleState with no bits set.
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.SampleState) -> rti.connextdds.SampleState: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.SampleState: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.SampleState) -> rti.connextdds.SampleState: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.SampleState: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.SampleState) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.SampleState) -> rti.connextdds.SampleState: 
        """
        Bitwise logical OR of masks.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.SampleState: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: ...
    def __xor__(self, arg0: rti.connextdds.SampleState) -> rti.connextdds.SampleState: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.SampleState: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.SampleState: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.SampleState: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.SampleState: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.SampleState: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.SampleState: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ANY: rti.connextdds.SampleState
    NOT_READ: rti.connextdds.SampleState
    READ: rti.connextdds.SampleState
    __hash__: NoneType
    pass
class SequenceNumber():
    def __add__(self, arg0: rti.connextdds.SequenceNumber) -> rti.connextdds.SequenceNumber: 
        """
        Add two SequenceNumbers.
        """
    def __eq__(self, arg0: rti.connextdds.SequenceNumber) -> bool: 
        """
        Compare SequenceNumbers for equality.
        """
    def __ge__(self, arg0: rti.connextdds.SequenceNumber) -> bool: 
        """
        Compare two SequenceNumbers for a greater-than-or-equal relationship.
        """
    def __gt__(self, arg0: rti.connextdds.SequenceNumber) -> bool: 
        """
        Compare two SequenceNumbers for a greater-than relationship.
        """
    def __iadd__(self, arg0: rti.connextdds.SequenceNumber) -> rti.connextdds.SequenceNumber: 
        """
        Add a SequenceNumber to another
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default SequenceNumber, equal to SequenceNumber.unknown
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a SequenceNumber from an integer.
        """
    def __int__(self) -> int: 
        """
        Convert SequenceNumber to integer.
        """
    def __isub__(self, arg0: rti.connextdds.SequenceNumber) -> rti.connextdds.SequenceNumber: 
        """
        Subtract a SequenceNumber from another.
        """
    def __le__(self, arg0: rti.connextdds.SequenceNumber) -> bool: 
        """
        Compare two SequenceNumbers for a less-than-or-equal relationship.
        """
    def __lt__(self, arg0: rti.connextdds.SequenceNumber) -> bool: 
        """
        Compare two SequenceNumbers for a less-than relationship.
        """
    def __ne__(self, arg0: rti.connextdds.SequenceNumber) -> bool: 
        """
        Compare SequenceNumbers for inequality.
        """
    def __repr__(self) -> str: 
        """
        Convert SequenceNumber to string.
        """
    def __sub__(self, arg0: rti.connextdds.SequenceNumber) -> rti.connextdds.SequenceNumber: 
        """
        Subtract one SequenceNumber from another.
        """
    @builtins.property
    def value(self) -> int:
        """
        Get/set the SequenceNumber value.

        :type: int
        """
    @value.setter
    def value(self, arg1: int) -> None:
        """
        Get/set the SequenceNumber value.
        """
    __hash__: NoneType
    automatic: rti.connextdds.SequenceNumber
    maximum: rti.connextdds.SequenceNumber
    unknown: rti.connextdds.SequenceNumber
    zero: rti.connextdds.SequenceNumber
    pass
class UnidimensionalCollectionType(CollectionType, DynamicType):
    def __eq__(self, arg0: rti.connextdds.UnidimensionalCollectionType) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.UnidimensionalCollectionType) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def bounds(self) -> int:
        """
        Gets the maximum length of this collection.

        :type: int
        """
    UNBOUNDED: int
    __hash__: NoneType
    pass
class Service():
    def __eq__(self, arg0: rti.connextdds.Service) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy (no service).
        """
    @typing.overload
    def __init__(self, kind: rti.connextdds.ServiceKind) -> None: 
        """
        Creates an instance with the specified service kind.
        """
    def __ne__(self, arg0: rti.connextdds.Service) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def kind(self) -> ServiceKind:
        """
        The service kind.

        :type: ServiceKind
        """
    @kind.setter
    def kind(self, arg1: ServiceKind) -> None:
        """
        The service kind.
        """
    __hash__: NoneType
    pass
class ServiceKind():
    class ServiceKind():
        """
        Members:

          NO_SERVICE : There is no service associated to the Entity.

          PERSISTENCE : The Entity is associated to RTI Persistence Service.

          QUEUING : The Entity is associated to RTI Queuing Service.

          ROUTING : The Entity is associated to RTI Routing Service.

          RECORDING : The Entity is associated to RTI Recording Service.

          REPLAY : The Entity is associated to RTI Replay Service.

          DATABASE_INTEGRATION : The Entity is associated to RTI Database Integration Service.

          WEB_INTEGRATION : The Entity is associated to RTI Web Integration Service.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        DATABASE_INTEGRATION: rti.connextdds.ServiceKind.ServiceKind
        NO_SERVICE: rti.connextdds.ServiceKind.ServiceKind
        PERSISTENCE: rti.connextdds.ServiceKind.ServiceKind
        QUEUING: rti.connextdds.ServiceKind.ServiceKind
        RECORDING: rti.connextdds.ServiceKind.ServiceKind
        REPLAY: rti.connextdds.ServiceKind.ServiceKind
        ROUTING: rti.connextdds.ServiceKind.ServiceKind
        WEB_INTEGRATION: rti.connextdds.ServiceKind.ServiceKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.ServiceKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.ServiceKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.ServiceKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ServiceKind.ServiceKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.ServiceKind.ServiceKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.ServiceKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.ServiceKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.ServiceKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> ServiceKind.ServiceKind:
        """
        Retrieves the actual enumerated value.

        :type: ServiceKind.ServiceKind
        """
    DATABASE_INTEGRATION: rti.connextdds.ServiceKind.ServiceKind
    NO_SERVICE: rti.connextdds.ServiceKind.ServiceKind
    PERSISTENCE: rti.connextdds.ServiceKind.ServiceKind
    QUEUING: rti.connextdds.ServiceKind.ServiceKind
    RECORDING: rti.connextdds.ServiceKind.ServiceKind
    REPLAY: rti.connextdds.ServiceKind.ServiceKind
    ROUTING: rti.connextdds.ServiceKind.ServiceKind
    WEB_INTEGRATION: rti.connextdds.ServiceKind.ServiceKind
    __hash__: NoneType
    pass
class ServiceRequest():
    class ContentFilter(ContentFilterBase):
        def __init__(self) -> None: ...
        def compile(self, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, old_compile_data: typing.Optional[object]) -> typing.Optional[object]: 
            """
            Compile an instance of the content filter according to the filter expression and parameters of the given data type.
            """
        def evaluate(self, compile_data: typing.Optional[object], sample: rti.connextdds.ServiceRequest, meta_data: rti.connextdds.FilterSampleInfo) -> bool: 
            """
            Evaluate whether the sample is passing the filter or not according to the sample content.
            """
        def finalize(self, compile_data: typing.Optional[object]) -> None: 
            """
            A previously compiled instance of the content filter is no longer in use and resources can now be cleaned up.
            """
        pass
    class ContentFilteredTopic(ServiceRequest.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ServiceRequest.Topic, name: str, contentfilter: rti.connextdds.Filter) -> None: 
            """
            Create a ContentFilteredTopic with a name and Filter.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.ServiceRequest.ITopicDescription) -> None: 
            """
            Cast a TopicDescription to a ContentFilteredTopic.
            """
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> bool: 
            """
            Test for inequality.
            """
        def append_to_expression_parameter(self, index: int, extension: str) -> None: 
            """
            Append the extension to the end of parameter at the provided index, separated by a comma.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ServiceRequest.ContentFilteredTopic]: 
            """
            Look up a ContentFilteredTopic by its name in the DomainParticipant.
            """
        def remove_from_expression_parameter(self, index: int, remove_term: str) -> None: 
            """
            Removes the specified term from the parameter at the provided index.
            """
        def set_filter(self, arg0: rti.connextdds.Filter) -> None: 
            """
            Set the filter.
            """
        @builtins.property
        def filter_expression(self) -> str:
            """
            Get the filter expression

            :type: str
            """
        @builtins.property
        def filter_parameters(self) -> StringSeq:
            """
            Get/set the filter parameters.

            :type: StringSeq
            """
        @filter_parameters.setter
        def filter_parameters(self, arg1: StringSeq) -> None:
            """
            Get/set the filter parameters.
            """
        @builtins.property
        def topic(self) -> ServiceRequest.Topic:
            """
            Get the underlying Topic.

            :type: ServiceRequest.Topic
            """
        __hash__: NoneType
        pass
    class ContentFilteredTopicSeq():
        def __add__(self, arg0: rti.connextdds.ServiceRequest.ContentFilteredTopicSeq) -> rti.connextdds.ServiceRequest.ContentFilteredTopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.ContentFilteredTopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.ServiceRequest.ContentFilteredTopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.ServiceRequest.ContentFilteredTopic: ...
        def __iadd__(self, arg0: rti.connextdds.ServiceRequest.ContentFilteredTopicSeq) -> rti.connextdds.ServiceRequest.ContentFilteredTopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.ServiceRequest.ContentFilteredTopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.ServiceRequest.ContentFilteredTopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ServiceRequest.ContentFilteredTopic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.ServiceRequest.ContentFilteredTopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.ContentFilteredTopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.ServiceRequest.ContentFilteredTopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.ServiceRequest.ContentFilteredTopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.ServiceRequest.ContentFilteredTopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.ServiceRequest.ContentFilteredTopic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.ServiceRequest.ContentFilteredTopic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataReader(IDataReader, IEntity, IAnyDataReader):
        class Selector():
            def __init__(self, datareader: rti.connextdds.ServiceRequest.DataReader) -> None: 
                """
                Create a Selector for a DataReader to read/take based on selected conditions
                """
            def condition(self, condition: rti.connextdds.IReadCondition) -> rti.connextdds.ServiceRequest.DataReader.Selector: 
                """
                Select samples based on a ReadCondition.
                """
            def content(self, query: rti.connextdds.Query) -> rti.connextdds.ServiceRequest.DataReader.Selector: 
                """
                Select samples based on a Query.
                """
            def instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ServiceRequest.DataReader.Selector: 
                """
                Select a specific instance to read/take.
                """
            def max_samples(self, max: int) -> rti.connextdds.ServiceRequest.DataReader.Selector: 
                """
                Limit the number of samples read/taken by the Select.
                """
            def next_instance(self, previous: rti.connextdds.InstanceHandle) -> rti.connextdds.ServiceRequest.DataReader.Selector: 
                """
                Select the instance after the specified instance to read/take.
                """
            def read(self) -> list: 
                """
                Read copies of available samples (data and info) based on the Selector settings.
                """
            def read_data(self) -> list: 
                """
                Read copies of available valid data based on the Selector settings.
                """
            def read_loaned(self) -> rti.connextdds.ServiceRequest.LoanedSamples: 
                """
                Take available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            def state(self, state: rti.connextdds.DataState) -> rti.connextdds.ServiceRequest.DataReader.Selector: 
                """
                Select samples with a specified data state.
                """
            def take(self) -> list: 
                """
                Take copies of available samples (data and info) based on the Selector settings.
                """
            def take_data(self) -> list: 
                """
                Take copies of available valid data based on the Selector settings.
                """
            def take_loaned(self) -> rti.connextdds.ServiceRequest.LoanedSamples: 
                """
                Read available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            pass
        def __enter__(self) -> rti.connextdds.ServiceRequest.DataReader: 
            """
            Enter a context for this DataReader, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.DataReader) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataReader, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ServiceRequest.Topic) -> None: 
            """
            Create a DataReader in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ServiceRequest.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.ServiceRequest.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in the implicit subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.ServiceRequest.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.ServiceRequest.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.ServiceRequest.Topic) -> None: 
            """
            Create a DataReader.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.ServiceRequest.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.ServiceRequest.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in a subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.ServiceRequest.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.ServiceRequest.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.ServiceRequest.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
            """
            Get a typed DataReader from an AnyDataReader.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Get a typed DataReader from an Entity.
            """
        def __lshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.ServiceRequest.DataReader: 
            """
            Set the DataReaderQos for this DataReader.
            """
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.DataReader) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.ServiceRequest.DataReader: 
            """
            Get the DataReaderQos from this DataReader
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Subscriber, arg1: rti.connextdds.ServiceRequest.TopicDescription, arg2: rti.connextdds.DataReaderQos) -> rti.connextdds.ServiceRequest.DataReader: ...
        def _set_related_writer_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        @typing.overload
        def acknowledge_all(self) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_all(self, arg0: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo) -> None: 
            """
            Acknowledge a single sample.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo, ack_response_data: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge a single sample with ack response data.
            """
        def close(self) -> None: 
            """
            Close this DataReader.
            """
        @staticmethod
        def find_all_by_topic(subscriber: rti.connextdds.Subscriber, topic_name: str) -> rti.connextdds.ServiceRequest.DataReaderSeq: 
            """
            Retrieve all DataReaders for the given topic name in the subscriber.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ServiceRequest.DataReader]: 
            """
            Find DataReader in DomainParticipant with the DataReader's name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.ServiceRequest.DataReader]: 
            """
            Find DataReader in Subscriber with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.ServiceRequest.DataReader]: 
            """
            Find DataReader in Subscriber with a topic name, returning the first found.
            """
        def is_matched_publication_alive(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            Check if a matched publication is alive.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ServiceRequest: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.ServiceRequest) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_publication_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Get the PublicationBuiltinTopicData for a publication matched to this DataReader.
            """
        def matched_publication_datareader_protocol_status(self, publication_handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReaderProtocolStatus: 
            """
            Get the DataReaderProtocolStatus for the DataReader based on the matched publication handle.
            """
        def matched_publication_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a publication matched to this DataReader.
            """
        def read(self) -> list: 
            """
            Read copies of all available samples (data and info).
            """
        def read_data(self) -> list: 
            """
            Read copies of all available valid data.
            """
        def read_loaned(self) -> rti.connextdds.ServiceRequest.LoanedSamples: 
            """
            Read all available samples (data and info) and return them in a loaned container.
            """
        @staticmethod
        def select(*args, **kwargs) -> typing.Any: 
            """
            Get a Selector to perform complex data selections, such as per-instance selection, content, and status filtering.
            """
        def set_listener(self, listener: rti.connextdds.ServiceRequest.DataReaderListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and associated event mask.
            """
        def take(self) -> list: 
            """
            Take copies of all available samples (data and info).
            """
        def take_data(self) -> list: 
            """
            Take copies of all available valid data.
            """
        def take_loaned(self) -> rti.connextdds.ServiceRequest.LoanedSamples: 
            """
            Take all available samples (data and info) and return them in a loaned container.
            """
        def wait_for_historical_data(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind.
            """
        def wait_for_historical_data_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind. This call is awaitable and only for use with asyncio.
            """
        @builtins.property
        def _has_matched_publications_with_related_reader(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datareader_cache_status(self) -> DataReaderCacheStatus:
            """
            Get the DataReaderCacheStatus for the DataReader.

            :type: DataReaderCacheStatus
            """
        @builtins.property
        def datareader_protocol_status(self) -> DataReaderProtocolStatus:
            """
            Get the DataReaderProtocolStatus for the DataReader.

            :type: DataReaderProtocolStatus
            """
        @builtins.property
        def default_filter_state(self) -> DataState:
            """
            Returns the filter state for the read/take operations.

            :type: DataState
            """
        @default_filter_state.setter
        def default_filter_state(self, arg1: DataState) -> None:
            """
            Returns the filter state for the read/take operations.
            """
        @builtins.property
        def listener(self) -> ServiceRequest.DataReaderListener:
            """
            Gets or sets the listener with StatusMask.ALL

            :type: ServiceRequest.DataReaderListener
            """
        @listener.setter
        def listener(self, arg1: ServiceRequest.DataReaderListener) -> None:
            """
            Gets or sets the listener with StatusMask.ALL
            """
        @builtins.property
        def liveliness_changed_status(self) -> LivelinessChangedStatus:
            """
            Get the LivelinessChangedStatus for this DataReader.

            :type: LivelinessChangedStatus
            """
        @builtins.property
        def matched_publications(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched publication handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def qos(self) -> DataReaderQos:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.

            :type: DataReaderQos
            """
        @qos.setter
        def qos(self, arg1: DataReaderQos) -> None:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.
            """
        @builtins.property
        def requested_deadline_missed_status(self) -> RequestedDeadlineMissedStatus:
            """
            Get the RequestedDeadlineMissed status for the DataReader

            :type: RequestedDeadlineMissedStatus
            """
        @builtins.property
        def requested_incompatible_qos_status(self) -> RequestedIncompatibleQosStatus:
            """
            Get the RequestedIncompatibleQosStatus for the DataReader.

            :type: RequestedIncompatibleQosStatus
            """
        @builtins.property
        def sample_lost_status(self) -> SampleLostStatus:
            """
            Get the SampleLostStatus for the DataReader.

            :type: SampleLostStatus
            """
        @builtins.property
        def sample_rejected_status(self) -> SampleRejectedStatus:
            """
            Get the SampleRejectedStatus for the DataReader.

            :type: SampleRejectedStatus
            """
        @builtins.property
        def subscriber(self) -> Subscriber:
            """
            Returns the parent Subscriber of the DataReader.

            :type: Subscriber
            """
        @builtins.property
        def subscription_matched_status(self) -> SubscriptionMatchedStatus:
            """
            Get the SubscriptionMatchedStatus for the DataReader.

            :type: SubscriptionMatchedStatus
            """
        @builtins.property
        def topic_description(self) -> ServiceRequest.TopicDescription:
            """
            Returns the TopicDescription associated with the DataReader.

            :type: ServiceRequest.TopicDescription
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataReader.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name associated with this DataReader.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataReaderListener():
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.ServiceRequest.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class DataReaderSeq():
        def __add__(self, arg0: rti.connextdds.ServiceRequest.DataReaderSeq) -> rti.connextdds.ServiceRequest.DataReaderSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.ServiceRequest.DataReader) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.DataReaderSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.ServiceRequest.DataReaderSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.ServiceRequest.DataReader: ...
        def __iadd__(self, arg0: rti.connextdds.ServiceRequest.DataReaderSeq) -> rti.connextdds.ServiceRequest.DataReaderSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.ServiceRequest.DataReaderSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.ServiceRequest.DataReaderSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ServiceRequest.DataReader]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.ServiceRequest.DataReaderSeq: ...
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.DataReaderSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.ServiceRequest.DataReaderSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.ServiceRequest.DataReader) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.ServiceRequest.DataReaderSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.ServiceRequest.DataReader) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.ServiceRequest.DataReader) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.ServiceRequest.DataReaderSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.ServiceRequest.DataReader) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.ServiceRequest.DataReader: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.ServiceRequest.DataReader: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.ServiceRequest.DataReader) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataWriter(IEntity, IAnyDataWriter):
        def __enter__(self) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Enter a context for this DataWriter, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.DataWriter) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataWriter, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ServiceRequest.Topic) -> None: 
            """
            Creates a DataWriter in the implicit publisher with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ServiceRequest.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.ServiceRequest.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in the implicit publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.ServiceRequest.Topic) -> None: 
            """
            Creates a DataWriter in a publisher with default QoS.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.ServiceRequest.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.ServiceRequest.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in a publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
            """
            Create a typed DataWriter from an AnyDataWriter.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Create a typed DataWriter from an Entity.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Sets the DataWriterQos.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Writes a paired sample with a timestamp.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.ServiceRequest, rti.connextdds.InstanceHandle]) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Writes a paired sample with an instance handle.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.ServiceRequestTimestampedSeq) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Writes a sequence of pairs of samples with timestamps.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.ServiceRequestSeq) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Writes a sequence of samples.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.ServiceRequest) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Writes a sample.
            """
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.DataWriter) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Get the DataWriterQos.
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Publisher, arg1: rti.connextdds.ServiceRequest.Topic, arg2: rti.connextdds.DataWriterQos) -> rti.connextdds.ServiceRequest.DataWriter: ...
        def _set_related_reader_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        def _wait_for_sample_acknowledgment(self, sample_id: rti.connextdds.SampleIdentity, timeout: rti.connextdds.Duration) -> None: 
            """
            Wait for a sample to be acknowledged by the application.
            """
        def assert_liveliness(self) -> None: 
            """
            Manually asserts the liveliness of the DataWriter.
            """
        def close(self) -> None: 
            """
            Close this DataWriter.
            """
        def create_data(self) -> rti.connextdds.ServiceRequest: 
            """
            Create data of the writer's associated type and initialize it.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Dispose an instance with params.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.ServiceRequest) -> object: 
            """
            Dispose the instance associated with key_holder.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.ServiceRequest, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose the instance associated with key_holder using a timestamp
            """
        @typing.overload
        def dispose_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Dispose an instance with params.
            """
        @staticmethod
        def find_all_by_topic(publisher: rti.connextdds.Publisher, topic_name: str) -> rti.connextdds.ServiceRequest.DataWriterSeq: 
            """
            Retrieve all DataWriters for the given topic name in the publisher.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ServiceRequest.DataWriter]: 
            """
            Find DataWriter in DomainParticipant with the provided name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.ServiceRequest.DataWriter]: 
            """
            Find DataWriter in Publisher with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.ServiceRequest.DataWriter]: 
            """
            Find DataWriter in publisher with a topic name, returning the first found.
            """
        def flush(self) -> None: 
            """
            Flushes the batch in progress in the context of thecalling thread.
            """
        def is_matched_subscription_active(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            A boolean indicating whether or not the matched subscription is active.
            """
        def is_sample_app_acknowledged(self, sample_id: rti.connextdds.SampleIdentity) -> bool: 
            """
            Indicates if a sample is considered application-acknowledged.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ServiceRequest: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.ServiceRequest) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_subscription_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Get the SubscriptionBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription handle.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, locator: rti.connextdds.Locator) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription locator.
            """
        def matched_subscription_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.ServiceRequest) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.ServiceRequest, timestamp: rti.connextdds.Time) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance and specified the timestamp.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.ServiceRequest, params: rti.connextdds.WriteParams) -> rti.connextdds.InstanceHandle: 
            """
            Registers instance with parameters.
            """
        def set_listener(self, listener: rti.connextdds.ServiceRequest.DataWriterListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask for the DataWriter.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Unregister an instance with parameters.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.ServiceRequest) -> object: 
            """
            Unregister the instance associated with key_holder.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.ServiceRequest, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister the instance associate with key_holder using a timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Unregister an instance with parameters.
            """
        def wait_for_acknowledgments(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Blocks the calling thread until all data written by a reliable DataWriter is acknowledged or until the timeout expires.
            """
        def wait_for_asynchronous_publishing(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            This operation blocks the calling thread (up to max_wait) until all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        def wait_for_asynchronous_publishing_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            This function is awaitable until either a timeout of max_wait or all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.This function works with asyncio.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        @typing.overload
        def write(self, samples: rti.connextdds.ServiceRequestSeq) -> None: 
            """
            Write a sequence of samples.
            """
        @typing.overload
        def write(self, samples: rti.connextdds.ServiceRequestSeq, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sequence of samples with a timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ServiceRequest) -> None: 
            """
            Write a sample.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ServiceRequest, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with a specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ServiceRequest, handle: rti.connextdds.InstanceHandle) -> None: 
            """
            Write a sample with an instance handle.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ServiceRequest, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with an instance handle and specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.ServiceRequest, params: rti.connextdds.WriteParams) -> None: 
            """
            Write with advanced parameters.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ServiceRequest) -> object: 
            """
            Write a sample. This method is awaitable and is only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ServiceRequest, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with a specified timestamp. This methods is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ServiceRequest, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Write a sample with an instance handle. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ServiceRequest, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with an instance handle and specified timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.ServiceRequestSeq) -> object: 
            """
            Write a sequence of samples. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.ServiceRequestSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.ServiceRequestSeq, handles: rti.connextdds.InstanceHandleSeq) -> object: 
            """
            Write a sequence of samples with their instance handles. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.ServiceRequestSeq, handles: rti.connextdds.InstanceHandleSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with their instance handles and a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.ServiceRequest, params: rti.connextdds.WriteParams) -> object: 
            """
            Write with advanced parameters.
            """
        @builtins.property
        def _has_matched_subscriptions_with_related_writer(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datawriter_cache_status(self) -> DataWriterCacheStatus:
            """
            Get a copy of the cache status for this writer.

            :type: DataWriterCacheStatus
            """
        @builtins.property
        def datawriter_protocol_status(self) -> DataWriterProtocolStatus:
            """
            Get a copy of the protocol status for this writer.

            :type: DataWriterProtocolStatus
            """
        @builtins.property
        def listener(self) -> ServiceRequest.DataWriterListener:
            """
            Get the listener associated with the DataWriter or set the listener.

            :type: ServiceRequest.DataWriterListener
            """
        @listener.setter
        def listener(self, arg1: ServiceRequest.DataWriterListener) -> None:
            """
            Get the listener associated with the DataWriter or set the listener.
            """
        @builtins.property
        def liveliness_lost_status(self) -> LivelinessLostStatus:
            """
            Get a copy of the LivelinessLostStatus.

            :type: LivelinessLostStatus
            """
        @builtins.property
        def matched_subscriptions(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched subscription handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def matched_subscriptions_locators(self) -> LocatorSeq:
            """
            The locators used to communicate with matched DataReaders.

            :type: LocatorSeq
            """
        @builtins.property
        def offered_deadline_missed_status(self) -> OfferedDeadlineMissedStatus:
            """
            Get a copy of the OfferedDeadlineMissedStatus.

            :type: OfferedDeadlineMissedStatus
            """
        @builtins.property
        def offered_incompatible_qos_status(self) -> OfferedIncompatibleQosStatus:
            """
            Get a copy of the OfferedIncompatibleQosStatus

            :type: OfferedIncompatibleQosStatus
            """
        @builtins.property
        def publication_matched_status(self) -> PublicationMatchedStatus:
            """
            Get a copy of the PublicationMatchedStatus

            :type: PublicationMatchedStatus
            """
        @builtins.property
        def publisher(self) -> Publisher:
            """
            Get the Publisher that owns this DataWriter.

            :type: Publisher
            """
        @builtins.property
        def qos(self) -> DataWriterQos:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.

            :type: DataWriterQos
            """
        @qos.setter
        def qos(self, arg1: DataWriterQos) -> None:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.
            """
        @builtins.property
        def reliable_reader_activity_changed_status(self) -> ReliableReaderActivityChangedStatus:
            """
            Get a copy of the reliable reader activity changed status for this writer.

            :type: ReliableReaderActivityChangedStatus
            """
        @builtins.property
        def reliable_writer_cache_changed_status(self) -> ReliableWriterCacheChangedStatus:
            """
            Get a copy of the reliable cache status for this writer.

            :type: ReliableWriterCacheChangedStatus
            """
        @builtins.property
        def service_request_accepted_status(self) -> ServiceRequestAcceptedStatus:
            """
            Get a copy of the service request accepted status for this writer.

            :type: ServiceRequestAcceptedStatus
            """
        @builtins.property
        def topic(self) -> ServiceRequest.Topic:
            """
            Get the Topic object associated with this DataWriter.

            :type: ServiceRequest.Topic
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataWriter.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name for the topic object associated with this DataWriter.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataWriterListener():
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class DataWriterSeq():
        def __add__(self, arg0: rti.connextdds.ServiceRequest.DataWriterSeq) -> rti.connextdds.ServiceRequest.DataWriterSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.ServiceRequest.DataWriter) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.DataWriterSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.ServiceRequest.DataWriterSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.ServiceRequest.DataWriter: ...
        def __iadd__(self, arg0: rti.connextdds.ServiceRequest.DataWriterSeq) -> rti.connextdds.ServiceRequest.DataWriterSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.ServiceRequest.DataWriterSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.ServiceRequest.DataWriterSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ServiceRequest.DataWriter]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.ServiceRequest.DataWriterSeq: ...
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.DataWriterSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.ServiceRequest.DataWriterSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.ServiceRequest.DataWriter) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.ServiceRequest.DataWriterSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.ServiceRequest.DataWriter) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.ServiceRequest.DataWriter) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.ServiceRequest.DataWriterSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.ServiceRequest.DataWriter) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.ServiceRequest.DataWriter: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.ServiceRequest.DataWriter) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ITopicDescription(IEntity):
        @builtins.property
        def name(self) -> str:
            """
            The name of the entity conforming to the ITopicDescription interface.

            :type: str
            """
        @builtins.property
        def participant(self) -> DomainParticipant:
            """
            The parent DomainParticipant.

            :type: DomainParticipant
            """
        @builtins.property
        def type_name(self) -> str:
            """
            The name of the associated type.

            :type: str
            """
        pass
    class LoanedSample():
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, data: rti.connextdds.ServiceRequest, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct LoanedSample with data and info.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> ServiceRequest:
            """
            Get the data associated with the sample.

            :type: ServiceRequest
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        pass
    class LoanedSamples():
        def __enter__(self) -> rti.connextdds.ServiceRequest.LoanedSamples: 
            """
            Enter a context for the loaned samples, loan returned on context exit.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for the loaned samples, returning the resources.
            """
        def __getitem__(self, arg0: int) -> rti.connextdds.ServiceRequest.LoanedSample: 
            """
            Access a LoanedSample object in an array-like syntax
            """
        def __init__(self) -> None: 
            """
            Create an empty LoanedSamples object.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.ServiceRequest.LoanedSample]: ...
        def __len__(self) -> int: 
            """
            Get the number of samples in the loan.
            """
        def return_loan(self) -> None: 
            """
            Returns the loan to the DataReader.
            """
        @builtins.property
        def length(self) -> int:
            """
            Get the number of samples in the loan.

            :type: int
            """
        pass
    class NoOpDataReaderListener(ServiceRequest.DataReaderListener):
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.ServiceRequest.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.ServiceRequest.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class NoOpDataWriterListener(ServiceRequest.DataWriterListener):
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.ServiceRequest.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class NoOpTopicListener(ServiceRequest.TopicListener):
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.ServiceRequest.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class Sample():
        @typing.overload
        def __init__(self, data: rti.connextdds.ServiceRequest, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct Sample with data and info.
            """
        @typing.overload
        def __init__(self, sample: rti.connextdds.ServiceRequest.Sample) -> None: 
            """
            Copy constructor.
            """
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, loaned_sample: rti.connextdds.ServiceRequest.LoanedSample) -> None: 
            """
            Construct a sample with a loaned sample.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> ServiceRequest:
            """
            The data associated with the sample.

            :type: ServiceRequest
            """
        @data.setter
        def data(self, arg1: ServiceRequest) -> None:
            """
            The data associated with the sample.
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        @info.setter
        def info(self, arg1: SampleInfo) -> None:
            """
            Get the info associated with the sample.
            """
        pass
    class SharedSamples():
        def __getitem__(self, arg0: int) -> rti.connextdds.ServiceRequest.LoanedSample: 
            """
            Get the sample at the specified index.
            """
        def __init__(self, loaned_samples: rti.connextdds.ServiceRequest.LoanedSamples) -> None: 
            """
            Constructs an instance of SharedSamples, removing ownership of the loan from the Loaned Samples.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.ServiceRequest.LoanedSample]: 
            """
            Make a sample iterator
            """
        def __len__(self) -> int: 
            """
            Returns the number of samples.
            """
        pass
    class Topic(ServiceRequest.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.Topic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast an Entity to a Topic.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.ServiceRequest.ITopicDescription) -> None: 
            """
            Cast an ITopicDescription to a Topic.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
            """
            Create a typed Topic from an AnyTopic.
            """
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.Topic) -> bool: 
            """
            Test for inequality.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.ServiceRequest.Topic]: 
            """
            Look up a Topic by its name in the DomainParticipant.
            """
        def set_listener(self, listener: rti.connextdds.ServiceRequest.TopicListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask.
            """
        @builtins.property
        def inconsistent_topic_status(self) -> InconsistentTopicStatus:
            """
            Get a copy of the current InconsistentTopicStatus for this Topic.

            :type: InconsistentTopicStatus
            """
        @builtins.property
        def listener(self) -> ServiceRequest.TopicListener:
            """
            The listener.

            :type: ServiceRequest.TopicListener
            """
        @listener.setter
        def listener(self, arg1: ServiceRequest.TopicListener) -> None:
            """
            The listener.
            """
        @builtins.property
        def qos(self) -> TopicQos:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.

            :type: TopicQos
            """
        @qos.setter
        def qos(self, arg1: TopicQos) -> None:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.
            """
        __hash__: NoneType
        pass
    class TopicDescription(ServiceRequest.ITopicDescription, IEntity):
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.TopicDescription) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.ServiceRequest.ITopicDescription) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.TopicDescription) -> bool: 
            """
            Test for inequality.
            """
        __hash__: NoneType
        pass
    class TopicListener():
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.ServiceRequest.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class TopicSeq():
        def __add__(self, arg0: rti.connextdds.ServiceRequest.TopicSeq) -> rti.connextdds.ServiceRequest.TopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.ServiceRequest.Topic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.ServiceRequest.TopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.ServiceRequest.TopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.ServiceRequest.Topic: ...
        def __iadd__(self, arg0: rti.connextdds.ServiceRequest.TopicSeq) -> rti.connextdds.ServiceRequest.TopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.ServiceRequest.TopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.ServiceRequest.TopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ServiceRequest.Topic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.ServiceRequest.TopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.ServiceRequest.TopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.ServiceRequest.TopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.ServiceRequest.Topic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.ServiceRequest.TopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.ServiceRequest.Topic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.ServiceRequest.Topic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.ServiceRequest.TopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.ServiceRequest.Topic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.ServiceRequest.Topic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.ServiceRequest.Topic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.ServiceRequest.Topic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ValidLoanedSamples():
        def __enter__(self) -> rti.connextdds.ServiceRequest.ValidLoanedSamples: ...
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.ServiceRequest.LoanedSample]: ...
        pass
    class WriterContentFilter(ServiceRequest.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def writer_attach(self) -> typing.Optional[object]: 
            """
            A writer-side filtering API to create some state that can facilitate filtering on the writer side.
            """
        def writer_compile(self, writer_filter_data: typing.Optional[object], property: rti.connextdds.ExpressionProperty, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_detach(self, writer_filter_data: typing.Optional[object]) -> None: 
            """
            A writer-side filtering API to clean up a previously created state using writer_attach.
            """
        def writer_evaluate(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.ServiceRequest, meta_data: rti.connextdds.FilterSampleInfo) -> rti.connextdds.CookieVector: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_finalize(self, writer_filter_data: typing.Optional[object], cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to clean up a previously compiled instance of the content filter.
            """
        def writer_return_loan(self, writer_filter_data: typing.Optional[object], cookies: rti.connextdds.CookieVector) -> None: 
            """
            A writer-side filtering API to return the loan on the list of DataReaders returned by writer_evaluate.
            """
        pass
    class WriterContentFilterHelper(ServiceRequest.WriterContentFilter, ServiceRequest.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def add_cookie(self, cookie: rti.connextdds.Cookie) -> None: 
            """
            A helper function which will add a Cookie to the Cookie sequence that is then returned by the writer_evaluate function.
            """
        def writer_evaluate_helper(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.ServiceRequest, meta_data: rti.connextdds.FilterSampleInfo) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        pass
    def __eq__(self, arg0: rti.connextdds.ServiceRequest) -> bool: 
        """
        Test for equality.
        """
    def __ne__(self, arg0: rti.connextdds.ServiceRequest) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def instance_id(self) -> Guid:
        """
        Get the instance id of the request.

        :type: Guid
        """
    @builtins.property
    def request_body(self) -> ByteVector:
        """
        Get the request body of the request.

        :type: ByteVector
        """
    @builtins.property
    def service_id(self) -> ServiceRequestId:
        """
        The service id of the request.

        :type: ServiceRequestId
        """
    __hash__: NoneType
    topic_name: str
    pass
class ServiceRequestAcceptedStatus():
    """
    Information about the service_request_accepted status
    Currently, the only service that causes the ServiceRequestAcceptedStatus to be triggered is TopicQuery service. A ServiceRequest is accepted when a DataWriter matches with a DataReader that has created a TopicQuery.
    This status is also changed (and the listener, if any, called) when a ServiceRequest has been cancelled, or deleted. This will happen when a DataReader deletes a TopicQuery using TopicQuery.close().
    """
    @builtins.property
    def current_count(self) -> EventCount32:
        """
        The current number of ServiceRequests that have been accepted by this DataWriter.

        :type: EventCount32
        """
    @builtins.property
    def last_request_handle(self) -> InstanceHandle:
        """
        A handle to the last ServiceRequest that caused the DataWriter's status to change.

        :type: InstanceHandle
        """
    @builtins.property
    def service_id(self) -> ServiceRequestId:
        """
        ID of the service to which the accepted Request belongs.

        :type: ServiceRequestId
        """
    @builtins.property
    def total_count(self) -> EventCount32:
        """
        The total number of ServiceRequests that have been accepted by this DataWriter.

        :type: EventCount32
        """
    pass
class ServiceRequestId():
    class ServiceRequestId():
        """
        Members:

          UNKNOWN : An unknown service.

          TOPIC_QUERY : The topic query service.

          LOCATOR_REACHABILITY : The locator reachability service.

          MONITORING_LIBRARY_COMMAND : The Monitoring Library 2.0 command service.

          MONITORING_LIBRARY_REPLY : The Monitoring Library 2.0 reply service.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        LOCATOR_REACHABILITY: rti.connextdds.ServiceRequestId.ServiceRequestId
        MONITORING_LIBRARY_COMMAND: rti.connextdds.ServiceRequestId.ServiceRequestId
        MONITORING_LIBRARY_REPLY: rti.connextdds.ServiceRequestId.ServiceRequestId
        TOPIC_QUERY: rti.connextdds.ServiceRequestId.ServiceRequestId
        UNKNOWN: rti.connextdds.ServiceRequestId.ServiceRequestId
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.ServiceRequestId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.ServiceRequestId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.ServiceRequestId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ServiceRequestId.ServiceRequestId) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.ServiceRequestId.ServiceRequestId: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.ServiceRequestId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.ServiceRequestId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.ServiceRequestId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> ServiceRequestId.ServiceRequestId:
        """
        Retrieves the actual enumerated value.

        :type: ServiceRequestId.ServiceRequestId
        """
    LOCATOR_REACHABILITY: rti.connextdds.ServiceRequestId.ServiceRequestId
    MONITORING_LIBRARY_COMMAND: rti.connextdds.ServiceRequestId.ServiceRequestId
    MONITORING_LIBRARY_REPLY: rti.connextdds.ServiceRequestId.ServiceRequestId
    TOPIC_QUERY: rti.connextdds.ServiceRequestId.ServiceRequestId
    UNKNOWN: rti.connextdds.ServiceRequestId.ServiceRequestId
    __hash__: NoneType
    pass
class ServiceRequestSeq():
    def __add__(self, arg0: rti.connextdds.ServiceRequestSeq) -> rti.connextdds.ServiceRequestSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.ServiceRequest) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.ServiceRequestSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.ServiceRequestSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.ServiceRequest: ...
    def __iadd__(self, arg0: rti.connextdds.ServiceRequestSeq) -> rti.connextdds.ServiceRequestSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.ServiceRequestSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ServiceRequestSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.ServiceRequest]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.ServiceRequestSeq: ...
    def __ne__(self, arg0: rti.connextdds.ServiceRequestSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.ServiceRequestSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.ServiceRequest) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.ServiceRequestSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.ServiceRequest) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.ServiceRequest) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.ServiceRequestSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.ServiceRequest) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.ServiceRequest: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.ServiceRequest: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.ServiceRequest) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class ServiceRequestTimestampedSeq():
    def __add__(self, arg0: rti.connextdds.ServiceRequestTimestampedSeq) -> rti.connextdds.ServiceRequestTimestampedSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.ServiceRequestTimestampedSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.ServiceRequestTimestampedSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]: ...
    def __iadd__(self, arg0: rti.connextdds.ServiceRequestTimestampedSeq) -> rti.connextdds.ServiceRequestTimestampedSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.ServiceRequestTimestampedSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ServiceRequestTimestampedSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.ServiceRequestTimestampedSeq: ...
    def __ne__(self, arg0: rti.connextdds.ServiceRequestTimestampedSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.ServiceRequestTimestampedSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.ServiceRequestTimestampedSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.ServiceRequestTimestampedSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: tuple[rti.connextdds.ServiceRequest, rti.connextdds.Time]) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
ShortSeq = Int16Seq
ShortType = Int16Type
SignedOctetType = Int8Type
class StatusCondition(ICondition):
    def __eq__(self, arg0: rti.connextdds.StatusCondition) -> bool: 
        """
        Compare StatusCondition objects for equality.
        """
    @typing.overload
    def __init__(self, entity: rti.connextdds.IEntity) -> None: 
        """
        Obtain a reference to an entity's StatusCondition object
        """
    @typing.overload
    def __init__(self, condition: rti.connextdds.ICondition) -> None: 
        """
        Downcast a Condition to a StatusCondition.
        """
    def __ne__(self, arg0: rti.connextdds.StatusCondition) -> bool: 
        """
        Compare StatusCondition objects for inequality.
        """
    def dispatch(self) -> None: 
        """
        Dispatches the functions registered with the condition.
        """
    def reset_handler(self) -> None: 
        """
        Resets the handler for this StatusCondition.
        """
    def set_handler(self, func: typing.Callable[[rti.connextdds.StatusCondition], None]) -> None: 
        """
        Set a handler function for this StatusCondition.
        """
    @builtins.property
    def enabled_statuses(self) -> StatusMask:
        """
        Get/set the enabled statuses for this condition.

        :type: StatusMask
        """
    @enabled_statuses.setter
    def enabled_statuses(self, arg1: StatusMask) -> None:
        """
        Get/set the enabled statuses for this condition.
        """
    @builtins.property
    def entity(self) -> Entity:
        """
        Get the Entity associated with this StatusCondition.

        :type: Entity
        """
    @builtins.property
    def trigger_value(self) -> bool:
        """
        The trigger value of the condition.

        :type: bool
        """
    __hash__: NoneType
    pass
class StatusMask():
    """
    A set of statuses.
    """
    def __and__(self, arg0: rti.connextdds.StatusMask) -> rti.connextdds.StatusMask: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.StatusMask) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.StatusMask) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.StatusMask) -> rti.connextdds.StatusMask: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.StatusMask: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a StatusMask equivalent to StatusMask.NONE
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.StatusMask) -> rti.connextdds.StatusMask: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.StatusMask: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.StatusMask) -> rti.connextdds.StatusMask: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.StatusMask: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.StatusMask) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.StatusMask) -> rti.connextdds.StatusMask: 
        """
        Bitwise logical OR of masks.
        """
    def __repr__(self) -> str: 
        """
        Convert mask to string.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.StatusMask: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: 
        """
        Convert mask to string.
        """
    def __xor__(self, arg0: rti.connextdds.StatusMask) -> rti.connextdds.StatusMask: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.StatusMask: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.StatusMask: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.StatusMask: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.StatusMask: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.StatusMask: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.StatusMask: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ALL: rti.connextdds.StatusMask
    DATAREADER_CACHE: rti.connextdds.StatusMask
    DATAREADER_PROTOCOL: rti.connextdds.StatusMask
    DATAWRITER_APPLICATION_ACKNOWLEDGMENT: rti.connextdds.StatusMask
    DATAWRITER_CACHE: rti.connextdds.StatusMask
    DATAWRITER_INSTANCE_REPLACED: rti.connextdds.StatusMask
    DATAWRITER_PROTOCOL: rti.connextdds.StatusMask
    DATA_AVAILABLE: rti.connextdds.StatusMask
    DATA_ON_READERS: rti.connextdds.StatusMask
    DESTINATION_UNREACHABLE: rti.connextdds.StatusMask
    INCONSISTENT_TOPIC: rti.connextdds.StatusMask
    INVALID_LOCAL_IDENTITY_ADVANCE_NOTICE: rti.connextdds.StatusMask
    LIVELINESS_CHANGED: rti.connextdds.StatusMask
    LIVELINESS_LOST: rti.connextdds.StatusMask
    NONE: rti.connextdds.StatusMask
    OFFERED_DEADLINE_MISSED: rti.connextdds.StatusMask
    OFFERED_INCOMPATIBLE_QOS: rti.connextdds.StatusMask
    PUBLICATION_MATCHED: rti.connextdds.StatusMask
    RELIABLE_READER_ACTIVITY_CHANGED: rti.connextdds.StatusMask
    RELIABLE_WRITER_CACHE_CHANGED: rti.connextdds.StatusMask
    REQUESTED_DEADLINE_MISSED: rti.connextdds.StatusMask
    REQUESTED_INCOMPATIBLE_QOS: rti.connextdds.StatusMask
    SAMPLE_LOST: rti.connextdds.StatusMask
    SAMPLE_REJECTED: rti.connextdds.StatusMask
    SAMPLE_REMOVED: rti.connextdds.StatusMask
    SERVICE_REQUEST_ACCEPTED: rti.connextdds.StatusMask
    SUBSCRIPTION_MATCHED: rti.connextdds.StatusMask
    __hash__: NoneType
    pass
class StreamKind():
    def __and__(self, arg0: rti.connextdds.StreamKind) -> rti.connextdds.StreamKind: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> rti.connextdds.StreamKind: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.StreamKind) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.StreamKind) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.StreamKind) -> rti.connextdds.StreamKind: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.StreamKind: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a StreamKind with nothing enabled.
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.StreamKind) -> rti.connextdds.StreamKind: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.StreamKind: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.StreamKind) -> rti.connextdds.StreamKind: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.StreamKind: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.StreamKind) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.StreamKind) -> rti.connextdds.StreamKind: 
        """
        Bitwise logical OR of masks.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.StreamKind: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: ...
    def __xor__(self, arg0: rti.connextdds.StreamKind) -> rti.connextdds.StreamKind: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.StreamKind: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.StreamKind: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.StreamKind: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.StreamKind: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.StreamKind: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.StreamKind: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ANY: rti.connextdds.StreamKind
    LIVE: rti.connextdds.StreamKind
    TOPIC_QUERY: rti.connextdds.StreamKind
    __hash__: NoneType
    pass
class StringMap():
    def __bool__(self) -> bool: 
        """
        Check whether the map is nonempty
        """
    @typing.overload
    def __contains__(self, arg0: str) -> bool: ...
    @typing.overload
    def __contains__(self, arg0: object) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> str: ...
    def __init__(self) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this map.
        """
    def __setitem__(self, arg0: str, arg1: str) -> None: ...
    def items(self) -> rti.connextdds.ItemsView: ...
    def keys(self) -> rti.connextdds.KeysView: ...
    def values(self) -> rti.connextdds.ValuesView: ...
    pass
class StringPairSeq():
    def __add__(self, arg0: rti.connextdds.StringPairSeq) -> rti.connextdds.StringPairSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: tuple[str, str]) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.StringPairSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.StringPairSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> tuple[str, str]: ...
    def __iadd__(self, arg0: rti.connextdds.StringPairSeq) -> rti.connextdds.StringPairSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.StringPairSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.StringPairSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[tuple[str, str]]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.StringPairSeq: ...
    def __ne__(self, arg0: rti.connextdds.StringPairSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.StringPairSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: tuple[str, str]) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.StringPairSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: tuple[str, str]) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: tuple[str, str]) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.StringPairSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: tuple[str, str]) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> tuple[str, str]: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> tuple[str, str]: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: tuple[str, str]) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class StringSeq():
    def __add__(self, arg0: rti.connextdds.StringSeq) -> rti.connextdds.StringSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: str) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.StringSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.StringSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> str: ...
    def __iadd__(self, arg0: rti.connextdds.StringSeq) -> rti.connextdds.StringSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.StringSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.StringSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.StringSeq: ...
    def __ne__(self, arg0: rti.connextdds.StringSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.StringSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: str) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.StringSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: str) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: str) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.StringSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: str) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> str: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> str: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: str) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class StringType(UnidimensionalCollectionType, CollectionType, DynamicType):
    def __eq__(self, arg0: rti.connextdds.StringType) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, bounds: int) -> None: 
        """
        Creates a bounded string.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an unbounded string.
        """
    def __ne__(self, arg0: rti.connextdds.StringType) -> bool: 
        """
        Test for inequality.
        """
    UNBOUNDED: int
    __hash__: NoneType
    pass
class StructType(ACTMember, DynamicType):
    def __eq__(self, arg0: rti.connextdds.StructType) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, name: str) -> None: 
        """
        Creates an empty StructType.
        """
    @typing.overload
    def __init__(self, name: str, extensibility: rti.connextdds.ExtensibilityKind) -> None: 
        """
        Creates an empty StructType with a specified extensibility.
        """
    @typing.overload
    def __init__(self, name: str, parent: rti.connextdds.StructType) -> None: 
        """
        Create an empty StructType with a base type.
        """
    @typing.overload
    def __init__(self, name: str, parent: rti.connextdds.StructType, extensibility: rti.connextdds.ExtensibilityKind) -> None: 
        """
        Creates an empty StructType with a base type and specified extensibility.
        """
    @typing.overload
    def __init__(self, name: str, members: rti.connextdds.MemberSeq) -> None: 
        """
        Create a StructType with the provided members.
        """
    @typing.overload
    def __init__(self, name: str, members: rti.connextdds.MemberSeq, extensibility: rti.connextdds.ExtensibilityKind) -> None: 
        """
        Creates a StructType with the provided members and specified extensibility.
        """
    @typing.overload
    def __init__(self, name: str, parent: rti.connextdds.StructType, members: rti.connextdds.MemberSeq) -> None: 
        """
        Create a StructType with a base type and the provided members.
        """
    @typing.overload
    def __init__(self, name: str, parent: rti.connextdds.StructType, members: rti.connextdds.MemberSeq, extensibility: rti.connextdds.ExtensibilityKind) -> None: 
        """
        Creates a StructType with a base types, the provided members, and the specified extensibility.
        """
    @typing.overload
    def __init__(self, type: rti.connextdds.DynamicType) -> None: 
        """
        Cast a DynamicType to a StructType
        """
    def __ne__(self, arg0: rti.connextdds.StructType) -> bool: 
        """
        Test for inequality.
        """
    def add_member(self, member: rti.connextdds.Member) -> rti.connextdds.StructType: 
        """
        Adds a member at the end.
        """
    def add_members(self, members: rti.connextdds.MemberSeq) -> rti.connextdds.StructType: 
        """
        Adds all members of the sequence to the end.
        """
    def find_member_by_id(self, member_id: int) -> int: 
        """
        Get the index of the member with a specfic ID.
        """
    @builtins.property
    def extensibility_kind(self) -> ExtensibilityKind:
        """
        Struct's extensibility kind.

        :type: ExtensibilityKind
        """
    @extensibility_kind.setter
    def extensibility_kind(self, arg1: ExtensibilityKind) -> None:
        """
        Struct's extensibility kind.
        """
    @builtins.property
    def has_parent(self) -> bool:
        """
        Indicates if this type has a base type.

        :type: bool
        """
    @builtins.property
    def parent(self) -> StructType:
        """
        Retrieve the base type.

        :type: StructType
        """
    INVALID_INDEX: int
    __hash__: NoneType
    pass
class Subscriber(IEntity):
    def __eq__(self, arg0: rti.connextdds.Subscriber) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, participant: rti.connextdds.DomainParticipant) -> None: 
        """
        Create a subscriber under a DomainParticipant.
        """
    @typing.overload
    def __init__(self, participant: rti.connextdds.DomainParticipant, qos: rti.connextdds.SubscriberQos, listener: rti.connextdds.SubscriberListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
        """
        Create a Subscriber under a DomainParticipant with a listener.
        """
    @typing.overload
    def __init__(self, entity: rti.connextdds.IEntity) -> None: 
        """
        Cast an Entity to a Subscriber.
        """
    def __ne__(self, arg0: rti.connextdds.Subscriber) -> bool: 
        """
        Test for inequality.
        """
    def find_datareader(self, name: str) -> typing.Optional[rti.connextdds.AnyDataReader]: 
        """
        Find a DataReader in this Subscriber by its name.
        """
    def find_datareader_by_topic_name(self, topic_name: str) -> typing.Optional[rti.connextdds.AnyDataReader]: 
        """
        Find a DataReader in this Subscriber by its topic name. If more than one exists for this Topic, the first one found is returned.
        """
    @typing.overload
    def find_datareaders(self) -> rti.connextdds.AnyDataReaderSeq: 
        """
        Find all DataReaders in the Subscriber.
        """
    @typing.overload
    def find_datareaders(self, arg0: rti.connextdds.DataState) -> rti.connextdds.AnyDataReaderSeq: 
        """
        Find all DataReaders that contain samples of the given DataState in the Subscriber.
        """
    @typing.overload
    def find_datareaders(self, arg0: str) -> rti.connextdds.AnyDataReaderSeq: 
        """
        Find all DataReaders for a given topic name
        """
    def notify_datareaders(self) -> None: 
        """
        This operation invokes the operation on_data_available on the DataReaderListener objects attached to contained DataReader entities with a DATA_AVAILABLE status that is considered changed
        """
    def set_listener(self, listener: rti.connextdds.SubscriberListener, event_mask: rti.connextdds.StatusMask) -> None: 
        """
        Bind the listener and event mask to the Subscriber.
        """
    @builtins.property
    def default_datareader_qos(self) -> DataReaderQos:
        """
        The default DataReaderQos.

        This property's getter returns a deep copy.

        :type: DataReaderQos
        """
    @default_datareader_qos.setter
    def default_datareader_qos(self, arg1: DataReaderQos) -> None:
        """
        The default DataReaderQos.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def listener(self) -> SubscriberListener:
        """
        Get the listener.

        :type: SubscriberListener
        """
    @listener.setter
    def listener(self, arg1: SubscriberListener) -> None:
        """
        Get the listener.
        """
    @builtins.property
    def participant(self) -> DomainParticipant:
        """
        Get the parent DomainParticipant for this Subscriber.

        :type: DomainParticipant
        """
    @builtins.property
    def qos(self) -> SubscriberQos:
        """
        The SubscriberQos for this Subscriber.

        This property's getter returns a deep copy.

        :type: SubscriberQos
        """
    @qos.setter
    def qos(self, arg1: SubscriberQos) -> None:
        """
        The SubscriberQos for this Subscriber.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class NoOpDomainParticipantListener(DomainParticipantListener, PublisherListener, AnyDataWriterListener, SubscriberListener, AnyDataReaderListener, AnyTopicListener):
    def __init__(self) -> None: ...
    def on_invalid_local_identity_status_advance_notice(self, arg0: rti.connextdds.DomainParticipant, arg1: rti.connextdds.InvalidLocalIdentityAdvanceNoticeStatus) -> None: 
        """
        On invalid local identity status advance notice callback
        """
    pass
class SubscriberQos():
    def __eq__(self, arg0: rti.connextdds.SubscriberQos) -> bool: 
        """
        Test for equality
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a SubscriberQos with the default value for each policy.
        """
    @typing.overload
    def __init__(self, subscriber: rti.connextdds.Subscriber) -> None: 
        """
        Create a SubscriberQos with settings equivalent to those of the provided Subscriber object.
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.SubscriberQos) -> None: 
        """
        Create a copy of a SubscriberQos object.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Presentation) -> rti.connextdds.SubscriberQos: 
        """
        Set the PresentationQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Partition) -> rti.connextdds.SubscriberQos: 
        """
        Set the PartitionQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.GroupData) -> rti.connextdds.SubscriberQos: 
        """
        Set the GroupDataQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityFactory) -> rti.connextdds.SubscriberQos: 
        """
        Set the EntityFactoryQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.SubscriberQos: 
        """
        Set the EntityNameQoS.
        """
    def __ne__(self, arg0: rti.connextdds.SubscriberQos) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Presentation) -> rti.connextdds.SubscriberQos: 
        """
        Get the PresentationQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Partition) -> rti.connextdds.SubscriberQos: 
        """
        Get the PartitionQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.GroupData) -> rti.connextdds.SubscriberQos: 
        """
        Get the GroupDataQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityFactory) -> rti.connextdds.SubscriberQos: 
        """
        Get the EntityFactoryQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.EntityName) -> rti.connextdds.SubscriberQos: 
        """
        Get the EntityNameQoS.
        """
    def __str__(self) -> str: ...
    def to_string(self, format: rti.connextdds.QosPrintFormat = QosPrintFormat(), base: typing.Optional[rti.connextdds.SubscriberQos] = None, print_all: bool = False) -> str: 
        """
        Convert QoS to string based on params.
        """
    @builtins.property
    def entity_factory(self) -> EntityFactory:
        """
        Get/set EntityFactory QoS.

        :type: EntityFactory
        """
    @entity_factory.setter
    def entity_factory(self, arg1: EntityFactory) -> None:
        """
        Get/set EntityFactory QoS.
        """
    @builtins.property
    def entity_name(self) -> EntityName:
        """
        Get/set EntityName QoS.

        :type: EntityName
        """
    @entity_name.setter
    def entity_name(self, arg1: EntityName) -> None:
        """
        Get/set EntityName QoS.
        """
    @builtins.property
    def group_data(self) -> GroupData:
        """
        Get/set GroupData QoS.

        :type: GroupData
        """
    @group_data.setter
    def group_data(self, arg1: GroupData) -> None:
        """
        Get/set GroupData QoS.
        """
    @builtins.property
    def partition(self) -> Partition:
        """
        Get/set Partition QoS.

        :type: Partition
        """
    @partition.setter
    def partition(self, arg1: Partition) -> None:
        """
        Get/set Partition QoS.
        """
    @builtins.property
    def presentation(self) -> Presentation:
        """
        Get/set Presentation QoS.

        :type: Presentation
        """
    @presentation.setter
    def presentation(self, arg1: Presentation) -> None:
        """
        Get/set Presentation QoS.
        """
    __hash__: NoneType
    pass
class SubscriberSeq():
    def __add__(self, arg0: rti.connextdds.SubscriberSeq) -> rti.connextdds.SubscriberSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.Subscriber) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.SubscriberSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.SubscriberSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Subscriber: ...
    def __iadd__(self, arg0: rti.connextdds.SubscriberSeq) -> rti.connextdds.SubscriberSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.SubscriberSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.SubscriberSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.Subscriber]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.SubscriberSeq: ...
    def __ne__(self, arg0: rti.connextdds.SubscriberSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.SubscriberSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Subscriber) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.SubscriberSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.Subscriber) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.Subscriber) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.SubscriberSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.Subscriber) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.Subscriber: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.Subscriber: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.Subscriber) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class SubscriptionBuiltinTopicData():
    class ContentFilter(ContentFilterBase):
        def __init__(self) -> None: ...
        def compile(self, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, old_compile_data: typing.Optional[object]) -> typing.Optional[object]: 
            """
            Compile an instance of the content filter according to the filter expression and parameters of the given data type.
            """
        def evaluate(self, compile_data: typing.Optional[object], sample: rti.connextdds.SubscriptionBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> bool: 
            """
            Evaluate whether the sample is passing the filter or not according to the sample content.
            """
        def finalize(self, compile_data: typing.Optional[object]) -> None: 
            """
            A previously compiled instance of the content filter is no longer in use and resources can now be cleaned up.
            """
        pass
    class ContentFilteredTopic(SubscriptionBuiltinTopicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic, name: str, contentfilter: rti.connextdds.Filter) -> None: 
            """
            Create a ContentFilteredTopic with a name and Filter.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.SubscriptionBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast a TopicDescription to a ContentFilteredTopic.
            """
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Test for inequality.
            """
        def append_to_expression_parameter(self, index: int, extension: str) -> None: 
            """
            Append the extension to the end of parameter at the provided index, separated by a comma.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic]: 
            """
            Look up a ContentFilteredTopic by its name in the DomainParticipant.
            """
        def remove_from_expression_parameter(self, index: int, remove_term: str) -> None: 
            """
            Removes the specified term from the parameter at the provided index.
            """
        def set_filter(self, arg0: rti.connextdds.Filter) -> None: 
            """
            Set the filter.
            """
        @builtins.property
        def filter_expression(self) -> str:
            """
            Get the filter expression

            :type: str
            """
        @builtins.property
        def filter_parameters(self) -> StringSeq:
            """
            Get/set the filter parameters.

            :type: StringSeq
            """
        @filter_parameters.setter
        def filter_parameters(self, arg1: StringSeq) -> None:
            """
            Get/set the filter parameters.
            """
        @builtins.property
        def topic(self) -> SubscriptionBuiltinTopicData.Topic:
            """
            Get the underlying Topic.

            :type: SubscriptionBuiltinTopicData.Topic
            """
        __hash__: NoneType
        pass
    class ContentFilteredTopicSeq():
        def __add__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic: ...
        def __iadd__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataReader(IDataReader, IEntity, IAnyDataReader):
        class Selector():
            def __init__(self, datareader: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> None: 
                """
                Create a Selector for a DataReader to read/take based on selected conditions
                """
            def condition(self, condition: rti.connextdds.IReadCondition) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader.Selector: 
                """
                Select samples based on a ReadCondition.
                """
            def content(self, query: rti.connextdds.Query) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader.Selector: 
                """
                Select samples based on a Query.
                """
            def instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader.Selector: 
                """
                Select a specific instance to read/take.
                """
            def max_samples(self, max: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader.Selector: 
                """
                Limit the number of samples read/taken by the Select.
                """
            def next_instance(self, previous: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader.Selector: 
                """
                Select the instance after the specified instance to read/take.
                """
            def read(self) -> list: 
                """
                Read copies of available samples (data and info) based on the Selector settings.
                """
            def read_data(self) -> list: 
                """
                Read copies of available valid data based on the Selector settings.
                """
            def read_loaned(self) -> rti.connextdds.SubscriptionBuiltinTopicData.LoanedSamples: 
                """
                Take available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            def state(self, state: rti.connextdds.DataState) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader.Selector: 
                """
                Select samples with a specified data state.
                """
            def take(self) -> list: 
                """
                Take copies of available samples (data and info) based on the Selector settings.
                """
            def take_data(self) -> list: 
                """
                Take copies of available valid data based on the Selector settings.
                """
            def take_loaned(self) -> rti.connextdds.SubscriptionBuiltinTopicData.LoanedSamples: 
                """
                Read available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            pass
        def __enter__(self) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader: 
            """
            Enter a context for this DataReader, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataReader, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> None: 
            """
            Create a DataReader in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in the implicit subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> None: 
            """
            Create a DataReader.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in a subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.SubscriptionBuiltinTopicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
            """
            Get a typed DataReader from an AnyDataReader.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Get a typed DataReader from an Entity.
            """
        def __lshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader: 
            """
            Set the DataReaderQos for this DataReader.
            """
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader: 
            """
            Get the DataReaderQos from this DataReader
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Subscriber, arg1: rti.connextdds.SubscriptionBuiltinTopicData.TopicDescription, arg2: rti.connextdds.DataReaderQos) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader: ...
        def _set_related_writer_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        @typing.overload
        def acknowledge_all(self) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_all(self, arg0: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo) -> None: 
            """
            Acknowledge a single sample.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo, ack_response_data: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge a single sample with ack response data.
            """
        def close(self) -> None: 
            """
            Close this DataReader.
            """
        @staticmethod
        def find_all_by_topic(subscriber: rti.connextdds.Subscriber, topic_name: str) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq: 
            """
            Retrieve all DataReaders for the given topic name in the subscriber.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.SubscriptionBuiltinTopicData.DataReader]: 
            """
            Find DataReader in DomainParticipant with the DataReader's name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.SubscriptionBuiltinTopicData.DataReader]: 
            """
            Find DataReader in Subscriber with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.SubscriptionBuiltinTopicData.DataReader]: 
            """
            Find DataReader in Subscriber with a topic name, returning the first found.
            """
        def is_matched_publication_alive(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            Check if a matched publication is alive.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_publication_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Get the PublicationBuiltinTopicData for a publication matched to this DataReader.
            """
        def matched_publication_datareader_protocol_status(self, publication_handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReaderProtocolStatus: 
            """
            Get the DataReaderProtocolStatus for the DataReader based on the matched publication handle.
            """
        def matched_publication_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a publication matched to this DataReader.
            """
        def read(self) -> list: 
            """
            Read copies of all available samples (data and info).
            """
        def read_data(self) -> list: 
            """
            Read copies of all available valid data.
            """
        def read_loaned(self) -> rti.connextdds.SubscriptionBuiltinTopicData.LoanedSamples: 
            """
            Read all available samples (data and info) and return them in a loaned container.
            """
        @staticmethod
        def select(*args, **kwargs) -> typing.Any: 
            """
            Get a Selector to perform complex data selections, such as per-instance selection, content, and status filtering.
            """
        def set_listener(self, listener: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and associated event mask.
            """
        def take(self) -> list: 
            """
            Take copies of all available samples (data and info).
            """
        def take_data(self) -> list: 
            """
            Take copies of all available valid data.
            """
        def take_loaned(self) -> rti.connextdds.SubscriptionBuiltinTopicData.LoanedSamples: 
            """
            Take all available samples (data and info) and return them in a loaned container.
            """
        def wait_for_historical_data(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind.
            """
        def wait_for_historical_data_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind. This call is awaitable and only for use with asyncio.
            """
        @builtins.property
        def _has_matched_publications_with_related_reader(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datareader_cache_status(self) -> DataReaderCacheStatus:
            """
            Get the DataReaderCacheStatus for the DataReader.

            :type: DataReaderCacheStatus
            """
        @builtins.property
        def datareader_protocol_status(self) -> DataReaderProtocolStatus:
            """
            Get the DataReaderProtocolStatus for the DataReader.

            :type: DataReaderProtocolStatus
            """
        @builtins.property
        def default_filter_state(self) -> DataState:
            """
            Returns the filter state for the read/take operations.

            :type: DataState
            """
        @default_filter_state.setter
        def default_filter_state(self, arg1: DataState) -> None:
            """
            Returns the filter state for the read/take operations.
            """
        @builtins.property
        def listener(self) -> SubscriptionBuiltinTopicData.DataReaderListener:
            """
            Gets or sets the listener with StatusMask.ALL

            :type: SubscriptionBuiltinTopicData.DataReaderListener
            """
        @listener.setter
        def listener(self, arg1: SubscriptionBuiltinTopicData.DataReaderListener) -> None:
            """
            Gets or sets the listener with StatusMask.ALL
            """
        @builtins.property
        def liveliness_changed_status(self) -> LivelinessChangedStatus:
            """
            Get the LivelinessChangedStatus for this DataReader.

            :type: LivelinessChangedStatus
            """
        @builtins.property
        def matched_publications(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched publication handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def qos(self) -> DataReaderQos:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.

            :type: DataReaderQos
            """
        @qos.setter
        def qos(self, arg1: DataReaderQos) -> None:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.
            """
        @builtins.property
        def requested_deadline_missed_status(self) -> RequestedDeadlineMissedStatus:
            """
            Get the RequestedDeadlineMissed status for the DataReader

            :type: RequestedDeadlineMissedStatus
            """
        @builtins.property
        def requested_incompatible_qos_status(self) -> RequestedIncompatibleQosStatus:
            """
            Get the RequestedIncompatibleQosStatus for the DataReader.

            :type: RequestedIncompatibleQosStatus
            """
        @builtins.property
        def sample_lost_status(self) -> SampleLostStatus:
            """
            Get the SampleLostStatus for the DataReader.

            :type: SampleLostStatus
            """
        @builtins.property
        def sample_rejected_status(self) -> SampleRejectedStatus:
            """
            Get the SampleRejectedStatus for the DataReader.

            :type: SampleRejectedStatus
            """
        @builtins.property
        def subscriber(self) -> Subscriber:
            """
            Returns the parent Subscriber of the DataReader.

            :type: Subscriber
            """
        @builtins.property
        def subscription_matched_status(self) -> SubscriptionMatchedStatus:
            """
            Get the SubscriptionMatchedStatus for the DataReader.

            :type: SubscriptionMatchedStatus
            """
        @builtins.property
        def topic_description(self) -> SubscriptionBuiltinTopicData.TopicDescription:
            """
            Returns the TopicDescription associated with the DataReader.

            :type: SubscriptionBuiltinTopicData.TopicDescription
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataReader.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name associated with this DataReader.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataReaderListener():
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class DataReaderSeq():
        def __add__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader: ...
        def __iadd__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.SubscriptionBuiltinTopicData.DataReader]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq: ...
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.SubscriptionBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataReader: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataWriter(IEntity, IAnyDataWriter):
        def __enter__(self) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Enter a context for this DataWriter, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataWriter, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> None: 
            """
            Creates a DataWriter in the implicit publisher with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in the implicit publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> None: 
            """
            Creates a DataWriter in a publisher with default QoS.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.SubscriptionBuiltinTopicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in a publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
            """
            Create a typed DataWriter from an AnyDataWriter.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Create a typed DataWriter from an Entity.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Sets the DataWriterQos.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Writes a paired sample with a timestamp.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.InstanceHandle]) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Writes a paired sample with an instance handle.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Writes a sequence of pairs of samples with timestamps.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Writes a sequence of samples.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Writes a sample.
            """
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Get the DataWriterQos.
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Publisher, arg1: rti.connextdds.SubscriptionBuiltinTopicData.Topic, arg2: rti.connextdds.DataWriterQos) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: ...
        def _set_related_reader_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        def _wait_for_sample_acknowledgment(self, sample_id: rti.connextdds.SampleIdentity, timeout: rti.connextdds.Duration) -> None: 
            """
            Wait for a sample to be acknowledged by the application.
            """
        def assert_liveliness(self) -> None: 
            """
            Manually asserts the liveliness of the DataWriter.
            """
        def close(self) -> None: 
            """
            Close this DataWriter.
            """
        def create_data(self) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Create data of the writer's associated type and initialize it.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Dispose an instance with params.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData) -> object: 
            """
            Dispose the instance associated with key_holder.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose the instance associated with key_holder using a timestamp
            """
        @typing.overload
        def dispose_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Dispose an instance with params.
            """
        @staticmethod
        def find_all_by_topic(publisher: rti.connextdds.Publisher, topic_name: str) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq: 
            """
            Retrieve all DataWriters for the given topic name in the publisher.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.SubscriptionBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in DomainParticipant with the provided name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.SubscriptionBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in Publisher with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.SubscriptionBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in publisher with a topic name, returning the first found.
            """
        def flush(self) -> None: 
            """
            Flushes the batch in progress in the context of thecalling thread.
            """
        def is_matched_subscription_active(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            A boolean indicating whether or not the matched subscription is active.
            """
        def is_sample_app_acknowledged(self, sample_id: rti.connextdds.SampleIdentity) -> bool: 
            """
            Indicates if a sample is considered application-acknowledged.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_subscription_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Get the SubscriptionBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription handle.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, locator: rti.connextdds.Locator) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription locator.
            """
        def matched_subscription_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData, timestamp: rti.connextdds.Time) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance and specified the timestamp.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData, params: rti.connextdds.WriteParams) -> rti.connextdds.InstanceHandle: 
            """
            Registers instance with parameters.
            """
        def set_listener(self, listener: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask for the DataWriter.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Unregister an instance with parameters.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData) -> object: 
            """
            Unregister the instance associated with key_holder.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.SubscriptionBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister the instance associate with key_holder using a timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Unregister an instance with parameters.
            """
        def wait_for_acknowledgments(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Blocks the calling thread until all data written by a reliable DataWriter is acknowledged or until the timeout expires.
            """
        def wait_for_asynchronous_publishing(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            This operation blocks the calling thread (up to max_wait) until all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        def wait_for_asynchronous_publishing_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            This function is awaitable until either a timeout of max_wait or all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.This function works with asyncio.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        @typing.overload
        def write(self, samples: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> None: 
            """
            Write a sequence of samples.
            """
        @typing.overload
        def write(self, samples: rti.connextdds.SubscriptionBuiltinTopicDataSeq, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sequence of samples with a timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.SubscriptionBuiltinTopicData) -> None: 
            """
            Write a sample.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.SubscriptionBuiltinTopicData, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with a specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.SubscriptionBuiltinTopicData, handle: rti.connextdds.InstanceHandle) -> None: 
            """
            Write a sample with an instance handle.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.SubscriptionBuiltinTopicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with an instance handle and specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.SubscriptionBuiltinTopicData, params: rti.connextdds.WriteParams) -> None: 
            """
            Write with advanced parameters.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.SubscriptionBuiltinTopicData) -> object: 
            """
            Write a sample. This method is awaitable and is only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.SubscriptionBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with a specified timestamp. This methods is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.SubscriptionBuiltinTopicData, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Write a sample with an instance handle. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.SubscriptionBuiltinTopicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with an instance handle and specified timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> object: 
            """
            Write a sequence of samples. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.SubscriptionBuiltinTopicDataSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.SubscriptionBuiltinTopicDataSeq, handles: rti.connextdds.InstanceHandleSeq) -> object: 
            """
            Write a sequence of samples with their instance handles. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.SubscriptionBuiltinTopicDataSeq, handles: rti.connextdds.InstanceHandleSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with their instance handles and a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.SubscriptionBuiltinTopicData, params: rti.connextdds.WriteParams) -> object: 
            """
            Write with advanced parameters.
            """
        @builtins.property
        def _has_matched_subscriptions_with_related_writer(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datawriter_cache_status(self) -> DataWriterCacheStatus:
            """
            Get a copy of the cache status for this writer.

            :type: DataWriterCacheStatus
            """
        @builtins.property
        def datawriter_protocol_status(self) -> DataWriterProtocolStatus:
            """
            Get a copy of the protocol status for this writer.

            :type: DataWriterProtocolStatus
            """
        @builtins.property
        def listener(self) -> SubscriptionBuiltinTopicData.DataWriterListener:
            """
            Get the listener associated with the DataWriter or set the listener.

            :type: SubscriptionBuiltinTopicData.DataWriterListener
            """
        @listener.setter
        def listener(self, arg1: SubscriptionBuiltinTopicData.DataWriterListener) -> None:
            """
            Get the listener associated with the DataWriter or set the listener.
            """
        @builtins.property
        def liveliness_lost_status(self) -> LivelinessLostStatus:
            """
            Get a copy of the LivelinessLostStatus.

            :type: LivelinessLostStatus
            """
        @builtins.property
        def matched_subscriptions(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched subscription handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def matched_subscriptions_locators(self) -> LocatorSeq:
            """
            The locators used to communicate with matched DataReaders.

            :type: LocatorSeq
            """
        @builtins.property
        def offered_deadline_missed_status(self) -> OfferedDeadlineMissedStatus:
            """
            Get a copy of the OfferedDeadlineMissedStatus.

            :type: OfferedDeadlineMissedStatus
            """
        @builtins.property
        def offered_incompatible_qos_status(self) -> OfferedIncompatibleQosStatus:
            """
            Get a copy of the OfferedIncompatibleQosStatus

            :type: OfferedIncompatibleQosStatus
            """
        @builtins.property
        def publication_matched_status(self) -> PublicationMatchedStatus:
            """
            Get a copy of the PublicationMatchedStatus

            :type: PublicationMatchedStatus
            """
        @builtins.property
        def publisher(self) -> Publisher:
            """
            Get the Publisher that owns this DataWriter.

            :type: Publisher
            """
        @builtins.property
        def qos(self) -> DataWriterQos:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.

            :type: DataWriterQos
            """
        @qos.setter
        def qos(self, arg1: DataWriterQos) -> None:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.
            """
        @builtins.property
        def reliable_reader_activity_changed_status(self) -> ReliableReaderActivityChangedStatus:
            """
            Get a copy of the reliable reader activity changed status for this writer.

            :type: ReliableReaderActivityChangedStatus
            """
        @builtins.property
        def reliable_writer_cache_changed_status(self) -> ReliableWriterCacheChangedStatus:
            """
            Get a copy of the reliable cache status for this writer.

            :type: ReliableWriterCacheChangedStatus
            """
        @builtins.property
        def service_request_accepted_status(self) -> ServiceRequestAcceptedStatus:
            """
            Get a copy of the service request accepted status for this writer.

            :type: ServiceRequestAcceptedStatus
            """
        @builtins.property
        def topic(self) -> SubscriptionBuiltinTopicData.Topic:
            """
            Get the Topic object associated with this DataWriter.

            :type: SubscriptionBuiltinTopicData.Topic
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataWriter.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name for the topic object associated with this DataWriter.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataWriterListener():
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class DataWriterSeq():
        def __add__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: ...
        def __iadd__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.SubscriptionBuiltinTopicData.DataWriter]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq: ...
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.SubscriptionBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.SubscriptionBuiltinTopicData.DataWriter: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ITopicDescription(IEntity):
        @builtins.property
        def name(self) -> str:
            """
            The name of the entity conforming to the ITopicDescription interface.

            :type: str
            """
        @builtins.property
        def participant(self) -> DomainParticipant:
            """
            The parent DomainParticipant.

            :type: DomainParticipant
            """
        @builtins.property
        def type_name(self) -> str:
            """
            The name of the associated type.

            :type: str
            """
        pass
    class LoanedSample():
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, data: rti.connextdds.SubscriptionBuiltinTopicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct LoanedSample with data and info.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> SubscriptionBuiltinTopicData:
            """
            Get the data associated with the sample.

            :type: SubscriptionBuiltinTopicData
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        pass
    class LoanedSamples():
        def __enter__(self) -> rti.connextdds.SubscriptionBuiltinTopicData.LoanedSamples: 
            """
            Enter a context for the loaned samples, loan returned on context exit.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for the loaned samples, returning the resources.
            """
        def __getitem__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.LoanedSample: 
            """
            Access a LoanedSample object in an array-like syntax
            """
        def __init__(self) -> None: 
            """
            Create an empty LoanedSamples object.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.SubscriptionBuiltinTopicData.LoanedSample]: ...
        def __len__(self) -> int: 
            """
            Get the number of samples in the loan.
            """
        def return_loan(self) -> None: 
            """
            Returns the loan to the DataReader.
            """
        @builtins.property
        def length(self) -> int:
            """
            Get the number of samples in the loan.

            :type: int
            """
        pass
    class NoOpDataReaderListener(SubscriptionBuiltinTopicData.DataReaderListener):
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class NoOpDataWriterListener(SubscriptionBuiltinTopicData.DataWriterListener):
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class NoOpTopicListener(SubscriptionBuiltinTopicData.TopicListener):
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class Sample():
        @typing.overload
        def __init__(self, data: rti.connextdds.SubscriptionBuiltinTopicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct Sample with data and info.
            """
        @typing.overload
        def __init__(self, sample: rti.connextdds.SubscriptionBuiltinTopicData.Sample) -> None: 
            """
            Copy constructor.
            """
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, loaned_sample: rti.connextdds.SubscriptionBuiltinTopicData.LoanedSample) -> None: 
            """
            Construct a sample with a loaned sample.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> SubscriptionBuiltinTopicData:
            """
            The data associated with the sample.

            :type: SubscriptionBuiltinTopicData
            """
        @data.setter
        def data(self, arg1: SubscriptionBuiltinTopicData) -> None:
            """
            The data associated with the sample.
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        @info.setter
        def info(self, arg1: SampleInfo) -> None:
            """
            Get the info associated with the sample.
            """
        pass
    class SharedSamples():
        def __getitem__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.LoanedSample: 
            """
            Get the sample at the specified index.
            """
        def __init__(self, loaned_samples: rti.connextdds.SubscriptionBuiltinTopicData.LoanedSamples) -> None: 
            """
            Constructs an instance of SharedSamples, removing ownership of the loan from the Loaned Samples.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.SubscriptionBuiltinTopicData.LoanedSample]: 
            """
            Make a sample iterator
            """
        def __len__(self) -> int: 
            """
            Returns the number of samples.
            """
        pass
    class Topic(SubscriptionBuiltinTopicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast an Entity to a Topic.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.SubscriptionBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast an ITopicDescription to a Topic.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
            """
            Create a typed Topic from an AnyTopic.
            """
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> bool: 
            """
            Test for inequality.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.SubscriptionBuiltinTopicData.Topic]: 
            """
            Look up a Topic by its name in the DomainParticipant.
            """
        def set_listener(self, listener: rti.connextdds.SubscriptionBuiltinTopicData.TopicListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask.
            """
        @builtins.property
        def inconsistent_topic_status(self) -> InconsistentTopicStatus:
            """
            Get a copy of the current InconsistentTopicStatus for this Topic.

            :type: InconsistentTopicStatus
            """
        @builtins.property
        def listener(self) -> SubscriptionBuiltinTopicData.TopicListener:
            """
            The listener.

            :type: SubscriptionBuiltinTopicData.TopicListener
            """
        @listener.setter
        def listener(self, arg1: SubscriptionBuiltinTopicData.TopicListener) -> None:
            """
            The listener.
            """
        @builtins.property
        def qos(self) -> TopicQos:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.

            :type: TopicQos
            """
        @qos.setter
        def qos(self, arg1: TopicQos) -> None:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.
            """
        __hash__: NoneType
        pass
    class TopicDescription(SubscriptionBuiltinTopicData.ITopicDescription, IEntity):
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.TopicDescription) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.SubscriptionBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.TopicDescription) -> bool: 
            """
            Test for inequality.
            """
        __hash__: NoneType
        pass
    class TopicListener():
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class TopicSeq():
        def __add__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.Topic: ...
        def __iadd__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq) -> rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.SubscriptionBuiltinTopicData.Topic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.SubscriptionBuiltinTopicData.TopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.SubscriptionBuiltinTopicData.Topic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.SubscriptionBuiltinTopicData.Topic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.SubscriptionBuiltinTopicData.Topic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ValidLoanedSamples():
        def __enter__(self) -> rti.connextdds.SubscriptionBuiltinTopicData.ValidLoanedSamples: ...
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.SubscriptionBuiltinTopicData.LoanedSample]: ...
        pass
    class WriterContentFilter(SubscriptionBuiltinTopicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def writer_attach(self) -> typing.Optional[object]: 
            """
            A writer-side filtering API to create some state that can facilitate filtering on the writer side.
            """
        def writer_compile(self, writer_filter_data: typing.Optional[object], property: rti.connextdds.ExpressionProperty, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_detach(self, writer_filter_data: typing.Optional[object]) -> None: 
            """
            A writer-side filtering API to clean up a previously created state using writer_attach.
            """
        def writer_evaluate(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.SubscriptionBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> rti.connextdds.CookieVector: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_finalize(self, writer_filter_data: typing.Optional[object], cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to clean up a previously compiled instance of the content filter.
            """
        def writer_return_loan(self, writer_filter_data: typing.Optional[object], cookies: rti.connextdds.CookieVector) -> None: 
            """
            A writer-side filtering API to return the loan on the list of DataReaders returned by writer_evaluate.
            """
        pass
    class WriterContentFilterHelper(SubscriptionBuiltinTopicData.WriterContentFilter, SubscriptionBuiltinTopicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def add_cookie(self, cookie: rti.connextdds.Cookie) -> None: 
            """
            A helper function which will add a Cookie to the Cookie sequence that is then returned by the writer_evaluate function.
            """
        def writer_evaluate_helper(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.SubscriptionBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        pass
    def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default SubscriptionBuiltinTopicData.
        """
    def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicData) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def content_filter_property(self) -> ContentFilterProperty:
        """
        The custom multicast locators that the endpoint can specify.

        :type: ContentFilterProperty
        """
    @builtins.property
    def data_tag(self) -> DataTag:
        """
        The DataTag policy of the corresponding DataReader.

        :type: DataTag
        """
    @builtins.property
    def deadline(self) -> Deadline:
        """
        The Deadline policy of the corresponding DataReader.

        :type: Deadline
        """
    @builtins.property
    def destination_order(self) -> DestinationOrder:
        """
        The DestinationOrder policy of the corresponding DataReader.

        :type: DestinationOrder
        """
    @builtins.property
    def disable_positive_acks(self) -> bool:
        """
        See whether or not a matching DataReader will send positive acknowledgments for reliability.

        :type: bool
        """
    @builtins.property
    def durability(self) -> Durability:
        """
        The Durability policy of the corresponding DataReader.

        :type: Durability
        """
    @builtins.property
    def group_data(self) -> GroupData:
        """
        The GroupData policy of the corresponding DataReader's Subscriber.

        :type: GroupData
        """
    @builtins.property
    def key(self) -> BuiltinTopicKey:
        """
        The DCPS key to distinguish entries.

        :type: BuiltinTopicKey
        """
    @builtins.property
    def latency_budget(self) -> LatencyBudget:
        """
        The LatencyBudget policy of the corresponding DataReader.

        :type: LatencyBudget
        """
    @builtins.property
    def liveliness(self) -> Liveliness:
        """
        The Liveliness policy of the corresponding DataReader.

        :type: Liveliness
        """
    @builtins.property
    def multicast_locators(self) -> LocatorVector:
        """
        The custom multicast locators that the endpoint can specify.

        :type: LocatorVector
        """
    @builtins.property
    def ownership(self) -> Ownership:
        """
        The Ownership policy of the corresponding DataReader.

        :type: Ownership
        """
    @builtins.property
    def participant_key(self) -> BuiltinTopicKey:
        """
        The DCPS key of the DomainParticipant to which the DataReader belongs.

        :type: BuiltinTopicKey
        """
    @builtins.property
    def partition(self) -> Partition:
        """
        The Partition policy of the corresponding DataReader's Subscriber.

        :type: Partition
        """
    @builtins.property
    def presentation(self) -> Presentation:
        """
        The Presentation policy of the corresponding DataReader's Subscriber.

        :type: Presentation
        """
    @builtins.property
    def product_version(self) -> ProductVersion:
        """
        The current version for RTI Connext.

        :type: ProductVersion
        """
    @builtins.property
    def property(self) -> Property:
        """
        The propagated name-value properties of the corresponding DataReader.

        :type: Property
        """
    @builtins.property
    def reliability(self) -> Reliability:
        """
        The Reliability policy of the corresponding DataReader.

        :type: Reliability
        """
    @builtins.property
    def representation(self) -> DataRepresentation:
        """
        The Representation policy of the corresponding DataReader.

        :type: DataRepresentation
        """
    @builtins.property
    def rtps_protocol_version(self) -> ProtocolVersion:
        """
        The version number of the RTPS wire protocol used.

        :type: ProtocolVersion
        """
    @builtins.property
    def rtps_vendor_id(self) -> VendorId:
        """
        The ID of the vendor implementing the RTPS wire protocol.

        :type: VendorId
        """
    @builtins.property
    def service(self) -> Service:
        """
        The Service policy

        :type: Service
        """
    @builtins.property
    def subscriber_key(self) -> BuiltinTopicKey:
        """
        The DCPS key of the Publisher to which the DataReader belongs.

        :type: BuiltinTopicKey
        """
    @builtins.property
    def subscription_name(self) -> EntityName:
        """
        The subscription name and role name.

        :type: EntityName
        """
    @builtins.property
    def time_based_filter(self) -> TimeBasedFilter:
        """
        The TimeBasedFilter policy of the corresponding DataReader.

        :type: TimeBasedFilter
        """
    @builtins.property
    def topic_data(self) -> TopicData:
        """
        The TopicData policy of the corresponding DataReader's Topic.

        :type: TopicData
        """
    @builtins.property
    def topic_name(self) -> str:
        """
        The name of the related Topic.

        :type: str
        """
    @builtins.property
    def type(self) -> typing.Optional[object]:
        """
        The type.

        :type: typing.Optional[object]
        """
    @builtins.property
    def type_name(self) -> str:
        """
        The name of the type attached to the Topic.

        :type: str
        """
    @builtins.property
    def unicast_locators(self) -> LocatorVector:
        """
        The custom unicast locators that the endpoint can specify.

        :type: LocatorVector
        """
    @builtins.property
    def user_data(self) -> UserData:
        """
        The UserData policy of the corresponding DataReader.

        :type: UserData
        """
    @builtins.property
    def virtual_guid(self) -> Guid:
        """
        The virtual Guid associated to the DataReader.

        :type: Guid
        """
    __hash__: NoneType
    builtin_topic_name: str
    pass
class SubscriptionBuiltinTopicDataSeq():
    def __add__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> rti.connextdds.SubscriptionBuiltinTopicDataSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.SubscriptionBuiltinTopicData) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.SubscriptionBuiltinTopicDataSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicData: ...
    def __iadd__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> rti.connextdds.SubscriptionBuiltinTopicDataSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicDataSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.SubscriptionBuiltinTopicData]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicDataSeq: ...
    def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicDataSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.SubscriptionBuiltinTopicData) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.SubscriptionBuiltinTopicData) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.SubscriptionBuiltinTopicData) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.SubscriptionBuiltinTopicDataSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.SubscriptionBuiltinTopicData) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.SubscriptionBuiltinTopicData: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.SubscriptionBuiltinTopicData: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.SubscriptionBuiltinTopicData) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class SubscriptionBuiltinTopicDataTimestampedSeq():
    def __add__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq) -> rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]: ...
    def __iadd__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq) -> rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq: ...
    def __ne__(self, arg0: rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.SubscriptionBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: tuple[rti.connextdds.SubscriptionBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class SubscriptionMatchedStatus():
    @builtins.property
    def current_count(self) -> int:
        """
        The number of DataWriters that are currently matched with this DataReader.

        :type: int
        """
    @builtins.property
    def current_count_change(self) -> int:
        """
        The delta for the current count since the last time the listener fired or the status was read.

        :type: int
        """
    @builtins.property
    def current_count_peak(self) -> int:
        """
        The highest value that the current count has reached.

        :type: int
        """
    @builtins.property
    def last_publication_handle(self) -> InstanceHandle:
        """
        A handle to the DataWriter that caused the most recent change to to this status.

        :type: InstanceHandle
        """
    @builtins.property
    def total_count(self) -> int:
        """
        Total count of times the DataReader matched with a DataWriter.

        :type: int
        """
    @builtins.property
    def total_count_change(self) -> int:
        """
        The delta in the total count since the last time the listener fired or the status was read.

        :type: int
        """
    pass
class SuspendedPublication():
    def __enter__(self) -> rti.connextdds.SuspendedPublication: 
        """
        Context manage the SuspendedPublication.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    def __init__(self, publisher: rti.connextdds.Publisher) -> None: 
        """
        Suspends the publications of the publisher.
        """
    def resume(self) -> None: 
        """
        Indicates that the application has completed these changes.
        """
    pass
class SyslogVerbosity():
    """
    Members:

      SILENT : Silent verbosity level

      EMERGENCY : Emergency verbosity level

      ALERT : Alert verbosity level

      CRITICAL : Critical verbosity level

      ERROR : Error verbosity level

      WARNING : Warning verbosity level

      NOTICE : Notice verbosity level

      INFORMATIONAL : Informational verbosity level

      DEBUG : Debug verbosity level
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    @builtins.property
    def name(self) -> str:
        """
        :type: str
        """
    @builtins.property
    def value(self) -> int:
        """
        :type: int
        """
    ALERT: rti.connextdds.SyslogVerbosity
    CRITICAL: rti.connextdds.SyslogVerbosity
    DEBUG: rti.connextdds.SyslogVerbosity
    EMERGENCY: rti.connextdds.SyslogVerbosity
    ERROR: rti.connextdds.SyslogVerbosity
    INFORMATIONAL: rti.connextdds.SyslogVerbosity
    NOTICE: rti.connextdds.SyslogVerbosity
    SILENT: rti.connextdds.SyslogVerbosity
    WARNING: rti.connextdds.SyslogVerbosity
    __members__: dict
    pass
class SystemResourceLimits():
    def __eq__(self, arg0: rti.connextdds.SystemResourceLimits) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a SystemResourceLimits qos policy with default values.
        """
    @typing.overload
    def __init__(self, max_objects_per_thread: int) -> None: 
        """
        Creates a SystemResourceLimits qos policy with the provided max_objects_per_thread.
        """
    def __ne__(self, arg0: rti.connextdds.SystemResourceLimits) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def initial_objects_per_thread(self) -> int:
        """
        The number of objects per thread for a DomainParticipantFactory for which infrastructure will initially be allocated.

        :type: int
        """
    @initial_objects_per_thread.setter
    def initial_objects_per_thread(self, arg1: int) -> None:
        """
        The number of objects per thread for a DomainParticipantFactory for which infrastructure will initially be allocated.
        """
    @builtins.property
    def max_objects_per_thread(self) -> int:
        """
        The maximum number of objects that can be stored per thread.

        :type: int
        """
    @max_objects_per_thread.setter
    def max_objects_per_thread(self, arg1: int) -> None:
        """
        The maximum number of objects that can be stored per thread.
        """
    __hash__: NoneType
    pass
class ThreadContext():
    def __enter__(self) -> rti.connextdds.ThreadContext: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
    def __init__(self) -> None: 
        """
        Creates a thread context that will unregister the thread on exit.This is only required on platforms that do not support automatic thread-specific storage (TSS) cleanup. Refer to the Platform Notes to see if your platform supports automatic TSS cleanup. It will be mentioned in the 'Thread Configuration' sub-section of the platform you are using.
        """
    pass
class ThreadSettings():
    def __eq__(self, arg0: rti.connextdds.ThreadSettings) -> bool: ...
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a ThreadSettings object with default settings.
        """
    @typing.overload
    def __init__(self, mask: rti.connextdds.ThreadSettingsKindMask, priority: int, stack_size: int, cpu_list: rti.connextdds.Int32Vector, cpu_rotation: rti.connextdds.ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind) -> None: 
        """
        Create a ThreadSettings object with the specified parameters.
        """
    def __ne__(self, arg0: rti.connextdds.ThreadSettings) -> bool: ...
    @builtins.property
    def cpu_list(self) -> Int32Seq:
        """
        Get/set a copy of the list of CPUs available to the thread.

        :type: Int32Seq
        """
    @cpu_list.setter
    def cpu_list(self, arg1: Int32Seq) -> None:
        """
        Get/set a copy of the list of CPUs available to the thread.
        """
    @builtins.property
    def cpu_rotation(self) -> ThreadSettingsCpuRotationKind:
        """
        Get/set a copy of the thread settings mask.

        :type: ThreadSettingsCpuRotationKind
        """
    @cpu_rotation.setter
    def cpu_rotation(self, arg1: ThreadSettingsCpuRotationKind) -> None:
        """
        Get/set a copy of the thread settings mask.
        """
    @builtins.property
    def mask(self) -> ThreadSettingsKindMask:
        """
        Get/set a copy of the thread settings mask.

        :type: ThreadSettingsKindMask
        """
    @mask.setter
    def mask(self, arg1: ThreadSettingsKindMask) -> None:
        """
        Get/set a copy of the thread settings mask.
        """
    @builtins.property
    def num_uses(self) -> int:
        """
        :type: int
        """
    @num_uses.setter
    def num_uses(self, arg1: int) -> None:
        pass
    @builtins.property
    def priority(self) -> int:
        """
        Get/set a copy of the thread priority.

        :type: int
        """
    @priority.setter
    def priority(self, arg1: int) -> None:
        """
        Get/set a copy of the thread priority.
        """
    @builtins.property
    def stack_size(self) -> int:
        """
        Get/set a copy of the thread stack size.

        :type: int
        """
    @stack_size.setter
    def stack_size(self, arg1: int) -> None:
        """
        Get/set a copy of the thread stack size.
        """
    __hash__: NoneType
    pass
class ThreadSettingsCpuRotationKind():
    class ThreadSettingsCpuRotationKind():
        """
        Members:

          NO_ROTATION : Any thread controlled by this QoS can run on any listed processor, as determined by OS scheduling.

          ROUND_ROBIN : Threads controlled by this QoS will be assigned one processor from the list in round-robin order.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        NO_ROTATION: rti.connextdds.ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind
        ROUND_ROBIN: rti.connextdds.ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.ThreadSettingsCpuRotationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.ThreadSettingsCpuRotationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.ThreadSettingsCpuRotationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.ThreadSettingsCpuRotationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.ThreadSettingsCpuRotationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.ThreadSettingsCpuRotationKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind:
        """
        Retrieves the actual enumerated value.

        :type: ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind
        """
    NO_ROTATION: rti.connextdds.ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind
    ROUND_ROBIN: rti.connextdds.ThreadSettingsCpuRotationKind.ThreadSettingsCpuRotationKind
    __hash__: NoneType
    pass
class ThreadSettingsKindMask():
    def __and__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a ThreadSettingsKindMask with default thread settings.
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Bitwise logical OR of masks.
        """
    def __repr__(self) -> str: 
        """
        Convert mask to string.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: 
        """
        Convert mask to string.
        """
    def __xor__(self, arg0: rti.connextdds.ThreadSettingsKindMask) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.ThreadSettingsKindMask: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    CANCEL_ASYNCHRONOUS: rti.connextdds.ThreadSettingsKindMask
    FLOATING_POINT: rti.connextdds.ThreadSettingsKindMask
    PRIORITY_ENFORCE: rti.connextdds.ThreadSettingsKindMask
    REALTIME_PRIORITY: rti.connextdds.ThreadSettingsKindMask
    STDIO: rti.connextdds.ThreadSettingsKindMask
    __hash__: NoneType
    pass
class Time():
    def __add__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Time: 
        """
        Add a Time and Duration together.
        """
    def __eq__(self, arg0: rti.connextdds.Time) -> bool: 
        """
        Check if this Time is equal to another.
        """
    def __ge__(self, arg0: rti.connextdds.Time) -> bool: 
        """
        Check if this Time is greater than or equal another.
        """
    def __gt__(self, arg0: rti.connextdds.Time) -> bool: 
        """
        Check if this Time is greater than another.
        """
    def __iadd__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Time: 
        """
        Add a Duration to this Time object.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a default Time object. The constructed Time object will represent 0 seconds and 0 nanoseconds.
        """
    @typing.overload
    def __init__(self, sec: int, nanosec: int = 0) -> None: 
        """
        Create a Time object. The constructed Time object will represent the given amount of time.
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.Time) -> None: 
        """
        Create a copy of a Time.
        """
    @typing.overload
    def __init__(self, arg0: datetime.datetime) -> None: 
        """
        Create a Time object from a timestamp.
        """
    def __isub__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Time: 
        """
        Subtract a Duration from this Time object.
        """
    def __le__(self, arg0: rti.connextdds.Time) -> bool: 
        """
        Check if this Time is less than or equal another.
        """
    def __lt__(self, arg0: rti.connextdds.Time) -> bool: 
        """
        Check if this Time is less than another.
        """
    def __ne__(self, arg0: rti.connextdds.Time) -> bool: 
        """
        Check if this Time is not equal to another.
        """
    def __radd__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Time: 
        """
        Add a Time and Duration together.
        """
    @typing.overload
    def __sub__(self, arg0: rti.connextdds.Duration) -> rti.connextdds.Time: 
        """
        Subtract a Duration from a Time.
        """
    @typing.overload
    def __sub__(self, arg0: rti.connextdds.Time) -> rti.connextdds.Duration: 
        """
        Calculate the duration between two times.
        """
    def compare(self, other: rti.connextdds.Time) -> int: 
        """
        Compare two Time objects.
        """
    @staticmethod
    def from_microseconds(microseconds: int) -> rti.connextdds.Time: 
        """
        Create a Time object from microseconds.
        """
    @staticmethod
    def from_milliseconds(milliseconds: int) -> rti.connextdds.Time: 
        """
        Create a Time object from millisecs.
        """
    @staticmethod
    def from_seconds(seconds: float) -> rti.connextdds.Time: 
        """
        Create a Time object from seconds.
        """
    def to_microseconds(self) -> int: 
        """
        Convert this Time to microseconds.
        """
    def to_milliseconds(self) -> int: 
        """
        Convert this Time to milliseconds.
        """
    def to_seconds(self) -> float: 
        """
        Convert this Time to seconds.
        """
    @builtins.property
    def nanosec(self) -> int:
        """
        The number of nanoseconds that are represented by this Time object.

        :type: int
        """
    @nanosec.setter
    def nanosec(self, arg1: int) -> None:
        """
        The number of nanoseconds that are represented by this Time object.
        """
    @builtins.property
    def sec(self) -> int:
        """
        The number of seconds that are represented by this Time object.

        :type: int
        """
    @sec.setter
    def sec(self, arg1: int) -> None:
        """
        The number of seconds that are represented by this Time object.
        """
    __hash__: NoneType
    invalid: rti.connextdds.Time
    maximum: rti.connextdds.Time
    zero: rti.connextdds.Time
    pass
class TimeBasedFilter():
    def __eq__(self, arg0: rti.connextdds.TimeBasedFilter) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default time-based filter.
        """
    @typing.overload
    def __init__(self, min_separation: rti.connextdds.Duration) -> None: 
        """
        Creates a policy with the specified minimum separation.
        """
    def __ne__(self, arg0: rti.connextdds.TimeBasedFilter) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def minimum_separation(self) -> Duration:
        """
        The minimum separation between subsequent samples.

        :type: Duration
        """
    @minimum_separation.setter
    def minimum_separation(self, arg1: Duration) -> None:
        """
        The minimum separation between subsequent samples.
        """
    __hash__: NoneType
    pass
class TimeoutError(Exception, Exception, BaseException):
    pass
class Topic(ITopicDescription, IEntity, IAnyTopic):
    def __eq__(self, arg0: rti.connextdds.Topic) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, entity: rti.connextdds.IEntity) -> None: 
        """
        Cast an Entity to a Topic.
        """
    @typing.overload
    def __init__(self, topic_description: rti.connextdds.ITopicDescription) -> None: 
        """
        Cast an ITopicDescription to a Topic.
        """
    @typing.overload
    def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
        """
        Create a typed Topic from an AnyTopic.
        """
    @typing.overload
    def __init__(self, participant: rti.connextdds.DomainParticipant, topic_name: str, type: object, qos: rti.connextdds.TopicQos = None, listener: rti.connextdds.TopicListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL, type_name: str = None) -> None: 
        """
        Create a Topic for an @idl.struct or @idl.union type.

         The participant, topic_name and type arguments are required. The type_name, qos, listener, mask arguments are optional. The type_name argument can be used to register the type with a name different from the class name.
        """
    def __ne__(self, arg0: rti.connextdds.Topic) -> bool: 
        """
        Test for inequality.
        """
    @staticmethod
    def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.Topic]: 
        """
        Look up a Topic by its name in the DomainParticipant.
        """
    def set_listener(self, listener: rti.connextdds.TopicListener, event_mask: rti.connextdds.StatusMask) -> None: 
        """
        Set the listener and event mask.
        """
    @builtins.property
    def inconsistent_topic_status(self) -> InconsistentTopicStatus:
        """
        Get a copy of the current InconsistentTopicStatus for this Topic.

        :type: InconsistentTopicStatus
        """
    @builtins.property
    def listener(self) -> TopicListener:
        """
        The listener.

        :type: TopicListener
        """
    @listener.setter
    def listener(self, arg1: TopicListener) -> None:
        """
        The listener.
        """
    @builtins.property
    def qos(self) -> TopicQos:
        """
        Get the TopicQos for this Topic.

        This property's getter returns a deep copy.

        :type: TopicQos
        """
    @qos.setter
    def qos(self, arg1: TopicQos) -> None:
        """
        Get the TopicQos for this Topic.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def type(self) -> type:
        """
        Get the type associated with the topic.

        :type: type
        """
    @builtins.property
    def type_support(self) -> object:
        """
        Get the type_support object associated with the topic.

        :type: object
        """
    __hash__: NoneType
    pass
class TopicBuiltinTopicData():
    class ContentFilter(ContentFilterBase):
        def __init__(self) -> None: ...
        def compile(self, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, old_compile_data: typing.Optional[object]) -> typing.Optional[object]: 
            """
            Compile an instance of the content filter according to the filter expression and parameters of the given data type.
            """
        def evaluate(self, compile_data: typing.Optional[object], sample: rti.connextdds.TopicBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> bool: 
            """
            Evaluate whether the sample is passing the filter or not according to the sample content.
            """
        def finalize(self, compile_data: typing.Optional[object]) -> None: 
            """
            A previously compiled instance of the content filter is no longer in use and resources can now be cleaned up.
            """
        pass
    class ContentFilteredTopic(TopicBuiltinTopicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.TopicBuiltinTopicData.Topic, name: str, contentfilter: rti.connextdds.Filter) -> None: 
            """
            Create a ContentFilteredTopic with a name and Filter.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.TopicBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast a TopicDescription to a ContentFilteredTopic.
            """
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Test for inequality.
            """
        def append_to_expression_parameter(self, index: int, extension: str) -> None: 
            """
            Append the extension to the end of parameter at the provided index, separated by a comma.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic]: 
            """
            Look up a ContentFilteredTopic by its name in the DomainParticipant.
            """
        def remove_from_expression_parameter(self, index: int, remove_term: str) -> None: 
            """
            Removes the specified term from the parameter at the provided index.
            """
        def set_filter(self, arg0: rti.connextdds.Filter) -> None: 
            """
            Set the filter.
            """
        @builtins.property
        def filter_expression(self) -> str:
            """
            Get the filter expression

            :type: str
            """
        @builtins.property
        def filter_parameters(self) -> StringSeq:
            """
            Get/set the filter parameters.

            :type: StringSeq
            """
        @filter_parameters.setter
        def filter_parameters(self, arg1: StringSeq) -> None:
            """
            Get/set the filter parameters.
            """
        @builtins.property
        def topic(self) -> TopicBuiltinTopicData.Topic:
            """
            Get the underlying Topic.

            :type: TopicBuiltinTopicData.Topic
            """
        __hash__: NoneType
        pass
    class ContentFilteredTopicSeq():
        def __add__(self, arg0: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic: ...
        def __iadd__(self, arg0: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataReader(IDataReader, IEntity, IAnyDataReader):
        class Selector():
            def __init__(self, datareader: rti.connextdds.TopicBuiltinTopicData.DataReader) -> None: 
                """
                Create a Selector for a DataReader to read/take based on selected conditions
                """
            def condition(self, condition: rti.connextdds.IReadCondition) -> rti.connextdds.TopicBuiltinTopicData.DataReader.Selector: 
                """
                Select samples based on a ReadCondition.
                """
            def content(self, query: rti.connextdds.Query) -> rti.connextdds.TopicBuiltinTopicData.DataReader.Selector: 
                """
                Select samples based on a Query.
                """
            def instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.TopicBuiltinTopicData.DataReader.Selector: 
                """
                Select a specific instance to read/take.
                """
            def max_samples(self, max: int) -> rti.connextdds.TopicBuiltinTopicData.DataReader.Selector: 
                """
                Limit the number of samples read/taken by the Select.
                """
            def next_instance(self, previous: rti.connextdds.InstanceHandle) -> rti.connextdds.TopicBuiltinTopicData.DataReader.Selector: 
                """
                Select the instance after the specified instance to read/take.
                """
            def read(self) -> list: 
                """
                Read copies of available samples (data and info) based on the Selector settings.
                """
            def read_data(self) -> list: 
                """
                Read copies of available valid data based on the Selector settings.
                """
            def read_loaned(self) -> rti.connextdds.TopicBuiltinTopicData.LoanedSamples: 
                """
                Take available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            def state(self, state: rti.connextdds.DataState) -> rti.connextdds.TopicBuiltinTopicData.DataReader.Selector: 
                """
                Select samples with a specified data state.
                """
            def take(self) -> list: 
                """
                Take copies of available samples (data and info) based on the Selector settings.
                """
            def take_data(self) -> list: 
                """
                Take copies of available valid data based on the Selector settings.
                """
            def take_loaned(self) -> rti.connextdds.TopicBuiltinTopicData.LoanedSamples: 
                """
                Read available samples (data and info) based on the Selector settings and return them in a loaned container.
                """
            pass
        def __enter__(self) -> rti.connextdds.TopicBuiltinTopicData.DataReader: 
            """
            Enter a context for this DataReader, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataReader, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.TopicBuiltinTopicData.Topic) -> None: 
            """
            Create a DataReader in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.TopicBuiltinTopicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.TopicBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in the implicit subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, cft: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.TopicBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in the implicit subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.TopicBuiltinTopicData.Topic) -> None: 
            """
            Create a DataReader.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, topic: rti.connextdds.TopicBuiltinTopicData.Topic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.TopicBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader in a subscriber with specific QoS and a listener.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with default QoS.
            """
        @typing.overload
        def __init__(self, subscriber: rti.connextdds.Subscriber, cft: rti.connextdds.TopicBuiltinTopicData.ContentFilteredTopic, qos: rti.connextdds.DataReaderQos, listener: rti.connextdds.TopicBuiltinTopicData.DataReaderListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Create a DataReader with a ContentFilteredTopic in a subscriber with specific QoS.
            """
        @typing.overload
        def __init__(self, reader: rti.connextdds.IAnyDataReader) -> None: 
            """
            Get a typed DataReader from an AnyDataReader.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Get a typed DataReader from an Entity.
            """
        def __lshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.TopicBuiltinTopicData.DataReader: 
            """
            Set the DataReaderQos for this DataReader.
            """
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataReaderQos) -> rti.connextdds.TopicBuiltinTopicData.DataReader: 
            """
            Get the DataReaderQos from this DataReader
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Subscriber, arg1: rti.connextdds.TopicBuiltinTopicData.TopicDescription, arg2: rti.connextdds.DataReaderQos) -> rti.connextdds.TopicBuiltinTopicData.DataReader: ...
        def _set_related_writer_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        @typing.overload
        def acknowledge_all(self) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_all(self, arg0: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge all previously accessed samples.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo) -> None: 
            """
            Acknowledge a single sample.
            """
        @typing.overload
        def acknowledge_sample(self, sample_info: rti.connextdds.SampleInfo, ack_response_data: rti.connextdds.AckResponseData) -> None: 
            """
            Acknowledge a single sample with ack response data.
            """
        def close(self) -> None: 
            """
            Close this DataReader.
            """
        @staticmethod
        def find_all_by_topic(subscriber: rti.connextdds.Subscriber, topic_name: str) -> rti.connextdds.TopicBuiltinTopicData.DataReaderSeq: 
            """
            Retrieve all DataReaders for the given topic name in the subscriber.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.TopicBuiltinTopicData.DataReader]: 
            """
            Find DataReader in DomainParticipant with the DataReader's name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.TopicBuiltinTopicData.DataReader]: 
            """
            Find DataReader in Subscriber with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(subscriber: rti.connextdds.Subscriber, name: str) -> typing.Optional[rti.connextdds.TopicBuiltinTopicData.DataReader]: 
            """
            Find DataReader in Subscriber with a topic name, returning the first found.
            """
        def is_matched_publication_alive(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            Check if a matched publication is alive.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.TopicBuiltinTopicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.TopicBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_publication_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.PublicationBuiltinTopicData: 
            """
            Get the PublicationBuiltinTopicData for a publication matched to this DataReader.
            """
        def matched_publication_datareader_protocol_status(self, publication_handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataReaderProtocolStatus: 
            """
            Get the DataReaderProtocolStatus for the DataReader based on the matched publication handle.
            """
        def matched_publication_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a publication matched to this DataReader.
            """
        def read(self) -> list: 
            """
            Read copies of all available samples (data and info).
            """
        def read_data(self) -> list: 
            """
            Read copies of all available valid data.
            """
        def read_loaned(self) -> rti.connextdds.TopicBuiltinTopicData.LoanedSamples: 
            """
            Read all available samples (data and info) and return them in a loaned container.
            """
        @staticmethod
        def select(*args, **kwargs) -> typing.Any: 
            """
            Get a Selector to perform complex data selections, such as per-instance selection, content, and status filtering.
            """
        def set_listener(self, listener: rti.connextdds.TopicBuiltinTopicData.DataReaderListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and associated event mask.
            """
        def take(self) -> list: 
            """
            Take copies of all available samples (data and info).
            """
        def take_data(self) -> list: 
            """
            Take copies of all available valid data.
            """
        def take_loaned(self) -> rti.connextdds.TopicBuiltinTopicData.LoanedSamples: 
            """
            Take all available samples (data and info) and return them in a loaned container.
            """
        def wait_for_historical_data(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind.
            """
        def wait_for_historical_data_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            Waits until all "historical" data is received for DataReaders that have a non-VOLATILE Durability Qos kind. This call is awaitable and only for use with asyncio.
            """
        @builtins.property
        def _has_matched_publications_with_related_reader(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datareader_cache_status(self) -> DataReaderCacheStatus:
            """
            Get the DataReaderCacheStatus for the DataReader.

            :type: DataReaderCacheStatus
            """
        @builtins.property
        def datareader_protocol_status(self) -> DataReaderProtocolStatus:
            """
            Get the DataReaderProtocolStatus for the DataReader.

            :type: DataReaderProtocolStatus
            """
        @builtins.property
        def default_filter_state(self) -> DataState:
            """
            Returns the filter state for the read/take operations.

            :type: DataState
            """
        @default_filter_state.setter
        def default_filter_state(self, arg1: DataState) -> None:
            """
            Returns the filter state for the read/take operations.
            """
        @builtins.property
        def listener(self) -> TopicBuiltinTopicData.DataReaderListener:
            """
            Gets or sets the listener with StatusMask.ALL

            :type: TopicBuiltinTopicData.DataReaderListener
            """
        @listener.setter
        def listener(self, arg1: TopicBuiltinTopicData.DataReaderListener) -> None:
            """
            Gets or sets the listener with StatusMask.ALL
            """
        @builtins.property
        def liveliness_changed_status(self) -> LivelinessChangedStatus:
            """
            Get the LivelinessChangedStatus for this DataReader.

            :type: LivelinessChangedStatus
            """
        @builtins.property
        def matched_publications(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched publication handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def qos(self) -> DataReaderQos:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.

            :type: DataReaderQos
            """
        @qos.setter
        def qos(self, arg1: DataReaderQos) -> None:
            """
            The DataReaderQos for this DataReader.

            This property's getter returns a deep copy.
            """
        @builtins.property
        def requested_deadline_missed_status(self) -> RequestedDeadlineMissedStatus:
            """
            Get the RequestedDeadlineMissed status for the DataReader

            :type: RequestedDeadlineMissedStatus
            """
        @builtins.property
        def requested_incompatible_qos_status(self) -> RequestedIncompatibleQosStatus:
            """
            Get the RequestedIncompatibleQosStatus for the DataReader.

            :type: RequestedIncompatibleQosStatus
            """
        @builtins.property
        def sample_lost_status(self) -> SampleLostStatus:
            """
            Get the SampleLostStatus for the DataReader.

            :type: SampleLostStatus
            """
        @builtins.property
        def sample_rejected_status(self) -> SampleRejectedStatus:
            """
            Get the SampleRejectedStatus for the DataReader.

            :type: SampleRejectedStatus
            """
        @builtins.property
        def subscriber(self) -> Subscriber:
            """
            Returns the parent Subscriber of the DataReader.

            :type: Subscriber
            """
        @builtins.property
        def subscription_matched_status(self) -> SubscriptionMatchedStatus:
            """
            Get the SubscriptionMatchedStatus for the DataReader.

            :type: SubscriptionMatchedStatus
            """
        @builtins.property
        def topic_description(self) -> TopicBuiltinTopicData.TopicDescription:
            """
            Returns the TopicDescription associated with the DataReader.

            :type: TopicBuiltinTopicData.TopicDescription
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataReader.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name associated with this DataReader.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataReaderListener():
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class DataReaderSeq():
        def __add__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReaderSeq) -> rti.connextdds.TopicBuiltinTopicData.DataReaderSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.TopicBuiltinTopicData.DataReader) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReaderSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.TopicBuiltinTopicData.DataReaderSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.DataReader: ...
        def __iadd__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReaderSeq) -> rti.connextdds.TopicBuiltinTopicData.DataReaderSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.DataReaderSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.TopicBuiltinTopicData.DataReader]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.DataReaderSeq: ...
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReaderSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.DataReaderSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.TopicBuiltinTopicData.DataReader) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.TopicBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.TopicBuiltinTopicData.DataReader) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.TopicBuiltinTopicData.DataReader) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.TopicBuiltinTopicData.DataReaderSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.TopicBuiltinTopicData.DataReader) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.TopicBuiltinTopicData.DataReader: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.TopicBuiltinTopicData.DataReader: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.TopicBuiltinTopicData.DataReader) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class DataWriter(IEntity, IAnyDataWriter):
        def __enter__(self) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Enter a context for this DataWriter, to be cleaned up on exiting context
            """
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter) -> bool: 
            """
            Test for equality.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for this DataWriter, cleaning up resources.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.TopicBuiltinTopicData.Topic) -> None: 
            """
            Creates a DataWriter in the implicit publisher with default QoS.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.TopicBuiltinTopicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.TopicBuiltinTopicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in the implicit publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.TopicBuiltinTopicData.Topic) -> None: 
            """
            Creates a DataWriter in a publisher with default QoS.
            """
        @typing.overload
        def __init__(self, pub: rti.connextdds.Publisher, topic: rti.connextdds.TopicBuiltinTopicData.Topic, qos: rti.connextdds.DataWriterQos, listener: rti.connextdds.TopicBuiltinTopicData.DataWriterListener = None, mask: rti.connextdds.StatusMask = StatusMask.ALL) -> None: 
            """
            Creates a DataWriter in a publisher with specific QoS and optionally a listener.
            """
        @typing.overload
        def __init__(self, writer: rti.connextdds.IAnyDataWriter) -> None: 
            """
            Create a typed DataWriter from an AnyDataWriter.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Create a typed DataWriter from an Entity.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Sets the DataWriterQos.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Writes a paired sample with a timestamp.
            """
        @typing.overload
        def __lshift__(self, arg0: tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.InstanceHandle]) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Writes a paired sample with an instance handle.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.TopicBuiltinTopicDataTimestampedSeq) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Writes a sequence of pairs of samples with timestamps.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.TopicBuiltinTopicDataSeq) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Writes a sequence of samples.
            """
        @typing.overload
        def __lshift__(self, arg0: rti.connextdds.TopicBuiltinTopicData) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Writes a sample.
            """
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter) -> bool: 
            """
            Test for inequality.
            """
        def __rshift__(self, arg0: rti.connextdds.DataWriterQos) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Get the DataWriterQos.
            """
        @staticmethod
        def _create_disabled(arg0: rti.connextdds.Publisher, arg1: rti.connextdds.TopicBuiltinTopicData.Topic, arg2: rti.connextdds.DataWriterQos) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: ...
        def _set_related_reader_key(self, arg0: rti.connextdds.InstanceHandle) -> None: ...
        def _wait_for_sample_acknowledgment(self, sample_id: rti.connextdds.SampleIdentity, timeout: rti.connextdds.Duration) -> None: 
            """
            Wait for a sample to be acknowledged by the application.
            """
        def assert_liveliness(self) -> None: 
            """
            Manually asserts the liveliness of the DataWriter.
            """
        def close(self) -> None: 
            """
            Close this DataWriter.
            """
        def create_data(self) -> rti.connextdds.TopicBuiltinTopicData: 
            """
            Create data of the writer's associated type and initialize it.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Dispose an instance with params.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Dispose an instance.
            """
        @typing.overload
        def dispose_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose an instance with a timestamp.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.TopicBuiltinTopicData) -> object: 
            """
            Dispose the instance associated with key_holder.
            """
        @typing.overload
        def dispose_instance_async(self, key_holder: rti.connextdds.TopicBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Dispose the instance associated with key_holder using a timestamp
            """
        @typing.overload
        def dispose_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Dispose an instance with params.
            """
        @staticmethod
        def find_all_by_topic(publisher: rti.connextdds.Publisher, topic_name: str) -> rti.connextdds.TopicBuiltinTopicData.DataWriterSeq: 
            """
            Retrieve all DataWriters for the given topic name in the publisher.
            """
        @staticmethod
        @typing.overload
        def find_by_name(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.TopicBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in DomainParticipant with the provided name, returning the first found.
            """
        @staticmethod
        @typing.overload
        def find_by_name(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.TopicBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in Publisher with the DataReader's name, returning the first found.
            """
        @staticmethod
        def find_by_topic(publisher: rti.connextdds.Publisher, name: str) -> typing.Optional[rti.connextdds.TopicBuiltinTopicData.DataWriter]: 
            """
            Find DataWriter in publisher with a topic name, returning the first found.
            """
        def flush(self) -> None: 
            """
            Flushes the batch in progress in the context of thecalling thread.
            """
        def is_matched_subscription_active(self, arg0: rti.connextdds.InstanceHandle) -> bool: 
            """
            A boolean indicating whether or not the matched subscription is active.
            """
        def is_sample_app_acknowledged(self, sample_id: rti.connextdds.SampleIdentity) -> bool: 
            """
            Indicates if a sample is considered application-acknowledged.
            """
        def key_value(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.TopicBuiltinTopicData: 
            """
            Retrieve the instance key that corresponds to an instance handle.
            """
        def lookup_instance(self, key_holder: rti.connextdds.TopicBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Retrieve the instance handle that corresponds to an instance key_holder
            """
        def matched_subscription_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.SubscriptionBuiltinTopicData: 
            """
            Get the SubscriptionBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription handle.
            """
        @typing.overload
        def matched_subscription_datawriter_protocol_status(self, locator: rti.connextdds.Locator) -> rti.connextdds.DataWriterProtocolStatus: 
            """
            Get a copy of the protocol status for this writer per a matched subscription locator.
            """
        def matched_subscription_participant_data(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.ParticipantBuiltinTopicData: 
            """
            Get the ParticipantBuiltinTopicData for a subscription matched to this DataWriter.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.TopicBuiltinTopicData) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.TopicBuiltinTopicData, timestamp: rti.connextdds.Time) -> rti.connextdds.InstanceHandle: 
            """
            Informs RTI Connext that the application will be modifying a particular instance and specified the timestamp.
            """
        @typing.overload
        def register_instance(self, key_holder: rti.connextdds.TopicBuiltinTopicData, params: rti.connextdds.WriteParams) -> rti.connextdds.InstanceHandle: 
            """
            Registers instance with parameters.
            """
        def set_listener(self, listener: rti.connextdds.TopicBuiltinTopicData.DataWriterListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask for the DataWriter.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance(self, params: rti.connextdds.WriteParams) -> None: 
            """
            Unregister an instance with parameters.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Unregister an instance.
            """
        @typing.overload
        def unregister_instance_async(self, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister an instance with timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.TopicBuiltinTopicData) -> object: 
            """
            Unregister the instance associated with key_holder.
            """
        @typing.overload
        def unregister_instance_async(self, key_holder: rti.connextdds.TopicBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Unregister the instance associate with key_holder using a timestamp.
            """
        @typing.overload
        def unregister_instance_async(self, params: rti.connextdds.WriteParams) -> object: 
            """
            Unregister an instance with parameters.
            """
        def wait_for_acknowledgments(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            Blocks the calling thread until all data written by a reliable DataWriter is acknowledged or until the timeout expires.
            """
        def wait_for_asynchronous_publishing(self, max_wait: rti.connextdds.Duration) -> None: 
            """
            This operation blocks the calling thread (up to max_wait) until all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        def wait_for_asynchronous_publishing_async(self, max_wait: rti.connextdds.Duration) -> object: 
            """
            This function is awaitable until either a timeout of max_wait or all data written by the asynchronous DataWriter is sent and acknowledged (if reliable) by all matched DataReader entities. A successful completion indicates that all the samples written have been sent and acknowledged where applicable; a time out indicates that max_wait elapsed before all the data was sent and/or acknowledged.This function works with asyncio.

            In other words, this guarantees that sending to best effort DataReader is complete in addition to what DataWriter.wait_for_acknowledgments() provides.

            If the DataWriter does not have PublishMode kind set to PublishModeKind.ASYNCHRONOUS the operation will complete immediately
            """
        @typing.overload
        def write(self, samples: rti.connextdds.TopicBuiltinTopicDataSeq) -> None: 
            """
            Write a sequence of samples.
            """
        @typing.overload
        def write(self, samples: rti.connextdds.TopicBuiltinTopicDataSeq, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sequence of samples with a timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.TopicBuiltinTopicData) -> None: 
            """
            Write a sample.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.TopicBuiltinTopicData, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with a specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.TopicBuiltinTopicData, handle: rti.connextdds.InstanceHandle) -> None: 
            """
            Write a sample with an instance handle.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.TopicBuiltinTopicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> None: 
            """
            Write a sample with an instance handle and specified timestamp.
            """
        @typing.overload
        def write(self, sample: rti.connextdds.TopicBuiltinTopicData, params: rti.connextdds.WriteParams) -> None: 
            """
            Write with advanced parameters.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.TopicBuiltinTopicData) -> object: 
            """
            Write a sample. This method is awaitable and is only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.TopicBuiltinTopicData, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with a specified timestamp. This methods is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.TopicBuiltinTopicData, handle: rti.connextdds.InstanceHandle) -> object: 
            """
            Write a sample with an instance handle. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.TopicBuiltinTopicData, handle: rti.connextdds.InstanceHandle, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sample with an instance handle and specified timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.TopicBuiltinTopicDataSeq) -> object: 
            """
            Write a sequence of samples. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.TopicBuiltinTopicDataSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.TopicBuiltinTopicDataSeq, handles: rti.connextdds.InstanceHandleSeq) -> object: 
            """
            Write a sequence of samples with their instance handles. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, samples: rti.connextdds.TopicBuiltinTopicDataSeq, handles: rti.connextdds.InstanceHandleSeq, timestamp: rti.connextdds.Time) -> object: 
            """
            Write a sequence of samples with their instance handles and a timestamp. This method is awaitable and only for use with asyncio.
            """
        @typing.overload
        def write_async(self, sample: rti.connextdds.TopicBuiltinTopicData, params: rti.connextdds.WriteParams) -> object: 
            """
            Write with advanced parameters.
            """
        @builtins.property
        def _has_matched_subscriptions_with_related_writer(self) -> int:
            """
            :type: int
            """
        @builtins.property
        def datawriter_cache_status(self) -> DataWriterCacheStatus:
            """
            Get a copy of the cache status for this writer.

            :type: DataWriterCacheStatus
            """
        @builtins.property
        def datawriter_protocol_status(self) -> DataWriterProtocolStatus:
            """
            Get a copy of the protocol status for this writer.

            :type: DataWriterProtocolStatus
            """
        @builtins.property
        def listener(self) -> TopicBuiltinTopicData.DataWriterListener:
            """
            Get the listener associated with the DataWriter or set the listener.

            :type: TopicBuiltinTopicData.DataWriterListener
            """
        @listener.setter
        def listener(self, arg1: TopicBuiltinTopicData.DataWriterListener) -> None:
            """
            Get the listener associated with the DataWriter or set the listener.
            """
        @builtins.property
        def liveliness_lost_status(self) -> LivelinessLostStatus:
            """
            Get a copy of the LivelinessLostStatus.

            :type: LivelinessLostStatus
            """
        @builtins.property
        def matched_subscriptions(self) -> InstanceHandleSeq:
            """
            Get a copy of the list of the currently matched subscription handles.

            :type: InstanceHandleSeq
            """
        @builtins.property
        def matched_subscriptions_locators(self) -> LocatorSeq:
            """
            The locators used to communicate with matched DataReaders.

            :type: LocatorSeq
            """
        @builtins.property
        def offered_deadline_missed_status(self) -> OfferedDeadlineMissedStatus:
            """
            Get a copy of the OfferedDeadlineMissedStatus.

            :type: OfferedDeadlineMissedStatus
            """
        @builtins.property
        def offered_incompatible_qos_status(self) -> OfferedIncompatibleQosStatus:
            """
            Get a copy of the OfferedIncompatibleQosStatus

            :type: OfferedIncompatibleQosStatus
            """
        @builtins.property
        def publication_matched_status(self) -> PublicationMatchedStatus:
            """
            Get a copy of the PublicationMatchedStatus

            :type: PublicationMatchedStatus
            """
        @builtins.property
        def publisher(self) -> Publisher:
            """
            Get the Publisher that owns this DataWriter.

            :type: Publisher
            """
        @builtins.property
        def qos(self) -> DataWriterQos:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.

            :type: DataWriterQos
            """
        @qos.setter
        def qos(self, arg1: DataWriterQos) -> None:
            """
            The DataWriterQos for this DataWriter.This property's getter returns a deep copy.
            """
        @builtins.property
        def reliable_reader_activity_changed_status(self) -> ReliableReaderActivityChangedStatus:
            """
            Get a copy of the reliable reader activity changed status for this writer.

            :type: ReliableReaderActivityChangedStatus
            """
        @builtins.property
        def reliable_writer_cache_changed_status(self) -> ReliableWriterCacheChangedStatus:
            """
            Get a copy of the reliable cache status for this writer.

            :type: ReliableWriterCacheChangedStatus
            """
        @builtins.property
        def service_request_accepted_status(self) -> ServiceRequestAcceptedStatus:
            """
            Get a copy of the service request accepted status for this writer.

            :type: ServiceRequestAcceptedStatus
            """
        @builtins.property
        def topic(self) -> TopicBuiltinTopicData.Topic:
            """
            Get the Topic object associated with this DataWriter.

            :type: TopicBuiltinTopicData.Topic
            """
        @builtins.property
        def topic_name(self) -> str:
            """
            Get the topic name associated with this DataWriter.

            :type: str
            """
        @builtins.property
        def type_name(self) -> str:
            """
            Get the type name for the topic object associated with this DataWriter.

            :type: str
            """
        __hash__: NoneType
        pass
    class DataWriterListener():
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class DataWriterSeq():
        def __add__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriterSeq) -> rti.connextdds.TopicBuiltinTopicData.DataWriterSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.TopicBuiltinTopicData.DataWriter) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriterSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.TopicBuiltinTopicData.DataWriterSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: ...
        def __iadd__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriterSeq) -> rti.connextdds.TopicBuiltinTopicData.DataWriterSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.DataWriterSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.TopicBuiltinTopicData.DataWriter]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.DataWriterSeq: ...
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriterSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.DataWriterSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.TopicBuiltinTopicData.DataWriter) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.TopicBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.TopicBuiltinTopicData.DataWriter) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.TopicBuiltinTopicData.DataWriter) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.TopicBuiltinTopicData.DataWriterSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.TopicBuiltinTopicData.DataWriter) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.TopicBuiltinTopicData.DataWriter: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.TopicBuiltinTopicData.DataWriter) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ITopicDescription(IEntity):
        @builtins.property
        def name(self) -> str:
            """
            The name of the entity conforming to the ITopicDescription interface.

            :type: str
            """
        @builtins.property
        def participant(self) -> DomainParticipant:
            """
            The parent DomainParticipant.

            :type: DomainParticipant
            """
        @builtins.property
        def type_name(self) -> str:
            """
            The name of the associated type.

            :type: str
            """
        pass
    class LoanedSample():
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, data: rti.connextdds.TopicBuiltinTopicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct LoanedSample with data and info.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> TopicBuiltinTopicData:
            """
            Get the data associated with the sample.

            :type: TopicBuiltinTopicData
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        pass
    class LoanedSamples():
        def __enter__(self) -> rti.connextdds.TopicBuiltinTopicData.LoanedSamples: 
            """
            Enter a context for the loaned samples, loan returned on context exit.
            """
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
            """
            Exit the context for the loaned samples, returning the resources.
            """
        def __getitem__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.LoanedSample: 
            """
            Access a LoanedSample object in an array-like syntax
            """
        def __init__(self) -> None: 
            """
            Create an empty LoanedSamples object.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.TopicBuiltinTopicData.LoanedSample]: ...
        def __len__(self) -> int: 
            """
            Get the number of samples in the loan.
            """
        def return_loan(self) -> None: 
            """
            Returns the loan to the DataReader.
            """
        @builtins.property
        def length(self) -> int:
            """
            Get the number of samples in the loan.

            :type: int
            """
        pass
    class NoOpDataReaderListener(TopicBuiltinTopicData.DataReaderListener):
        def __init__(self) -> None: ...
        def on_data_available(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader) -> None: 
            """
            Data available callback.
            """
        def on_liveliness_changed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.LivelinessChangedStatus) -> None: 
            """
            Liveliness changed callback.
            """
        def on_requested_deadline_missed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedDeadlineMissedStatus) -> None: 
            """
            Requested deadline missed callback.
            """
        def on_requested_incompatible_qos(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.RequestedIncompatibleQosStatus) -> None: 
            """
            Requested incompatible QoS callback.
            """
        def on_sample_lost(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleLostStatus) -> None: 
            """
            Sample lost callback.
            """
        def on_sample_rejected(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.SampleRejectedStatus) -> None: 
            """
            Sample rejected callback.
            """
        def on_subscription_matched(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataReader, arg1: rti.connextdds.SubscriptionMatchedStatus) -> None: 
            """
            Subscription matched callback.
            """
        pass
    class NoOpDataWriterListener(TopicBuiltinTopicData.DataWriterListener):
        def __init__(self) -> None: ...
        def on_application_acknowledgment(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.AcknowledgmentInfo) -> None: 
            """
            On application acknowledgment callback
            """
        def on_instance_replaced(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.InstanceHandle) -> None: 
            """
            On instance replaced callback.
            """
        def on_liveliness_lost(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.LivelinessLostStatus) -> None: 
            """
            Liveliness lost callback.
            """
        def on_offered_deadline_missed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedDeadlineMissedStatus) -> None: 
            """
            Offered deadline missed callback.
            """
        def on_offered_incompatible_qos(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.OfferedIncompatibleQosStatus) -> None: 
            """
            Offered incompatible QoS callback.
            """
        def on_publication_matched(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.PublicationMatchedStatus) -> None: 
            """
            Publication matched callback.
            """
        def on_reliable_reader_activity_changed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableReaderActivityChangedStatus) -> None: 
            """
            Reliable reader activity changed callback.
            """
        def on_reliable_writer_cache_changed(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.ReliableWriterCacheChangedStatus) -> None: 
            """
            Reliable writer cache changed callback.
            """
        def on_service_request_accepted(self, arg0: rti.connextdds.TopicBuiltinTopicData.DataWriter, arg1: rti.connextdds.ServiceRequestAcceptedStatus) -> None: 
            """
            On service request accepted callback.
            """
        pass
    class NoOpTopicListener(TopicBuiltinTopicData.TopicListener):
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.TopicBuiltinTopicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class Sample():
        @typing.overload
        def __init__(self, data: rti.connextdds.TopicBuiltinTopicData, info: rti.connextdds.SampleInfo) -> None: 
            """
            Construct Sample with data and info.
            """
        @typing.overload
        def __init__(self, sample: rti.connextdds.TopicBuiltinTopicData.Sample) -> None: 
            """
            Copy constructor.
            """
        @typing.overload
        def __init__(self) -> None: 
            """
            Basic constructor
            """
        @typing.overload
        def __init__(self, loaned_sample: rti.connextdds.TopicBuiltinTopicData.LoanedSample) -> None: 
            """
            Construct a sample with a loaned sample.
            """
        def __iter__(self) -> object: ...
        @builtins.property
        def data(self) -> TopicBuiltinTopicData:
            """
            The data associated with the sample.

            :type: TopicBuiltinTopicData
            """
        @data.setter
        def data(self, arg1: TopicBuiltinTopicData) -> None:
            """
            The data associated with the sample.
            """
        @builtins.property
        def info(self) -> SampleInfo:
            """
            Get the info associated with the sample.

            :type: SampleInfo
            """
        @info.setter
        def info(self, arg1: SampleInfo) -> None:
            """
            Get the info associated with the sample.
            """
        pass
    class SharedSamples():
        def __getitem__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.LoanedSample: 
            """
            Get the sample at the specified index.
            """
        def __init__(self, loaned_samples: rti.connextdds.TopicBuiltinTopicData.LoanedSamples) -> None: 
            """
            Constructs an instance of SharedSamples, removing ownership of the loan from the Loaned Samples.
            """
        def __iter__(self) -> typing.Iterator[rti.connextdds.TopicBuiltinTopicData.LoanedSample]: 
            """
            Make a sample iterator
            """
        def __len__(self) -> int: 
            """
            Returns the number of samples.
            """
        pass
    class Topic(TopicBuiltinTopicData.ITopicDescription, IEntity, IAnyTopic):
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.Topic) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast an Entity to a Topic.
            """
        @typing.overload
        def __init__(self, topic_description: rti.connextdds.TopicBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast an ITopicDescription to a Topic.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
            """
            Create a typed Topic from an AnyTopic.
            """
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.Topic) -> bool: 
            """
            Test for inequality.
            """
        @staticmethod
        def find(participant: rti.connextdds.DomainParticipant, name: str) -> typing.Optional[rti.connextdds.TopicBuiltinTopicData.Topic]: 
            """
            Look up a Topic by its name in the DomainParticipant.
            """
        def set_listener(self, listener: rti.connextdds.TopicBuiltinTopicData.TopicListener, event_mask: rti.connextdds.StatusMask) -> None: 
            """
            Set the listener and event mask.
            """
        @builtins.property
        def inconsistent_topic_status(self) -> InconsistentTopicStatus:
            """
            Get a copy of the current InconsistentTopicStatus for this Topic.

            :type: InconsistentTopicStatus
            """
        @builtins.property
        def listener(self) -> TopicBuiltinTopicData.TopicListener:
            """
            The listener.

            :type: TopicBuiltinTopicData.TopicListener
            """
        @listener.setter
        def listener(self, arg1: TopicBuiltinTopicData.TopicListener) -> None:
            """
            The listener.
            """
        @builtins.property
        def qos(self) -> TopicQos:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.

            :type: TopicQos
            """
        @qos.setter
        def qos(self, arg1: TopicQos) -> None:
            """
            Get the TopicQos for this Topic.

            This property's getter returns a deep copy.
            """
        __hash__: NoneType
        pass
    class TopicDescription(TopicBuiltinTopicData.ITopicDescription, IEntity):
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.TopicDescription) -> bool: 
            """
            Test for equality.
            """
        @typing.overload
        def __init__(self, topic: rti.connextdds.TopicBuiltinTopicData.ITopicDescription) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        @typing.overload
        def __init__(self, entity: rti.connextdds.IEntity) -> None: 
            """
            Cast a Topic to a TopicDescription.
            """
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.TopicDescription) -> bool: 
            """
            Test for inequality.
            """
        __hash__: NoneType
        pass
    class TopicListener():
        def __init__(self) -> None: ...
        def on_inconsistent_topic(self, arg0: rti.connextdds.TopicBuiltinTopicData.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
            """
            Inconsistent topic callback.
            """
        pass
    class TopicSeq():
        def __add__(self, arg0: rti.connextdds.TopicBuiltinTopicData.TopicSeq) -> rti.connextdds.TopicBuiltinTopicData.TopicSeq: ...
        def __bool__(self) -> bool: 
            """
            Check whether the list is nonempty
            """
        def __contains__(self, x: rti.connextdds.TopicBuiltinTopicData.Topic) -> bool: 
            """
            Return true the container contains ``x``
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None: 
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None: 
            """
            Delete list elements using a slice object
            """
        def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData.TopicSeq) -> bool: ...
        @typing.overload
        def __getitem__(self, s: slice) -> rti.connextdds.TopicBuiltinTopicData.TopicSeq: 
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.Topic: ...
        def __iadd__(self, arg0: rti.connextdds.TopicBuiltinTopicData.TopicSeq) -> rti.connextdds.TopicBuiltinTopicData.TopicSeq: ...
        def __imul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.TopicSeq: ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, arg0: rti.connextdds.TopicBuiltinTopicData.TopicSeq) -> None: 
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.TopicBuiltinTopicData.Topic]: ...
        def __len__(self) -> int: ...
        def __mul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.TopicSeq: ...
        def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData.TopicSeq) -> bool: ...
        def __rmul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData.TopicSeq: ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: rti.connextdds.TopicBuiltinTopicData.Topic) -> None: ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: rti.connextdds.TopicBuiltinTopicData.TopicSeq) -> None: 
            """
            Assign list elements using a slice object
            """
        def append(self, x: rti.connextdds.TopicBuiltinTopicData.Topic) -> None: 
            """
            Add an item to the end of the list
            """
        def clear(self) -> None: 
            """
            Clear the contents
            """
        def count(self, x: rti.connextdds.TopicBuiltinTopicData.Topic) -> int: 
            """
            Return the number of times ``x`` appears in the list
            """
        @typing.overload
        def extend(self, L: rti.connextdds.TopicBuiltinTopicData.TopicSeq) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None: 
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: rti.connextdds.TopicBuiltinTopicData.Topic) -> None: 
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> rti.connextdds.TopicBuiltinTopicData.Topic: 
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> rti.connextdds.TopicBuiltinTopicData.Topic: 
            """
            Remove and return the item at index ``i``
            """
        def remove(self, x: rti.connextdds.TopicBuiltinTopicData.Topic) -> None: 
            """
            Remove the first item from the list whose value is x. It is an error if there is no such item.
            """
        __hash__: NoneType
        pass
    class ValidLoanedSamples():
        def __enter__(self) -> rti.connextdds.TopicBuiltinTopicData.ValidLoanedSamples: ...
        def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...
        def __iter__(self) -> typing.Iterator[rti.connextdds.TopicBuiltinTopicData.LoanedSample]: ...
        pass
    class WriterContentFilter(TopicBuiltinTopicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def writer_attach(self) -> typing.Optional[object]: 
            """
            A writer-side filtering API to create some state that can facilitate filtering on the writer side.
            """
        def writer_compile(self, writer_filter_data: typing.Optional[object], property: rti.connextdds.ExpressionProperty, expression: str, parameters: rti.connextdds.StringSeq, type_code: typing.Optional[rti.connextdds.DynamicType], type_class_name: str, cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_detach(self, writer_filter_data: typing.Optional[object]) -> None: 
            """
            A writer-side filtering API to clean up a previously created state using writer_attach.
            """
        def writer_evaluate(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.TopicBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> rti.connextdds.CookieVector: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        def writer_finalize(self, writer_filter_data: typing.Optional[object], cookie: rti.connextdds.Cookie) -> None: 
            """
            A writer-side filtering API to clean up a previously compiled instance of the content filter.
            """
        def writer_return_loan(self, writer_filter_data: typing.Optional[object], cookies: rti.connextdds.CookieVector) -> None: 
            """
            A writer-side filtering API to return the loan on the list of DataReaders returned by writer_evaluate.
            """
        pass
    class WriterContentFilterHelper(TopicBuiltinTopicData.WriterContentFilter, TopicBuiltinTopicData.ContentFilter, ContentFilterBase):
        def __init__(self) -> None: ...
        def add_cookie(self, cookie: rti.connextdds.Cookie) -> None: 
            """
            A helper function which will add a Cookie to the Cookie sequence that is then returned by the writer_evaluate function.
            """
        def writer_evaluate_helper(self, writer_filter_data: typing.Optional[object], sample: rti.connextdds.TopicBuiltinTopicData, meta_data: rti.connextdds.FilterSampleInfo) -> None: 
            """
            A writer-side filtering API to compile an instance of the content filter according to the filter expression and parameters specified by a matching DataReader.
            """
        pass
    def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicData) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Create a default TopicBuiltinTopicData.
        """
    def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicData) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def deadline(self) -> Deadline:
        """
        Get the Deadline policy of the corresponding Topic.

        :type: Deadline
        """
    @builtins.property
    def destination_order(self) -> DestinationOrder:
        """
        Get the DestinationOrder policy of the corresponding Topic.

        :type: DestinationOrder
        """
    @builtins.property
    def durability(self) -> Durability:
        """
        Get the Durability policy of the corresponding Topic.

        :type: Durability
        """
    @builtins.property
    def durability_service(self) -> DurabilityService:
        """
        Get the DurabilityService policy of the corresponding Topic.

        :type: DurabilityService
        """
    @builtins.property
    def history(self) -> History:
        """
        Get the History policy of the corresponding Topic.

        :type: History
        """
    @builtins.property
    def key(self) -> BuiltinTopicKey:
        """
        Get the DCPS key to distinguish entries.

        :type: BuiltinTopicKey
        """
    @builtins.property
    def latency_budget(self) -> LatencyBudget:
        """
        Get the LatencyBudget policy of the corresponding Topic.

        :type: LatencyBudget
        """
    @builtins.property
    def lifespan(self) -> Lifespan:
        """
        Get the Lifespan policy of the corresponding Topic.

        :type: Lifespan
        """
    @builtins.property
    def liveliness(self) -> Liveliness:
        """
        Get the Liveliness policy of the corresponding Topic.

        :type: Liveliness
        """
    @builtins.property
    def name(self) -> str:
        """
        Get the name of the Topic.

        :type: str
        """
    @builtins.property
    def ownership(self) -> Ownership:
        """
        Get the Ownership policy of the corresponding Topic.

        :type: Ownership
        """
    @builtins.property
    def reliability(self) -> Reliability:
        """
        Get the Reliability policy of the corresponding Topic.

        :type: Reliability
        """
    @builtins.property
    def representation(self) -> DataRepresentation:
        """
        Get the DataRepresentation policy of the corresponding Topic.

        :type: DataRepresentation
        """
    @builtins.property
    def resource_limits(self) -> ResourceLimits:
        """
        Get the ResourceLimits policy of the corresponding Topic.

        :type: ResourceLimits
        """
    @builtins.property
    def topic_data(self) -> TopicData:
        """
        Get the TopicData policy of the corresponding Topic.

        :type: TopicData
        """
    @builtins.property
    def transport_priority(self) -> TransportPriority:
        """
        Get the TransportPriority policy of the corresponding Topic.

        :type: TransportPriority
        """
    @builtins.property
    def type_name(self) -> str:
        """
        Get the name of the type attached to the Topic.

        :type: str
        """
    __hash__: NoneType
    topic_name: str
    pass
class TopicBuiltinTopicDataSeq():
    def __add__(self, arg0: rti.connextdds.TopicBuiltinTopicDataSeq) -> rti.connextdds.TopicBuiltinTopicDataSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.TopicBuiltinTopicData) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicDataSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.TopicBuiltinTopicDataSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicData: ...
    def __iadd__(self, arg0: rti.connextdds.TopicBuiltinTopicDataSeq) -> rti.connextdds.TopicBuiltinTopicDataSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicDataSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TopicBuiltinTopicDataSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.TopicBuiltinTopicData]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicDataSeq: ...
    def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicDataSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicDataSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.TopicBuiltinTopicData) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.TopicBuiltinTopicDataSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.TopicBuiltinTopicData) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.TopicBuiltinTopicData) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.TopicBuiltinTopicDataSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.TopicBuiltinTopicData) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.TopicBuiltinTopicData: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.TopicBuiltinTopicData: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.TopicBuiltinTopicData) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class TopicBuiltinTopicDataTimestampedSeq():
    def __add__(self, arg0: rti.connextdds.TopicBuiltinTopicDataTimestampedSeq) -> rti.connextdds.TopicBuiltinTopicDataTimestampedSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.TopicBuiltinTopicDataTimestampedSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.TopicBuiltinTopicDataTimestampedSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]: ...
    def __iadd__(self, arg0: rti.connextdds.TopicBuiltinTopicDataTimestampedSeq) -> rti.connextdds.TopicBuiltinTopicDataTimestampedSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicDataTimestampedSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TopicBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicDataTimestampedSeq: ...
    def __ne__(self, arg0: rti.connextdds.TopicBuiltinTopicDataTimestampedSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.TopicBuiltinTopicDataTimestampedSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.TopicBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.TopicBuiltinTopicDataTimestampedSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: tuple[rti.connextdds.TopicBuiltinTopicData, rti.connextdds.Time]) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class TopicData():
    def __eq__(self, arg0: rti.connextdds.TopicData) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty TopicData QoS policy.
        """
    @typing.overload
    def __init__(self, data: rti.connextdds.Uint8Seq) -> None: 
        """
        Create a TopicData object from a data sequence.
        """
    def __iter__(self) -> typing.Iterator[int]: ...
    def __ne__(self, arg0: rti.connextdds.TopicData) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> Uint8Seq:
        """
        Get/set a copy of the TopicData value.

        :type: Uint8Seq
        """
    @value.setter
    def value(self, arg1: Uint8Seq) -> None:
        """
        Get/set a copy of the TopicData value.
        """
    __hash__: NoneType
    pass
class TopicDescription(ITopicDescription, IEntity):
    def __eq__(self, arg0: rti.connextdds.TopicDescription) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, topic: rti.connextdds.ITopicDescription) -> None: 
        """
        Cast a Topic to a TopicDescription.
        """
    @typing.overload
    def __init__(self, entity: rti.connextdds.IEntity) -> None: 
        """
        Cast a Topic to a TopicDescription.
        """
    def __ne__(self, arg0: rti.connextdds.TopicDescription) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class NoOpTopicListener(TopicListener):
    def __init__(self) -> None: ...
    def on_inconsistent_topic(self, arg0: rti.connextdds.Topic, arg1: rti.connextdds.InconsistentTopicStatus) -> None: 
        """
        Inconsistent topic callback.
        """
    pass
class TopicQos():
    def __eq__(self, arg0: rti.connextdds.TopicQos) -> bool: 
        """
        Test for equality
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a TopicQos with the default value for each policy.
        """
    @typing.overload
    def __init__(self, topic: rti.connextdds.IAnyTopic) -> None: 
        """
        Create a TopicQos with settings equivalent to those of the provided Topic.
        """
    @typing.overload
    def __init__(self, other: rti.connextdds.TopicQos) -> None: 
        """
        Create a copy of a TopicQos object.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TopicData) -> rti.connextdds.TopicQos: 
        """
        Set the TopicDataQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Durability) -> rti.connextdds.TopicQos: 
        """
        Set the DurabilityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DurabilityService) -> rti.connextdds.TopicQos: 
        """
        Set the DurabilityServiceQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Deadline) -> rti.connextdds.TopicQos: 
        """
        Set the DeadlineQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.LatencyBudget) -> rti.connextdds.TopicQos: 
        """
        Set the LatencyBudgetQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Liveliness) -> rti.connextdds.TopicQos: 
        """
        Set the LivelinessQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Reliability) -> rti.connextdds.TopicQos: 
        """
        Set the ReliabilityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DestinationOrder) -> rti.connextdds.TopicQos: 
        """
        Set the DestinationOrderQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.History) -> rti.connextdds.TopicQos: 
        """
        Set the HistoryQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.ResourceLimits) -> rti.connextdds.TopicQos: 
        """
        Set the ResourceLimitsQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.TransportPriority) -> rti.connextdds.TopicQos: 
        """
        Set the TransportPriorityQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Lifespan) -> rti.connextdds.TopicQos: 
        """
        Set the LifespanQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.Ownership) -> rti.connextdds.TopicQos: 
        """
        Set the OwnershipQoS.
        """
    @typing.overload
    def __lshift__(self, arg0: rti.connextdds.DataRepresentation) -> rti.connextdds.TopicQos: 
        """
        Set the DataRepresentationQoS.
        """
    def __ne__(self, arg0: rti.connextdds.TopicQos) -> bool: 
        """
        Test for inequality.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TopicData) -> rti.connextdds.TopicQos: 
        """
        Get the TopicDataQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Durability) -> rti.connextdds.TopicQos: 
        """
        Get the DurabilityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DurabilityService) -> rti.connextdds.TopicQos: 
        """
        Get the DurabilityServiceQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Deadline) -> rti.connextdds.TopicQos: 
        """
        Get the DeadlineQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.LatencyBudget) -> rti.connextdds.TopicQos: 
        """
        Get the LatencyBudgetQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Liveliness) -> rti.connextdds.TopicQos: 
        """
        Get the LivelinessQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Reliability) -> rti.connextdds.TopicQos: 
        """
        Get the ReliabilityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DestinationOrder) -> rti.connextdds.TopicQos: 
        """
        Get the DestinationOrderQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.History) -> rti.connextdds.TopicQos: 
        """
        Get the HistoryQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.ResourceLimits) -> rti.connextdds.TopicQos: 
        """
        Get the ResourceLimitsQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.TransportPriority) -> rti.connextdds.TopicQos: 
        """
        Get the TransportPriorityQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Lifespan) -> rti.connextdds.TopicQos: 
        """
        Get the LifespanQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.Ownership) -> rti.connextdds.TopicQos: 
        """
        Get the OwnershipQoS.
        """
    @typing.overload
    def __rshift__(self, arg0: rti.connextdds.DataRepresentation) -> rti.connextdds.TopicQos: 
        """
        Get the DataRepresentationQoS.
        """
    def __str__(self) -> str: ...
    def to_string(self, format: rti.connextdds.QosPrintFormat = QosPrintFormat(), base: typing.Optional[rti.connextdds.TopicQos] = None, print_all: bool = False) -> str: 
        """
        Convert QoS to string based on params.
        """
    @builtins.property
    def data_representation(self) -> DataRepresentation:
        """
        Get/set DataRepresentation QoS.

        :type: DataRepresentation
        """
    @data_representation.setter
    def data_representation(self, arg1: DataRepresentation) -> None:
        """
        Get/set DataRepresentation QoS.
        """
    @builtins.property
    def deadline(self) -> Deadline:
        """
        Get/set Deadline QoS.

        :type: Deadline
        """
    @deadline.setter
    def deadline(self, arg1: Deadline) -> None:
        """
        Get/set Deadline QoS.
        """
    @builtins.property
    def destination_order(self) -> DestinationOrder:
        """
        Get/set DestinationOrder QoS.

        :type: DestinationOrder
        """
    @destination_order.setter
    def destination_order(self, arg1: DestinationOrder) -> None:
        """
        Get/set DestinationOrder QoS.
        """
    @builtins.property
    def durability(self) -> Durability:
        """
        Get/set Durability QoS.

        :type: Durability
        """
    @durability.setter
    def durability(self, arg1: Durability) -> None:
        """
        Get/set Durability QoS.
        """
    @builtins.property
    def durability_service(self) -> DurabilityService:
        """
        Get/set DurabilityService QoS.

        :type: DurabilityService
        """
    @durability_service.setter
    def durability_service(self, arg1: DurabilityService) -> None:
        """
        Get/set DurabilityService QoS.
        """
    @builtins.property
    def history(self) -> History:
        """
        Get/set History QoS.

        :type: History
        """
    @history.setter
    def history(self, arg1: History) -> None:
        """
        Get/set History QoS.
        """
    @builtins.property
    def latency_budget(self) -> LatencyBudget:
        """
        Get/set LatencyBudget QoS.

        :type: LatencyBudget
        """
    @latency_budget.setter
    def latency_budget(self, arg1: LatencyBudget) -> None:
        """
        Get/set LatencyBudget QoS.
        """
    @builtins.property
    def lifespan(self) -> Lifespan:
        """
        Get/set Lifespan QoS.

        :type: Lifespan
        """
    @lifespan.setter
    def lifespan(self, arg1: Lifespan) -> None:
        """
        Get/set Lifespan QoS.
        """
    @builtins.property
    def liveliness(self) -> Liveliness:
        """
        Get/set Liveliness QoS.

        :type: Liveliness
        """
    @liveliness.setter
    def liveliness(self, arg1: Liveliness) -> None:
        """
        Get/set Liveliness QoS.
        """
    @builtins.property
    def ownership(self) -> Ownership:
        """
        Get/set Ownership QoS.

        :type: Ownership
        """
    @ownership.setter
    def ownership(self, arg1: Ownership) -> None:
        """
        Get/set Ownership QoS.
        """
    @builtins.property
    def reliability(self) -> Reliability:
        """
        Get/set Reliability QoS.

        :type: Reliability
        """
    @reliability.setter
    def reliability(self, arg1: Reliability) -> None:
        """
        Get/set Reliability QoS.
        """
    @builtins.property
    def resource_limits(self) -> ResourceLimits:
        """
        Get/set ResourceLimits QoS.

        :type: ResourceLimits
        """
    @resource_limits.setter
    def resource_limits(self, arg1: ResourceLimits) -> None:
        """
        Get/set ResourceLimits QoS.
        """
    @builtins.property
    def topic_data(self) -> TopicData:
        """
        Get/set TopicData QoS.

        :type: TopicData
        """
    @topic_data.setter
    def topic_data(self, arg1: TopicData) -> None:
        """
        Get/set TopicData QoS.
        """
    @builtins.property
    def transport_priority(self) -> TransportPriority:
        """
        Get/set TransportPriority QoS.

        :type: TransportPriority
        """
    @transport_priority.setter
    def transport_priority(self, arg1: TransportPriority) -> None:
        """
        Get/set TransportPriority QoS.
        """
    __hash__: NoneType
    pass
class TopicQuery():
    def __enter__(self) -> rti.connextdds.TopicQuery: 
        """
        Enter a context managed block for a TopicQuery.
        """
    def __eq__(self, arg0: rti.connextdds.TopicQuery) -> bool: 
        """
        Compare DataStateEx objects for equality.
        """
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: 
        """
        Exit a context managed block for a TopicQuery.
        """
    def __init__(self, reader: rti.connextdds.IAnyDataReader, selection: rti.connextdds.TopicQuerySelection) -> None: 
        """
        Creates a TopicQuery for a given DataReader.
        """
    def __ne__(self, arg0: rti.connextdds.TopicQuery) -> bool: 
        """
        Compare DataStateEx objects for inequality.
        """
    def close(self) -> None: 
        """
        Deletes and cancels this TopicQuery.
        """
    @staticmethod
    def find(reader: rti.connextdds.IAnyDataReader, guid: rti.connextdds.Guid) -> typing.Optional[rti.connextdds.TopicQuery]: 
        """
        Lookup a TopicQuery by its GUID in the reader that createdit
        """
    def retain(self) -> None: 
        """
        Disable automatic destruction of this TopicQuery.
        """
    @staticmethod
    def select_all(reader: rti.connextdds.IAnyDataReader) -> rti.connextdds.TopicQuery: 
        """
        Create a TopicQuery that requests all data.
        """
    def unretain(self) -> None: ...
    @staticmethod
    def use_reader_content_filter(reader: rti.connextdds.IAnyDataReader) -> rti.connextdds.TopicQuery: 
        """
        Create a TopicQuery with a DataReader's content filter.
        """
    @builtins.property
    def closed(self) -> bool:
        """
        Indicates whether this TopicQuery has been closed with close().

        :type: bool
        """
    @builtins.property
    def datareader(self) -> AnyDataReader:
        """
        Gets the DataReader associated to this TopicQuery.

        :type: AnyDataReader
        """
    @builtins.property
    def guid(self) -> Guid:
        """
        The TopicQuery GUID.

        :type: Guid
        """
    __hash__: NoneType
    pass
class TopicQueryData():
    @staticmethod
    def create_from_service_request(service_request: rti.connextdds.ServiceRequest) -> rti.connextdds.TopicQueryData: 
        """
        Creates a TopicQueryData from a ServiceRequest.
        """
    @builtins.property
    def original_related_reader_guid(self) -> Guid:
        """
        Identifies the DataReader that created the TopicQuery.

        :type: Guid
        """
    @builtins.property
    def selection(self) -> TopicQuerySelection:
        """
        The data selection.

        :type: TopicQuerySelection
        """
    @builtins.property
    def topic_name(self) -> str:
        """
        The topic name of the DataReader.

        :type: str
        """
    pass
class TopicQueryDispatch():
    def __eq__(self, arg0: rti.connextdds.TopicQueryDispatch) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @staticmethod
    @typing.overload
    def __init__(*args, **kwargs) -> typing.Any: 
        """
        Creates a policy with the provided values for enable, publication_period and samples_per_period.
        """
    def __ne__(self, arg0: rti.connextdds.TopicQueryDispatch) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def enable(self) -> bool:
        """
        Allows this writer to dispatch TopicQueries.

        :type: bool
        """
    @enable.setter
    def enable(self, arg1: bool) -> None:
        """
        Allows this writer to dispatch TopicQueries.
        """
    @builtins.property
    def publication_period(self) -> Duration:
        """
        The periodic interval at which samples are published.

        :type: Duration
        """
    @publication_period.setter
    def publication_period(self, arg1: Duration) -> None:
        """
        The periodic interval at which samples are published.
        """
    @builtins.property
    def samples_per_period(self) -> int:
        """
        The maximum number of samples to publish in each publication_period.

        :type: int
        """
    @samples_per_period.setter
    def samples_per_period(self, arg1: int) -> None:
        """
        The maximum number of samples to publish in each publication_period.
        """
    __hash__: NoneType
    pass
class TopicQuerySelection():
    @typing.overload
    def __init__(self, filter: rti.connextdds.Filter) -> None: 
        """
        Creates a TopicQuerySelection.
        """
    @typing.overload
    def __init__(self, filter: rti.connextdds.Filter, kind: rti.connextdds.TopicQuerySelectionKind) -> None: 
        """
        Creates a TopicQuerySelection with a selection kind.
        """
    @builtins.property
    def filter(self) -> Filter:
        """
        The filter.

        :type: Filter
        """
    @filter.setter
    def filter(self, arg1: Filter) -> None:
        """
        The filter.
        """
    @builtins.property
    def kind(self) -> TopicQuerySelectionKind:
        """
        Indicates whether the sample selection is limited to cached samples or not.

        :type: TopicQuerySelectionKind
        """
    @kind.setter
    def kind(self, arg1: TopicQuerySelectionKind) -> None:
        """
        Indicates whether the sample selection is limited to cached samples or not.
        """
    pass
class TopicQuerySelectionKind():
    class TopicQuerySelectionKind():
        """
        Members:

          HISTORY_SNAPSHOT : [default] Indicates that the TopicQuery may only select samples that were in the DataWriter cache upon reception.

          CONTINUOUS : Indicates that the TopicQuery may continue selecting samples published after its reception.

        The subscribing application must explicitly delete the TopicQuery (see TopicQuery.close()) to signal the DataWriters to stop publishing samples for it.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        CONTINUOUS: rti.connextdds.TopicQuerySelectionKind.TopicQuerySelectionKind
        HISTORY_SNAPSHOT: rti.connextdds.TopicQuerySelectionKind.TopicQuerySelectionKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.TopicQuerySelectionKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.TopicQuerySelectionKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.TopicQuerySelectionKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TopicQuerySelectionKind.TopicQuerySelectionKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.TopicQuerySelectionKind.TopicQuerySelectionKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.TopicQuerySelectionKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.TopicQuerySelectionKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.TopicQuerySelectionKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> TopicQuerySelectionKind.TopicQuerySelectionKind:
        """
        Retrieves the actual enumerated value.

        :type: TopicQuerySelectionKind.TopicQuerySelectionKind
        """
    CONTINUOUS: rti.connextdds.TopicQuerySelectionKind.TopicQuerySelectionKind
    HISTORY_SNAPSHOT: rti.connextdds.TopicQuerySelectionKind.TopicQuerySelectionKind
    __hash__: NoneType
    pass
class TopicSeq():
    def __add__(self, arg0: list[rti.connextdds.Topic]) -> list[rti.connextdds.Topic]: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.Topic) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: list[rti.connextdds.Topic]) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> list[rti.connextdds.Topic]: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.Topic: ...
    def __iadd__(self, arg0: list[rti.connextdds.Topic]) -> list[rti.connextdds.Topic]: ...
    def __imul__(self, arg0: int) -> list[rti.connextdds.Topic]: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: list[rti.connextdds.Topic]) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.Topic]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> list[rti.connextdds.Topic]: ...
    def __ne__(self, arg0: list[rti.connextdds.Topic]) -> bool: ...
    def __rmul__(self, arg0: int) -> list[rti.connextdds.Topic]: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.Topic) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: list[rti.connextdds.Topic]) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.Topic) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.Topic) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: list[rti.connextdds.Topic]) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.Topic) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.Topic: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.Topic: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.Topic) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class TransportBuiltin():
    def __eq__(self, arg0: rti.connextdds.TransportBuiltin) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, mask: rti.connextdds.TransportBuiltinMask) -> None: 
        """
        Creates an instnace with the transport selection that the mask specifies.
        """
    def __ne__(self, arg0: rti.connextdds.TransportBuiltin) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def mask(self) -> TransportBuiltinMask:
        """
        The selected transports through a mask.

        :type: TransportBuiltinMask
        """
    @mask.setter
    def mask(self, arg1: TransportBuiltinMask) -> None:
        """
        The selected transports through a mask.
        """
    __hash__: NoneType
    all: rti.connextdds.TransportBuiltin
    none: rti.connextdds.TransportBuiltin
    shmem: rti.connextdds.TransportBuiltin
    udpv4: rti.connextdds.TransportBuiltin
    udpv4_wan: rti.connextdds.TransportBuiltin
    udpv6: rti.connextdds.TransportBuiltin
    pass
class TransportBuiltinMask():
    def __and__(self, arg0: rti.connextdds.TransportBuiltinMask) -> rti.connextdds.TransportBuiltinMask: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> bool: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.TransportBuiltinMask) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.TransportBuiltinMask) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.TransportBuiltinMask) -> rti.connextdds.TransportBuiltinMask: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.TransportBuiltinMask: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a TransportBuiltinMask equivalent to TransportBuiltinMask.NONE
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.TransportBuiltinMask) -> rti.connextdds.TransportBuiltinMask: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.TransportBuiltinMask: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.TransportBuiltinMask) -> rti.connextdds.TransportBuiltinMask: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.TransportBuiltinMask: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.TransportBuiltinMask) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.TransportBuiltinMask) -> rti.connextdds.TransportBuiltinMask: 
        """
        Bitwise logical OR of masks.
        """
    def __repr__(self) -> str: 
        """
        Convert mask to string.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.TransportBuiltinMask: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: 
        """
        Convert mask to string.
        """
    def __xor__(self, arg0: rti.connextdds.TransportBuiltinMask) -> rti.connextdds.TransportBuiltinMask: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.TransportBuiltinMask: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.TransportBuiltinMask: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.TransportBuiltinMask: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.TransportBuiltinMask: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.TransportBuiltinMask: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.TransportBuiltinMask: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ALL: rti.connextdds.TransportBuiltinMask
    NONE: rti.connextdds.TransportBuiltinMask
    SHMEM: rti.connextdds.TransportBuiltinMask
    UDPv4: rti.connextdds.TransportBuiltinMask
    UDPv4_WAN: rti.connextdds.TransportBuiltinMask
    UDPv6: rti.connextdds.TransportBuiltinMask
    __hash__: NoneType
    pass
class TransportClassId():
    class TransportClassId():
        """
        Members:

          INVALID : Invalid.

          ANY : Any.

          UDPv4 : UDPv4.

          UDPv4_WAN : UDPv4 WAN.

          SHMEM : Shared memory.

          SHMEM_510 : Shared Memory from 5.1.0 and earlier.

          INTRA : Intra-participant.

          UDPv6 : UDPv6.

          UDPv6_510 : UDPv6 for 5.1.0 and earlier.

          TCPV4_LAN : TCPv4 LAN mode.

          TCPV4_WAN : TCPv4 WAN mode.

          TLSV4_LAN : TCPv4 LAN mode with TLS.

          TLSV4_WAN : TCPv4 WAN mode with TLS.

          RESERVED_RANGE : eserved for additional user-defined transport plugins.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        ANY: rti.connextdds.TransportClassId.TransportClassId
        INTRA: rti.connextdds.TransportClassId.TransportClassId
        INVALID: rti.connextdds.TransportClassId.TransportClassId
        RESERVED_RANGE: rti.connextdds.TransportClassId.TransportClassId
        SHMEM: rti.connextdds.TransportClassId.TransportClassId
        SHMEM_510: rti.connextdds.TransportClassId.TransportClassId
        TCPV4_LAN: rti.connextdds.TransportClassId.TransportClassId
        TCPV4_WAN: rti.connextdds.TransportClassId.TransportClassId
        TLSV4_LAN: rti.connextdds.TransportClassId.TransportClassId
        TLSV4_WAN: rti.connextdds.TransportClassId.TransportClassId
        UDPv4: rti.connextdds.TransportClassId.TransportClassId
        UDPv4_WAN: rti.connextdds.TransportClassId.TransportClassId
        UDPv6: rti.connextdds.TransportClassId.TransportClassId
        UDPv6_510: rti.connextdds.TransportClassId.TransportClassId
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.TransportClassId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.TransportClassId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.TransportClassId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TransportClassId.TransportClassId) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.TransportClassId.TransportClassId: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.TransportClassId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.TransportClassId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.TransportClassId) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> TransportClassId.TransportClassId:
        """
        Retrieves the actual enumerated value.

        :type: TransportClassId.TransportClassId
        """
    ANY: rti.connextdds.TransportClassId.TransportClassId
    INTRA: rti.connextdds.TransportClassId.TransportClassId
    INVALID: rti.connextdds.TransportClassId.TransportClassId
    RESERVED_RANGE: rti.connextdds.TransportClassId.TransportClassId
    SHMEM: rti.connextdds.TransportClassId.TransportClassId
    SHMEM_510: rti.connextdds.TransportClassId.TransportClassId
    TCPV4_LAN: rti.connextdds.TransportClassId.TransportClassId
    TCPV4_WAN: rti.connextdds.TransportClassId.TransportClassId
    TLSV4_LAN: rti.connextdds.TransportClassId.TransportClassId
    TLSV4_WAN: rti.connextdds.TransportClassId.TransportClassId
    UDPv4: rti.connextdds.TransportClassId.TransportClassId
    UDPv4_WAN: rti.connextdds.TransportClassId.TransportClassId
    UDPv6: rti.connextdds.TransportClassId.TransportClassId
    UDPv6_510: rti.connextdds.TransportClassId.TransportClassId
    __hash__: NoneType
    pass
class TransportInfo():
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an instance with default values.
        """
    @typing.overload
    def __init__(self, class_id: rti.connextdds.TransportClassId.TransportClassId, message_size_max: int) -> None: 
        """
        Creates an instance with the specified class id and max size.
        """
    @builtins.property
    def class_id(self) -> TransportClassId:
        """
        The class_id identifies the transport associated with the message_size_max.

        :type: TransportClassId
        """
    @class_id.setter
    def class_id(self, arg1: TransportClassId.TransportClassId) -> None:
        """
        The class_id identifies the transport associated with the message_size_max.
        """
    @builtins.property
    def message_size_max(self) -> int:
        """
        The maximum size of an RTPS message in bytes that can be sent or received by the transport plugin identified by the class_id.

        :type: int
        """
    @message_size_max.setter
    def message_size_max(self, arg1: int) -> None:
        """
        The maximum size of an RTPS message in bytes that can be sent or received by the transport plugin identified by the class_id.
        """
    pass
class TransportInfoSeq():
    def __add__(self, arg0: rti.connextdds.TransportInfoSeq) -> rti.connextdds.TransportInfoSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.TransportInfo) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.TransportInfoSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.TransportInfoSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.TransportInfo: ...
    def __iadd__(self, arg0: rti.connextdds.TransportInfoSeq) -> rti.connextdds.TransportInfoSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.TransportInfoSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TransportInfoSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.TransportInfo]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.TransportInfoSeq: ...
    def __ne__(self, arg0: rti.connextdds.TransportInfoSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.TransportInfoSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.TransportInfo) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.TransportInfoSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.TransportInfo) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.TransportInfo) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.TransportInfoSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.TransportInfo) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.TransportInfo: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.TransportInfo: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.TransportInfo) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class TransportInfoVector():
    """
    A DDS standard container with functionality similar to a C++ vector.
    """
    def __eq__(self, arg0: rti.connextdds.TransportInfoVector) -> bool: 
        """
        Compare TransportInfoVectors for equality.
        """
    def __getitem__(self, arg0: int) -> rti.connextdds.TransportInfo: 
        """
        Get the value at the specified index.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create an empty TransportInfoVector
        """
    @typing.overload
    def __init__(self, size: int) -> None: 
        """
        Create a TransportInfoVector with a preallocated size.
        """
    @typing.overload
    def __init__(self, vector: rti.connextdds.TransportInfoVector) -> None: 
        """
        Create a copy from another TransportInfoVector.
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, list: rti.connextdds.TransportInfoSeq) -> None: 
        """
        Create a TransportInfoVector from a list of values.
        """
    def __iter__(self) -> typing.Iterator[rti.connextdds.TransportInfo]: 
        """
        Iterate over the contents of the vector.
        """
    def __len__(self) -> int: 
        """
        Get the length of the TransportInfoVector.
        """
    def __ne__(self, arg0: rti.connextdds.TransportInfoVector) -> bool: 
        """
        Compare TransportInfoVectors for inequality.
        """
    def __setitem__(self, arg0: int, arg1: rti.connextdds.TransportInfo) -> None: 
        """
        Set the value at the specified index.
        """
    def clear(self) -> None: 
        """
        Resize TransportInfoVector to 0.
        """
    def resize(self, size: int) -> None: 
        """
        Resize TransportInfoVector.
        """
    __hash__: NoneType
    pass
class TransportMulticast():
    def __eq__(self, arg0: rti.connextdds.TransportMulticast) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, value: rti.connextdds.TransportMulticastSettingsSeq, kind: rti.connextdds.TransportMulticastKind) -> None: 
        """
        Creates an instance with the speicfied multicast settings.
        """
    def __ne__(self, arg0: rti.connextdds.TransportMulticast) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def kind(self) -> TransportMulticastKind:
        """
        A value that specifies a way to determine how to obtain the multicast address.

        :type: TransportMulticastKind
        """
    @kind.setter
    def kind(self, arg1: TransportMulticastKind) -> None:
        """
        A value that specifies a way to determine how to obtain the multicast address.
        """
    @builtins.property
    def value(self) -> TransportMulticastSettingsSeq:
        """
        A sequence of multicast communications settings.

        :type: TransportMulticastSettingsSeq
        """
    @value.setter
    def value(self, arg1: TransportMulticastSettingsSeq) -> None:
        """
        A sequence of multicast communications settings.
        """
    __hash__: NoneType
    pass
class TransportMulticastKind():
    class TransportMulticastKind():
        """
        Members:

          AUTOMATIC : Selects the multicast address automatically.

        NOTE: This setting is required when using the TransportMulticastMapping.

          UNICAST : Selects a unicast-only mode.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        AUTOMATIC: rti.connextdds.TransportMulticastKind.TransportMulticastKind
        UNICAST: rti.connextdds.TransportMulticastKind.TransportMulticastKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.TransportMulticastKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.TransportMulticastKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.TransportMulticastKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TransportMulticastKind.TransportMulticastKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.TransportMulticastKind.TransportMulticastKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.TransportMulticastKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.TransportMulticastKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.TransportMulticastKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> TransportMulticastKind.TransportMulticastKind:
        """
        Retrieves the actual enumerated value.

        :type: TransportMulticastKind.TransportMulticastKind
        """
    AUTOMATIC: rti.connextdds.TransportMulticastKind.TransportMulticastKind
    UNICAST: rti.connextdds.TransportMulticastKind.TransportMulticastKind
    __hash__: NoneType
    pass
class TransportMulticastMapping():
    def __eq__(self, arg0: rti.connextdds.TransportMulticastMapping) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, mappings: rti.connextdds.MulticastMappingSeq) -> None: 
        """
        Creates an object with with specified mappings.
        """
    def __ne__(self, arg0: rti.connextdds.TransportMulticastMapping) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> MulticastMappingSeq:
        """
        A sequence of transport multicast mappings.

        :type: MulticastMappingSeq
        """
    @value.setter
    def value(self, arg1: MulticastMappingSeq) -> None:
        """
        A sequence of transport multicast mappings.
        """
    __hash__: NoneType
    pass
class TransportMulticastMappingFunction():
    def __eq__(self, arg0: rti.connextdds.TransportMulticastMappingFunction) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, dll: str, function_name: str) -> None: 
        """
        Create a mapping function instance.
        """
    def __ne__(self, arg0: rti.connextdds.TransportMulticastMappingFunction) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def dll(self) -> typing.Optional[str]:
        """
        The name of the dynamic library containing the mapping function.

        :type: typing.Optional[str]
        """
    @dll.setter
    def dll(self, arg1: str) -> None:
        """
        The name of the dynamic library containing the mapping function.
        """
    @builtins.property
    def function_name(self) -> typing.Optional[str]:
        """
        The name of the mapping function.

        :type: typing.Optional[str]
        """
    @function_name.setter
    def function_name(self, arg1: str) -> None:
        """
        The name of the mapping function.
        """
    __hash__: NoneType
    pass
class TransportMulticastSeq():
    def __add__(self, arg0: rti.connextdds.TransportMulticastSeq) -> rti.connextdds.TransportMulticastSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.TransportMulticast) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.TransportMulticastSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.TransportMulticastSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.TransportMulticast: ...
    def __iadd__(self, arg0: rti.connextdds.TransportMulticastSeq) -> rti.connextdds.TransportMulticastSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.TransportMulticastSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TransportMulticastSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.TransportMulticast]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.TransportMulticastSeq: ...
    def __ne__(self, arg0: rti.connextdds.TransportMulticastSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.TransportMulticastSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.TransportMulticast) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.TransportMulticastSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.TransportMulticast) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.TransportMulticast) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.TransportMulticastSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.TransportMulticast) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.TransportMulticast: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.TransportMulticast: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.TransportMulticast) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class TransportMulticastSettings():
    def __eq__(self, arg0: rti.connextdds.TransportMulticastSettings) -> bool: 
        """
        Test for equality.
        """
    def __init__(self, transports: rti.connextdds.StringSeq, receive_address: str, receive_port: int) -> None: 
        """
        Creates an instance with the specified transport aliases, receive address and receive port.
        """
    def __ne__(self, arg0: rti.connextdds.TransportMulticastSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def receive_address(self) -> str:
        """
        The multicast group address on which the entity can receive data.

        :type: str
        """
    @receive_address.setter
    def receive_address(self, arg1: str) -> None:
        """
        The multicast group address on which the entity can receive data.
        """
    @builtins.property
    def receive_port(self) -> int:
        """
        The multicast port on which the entity can receive data.

        :type: int
        """
    @receive_port.setter
    def receive_port(self, arg1: int) -> None:
        """
        The multicast port on which the entity can receive data.
        """
    @builtins.property
    def transports(self) -> StringSeq:
        """
        A sequence of transport aliases that specifies the transports on which to receive multicast traffic for the entity.

        This property's getter returns a deep copy.

        :type: StringSeq
        """
    @transports.setter
    def transports(self, arg1: StringSeq) -> None:
        """
        A sequence of transport aliases that specifies the transports on which to receive multicast traffic for the entity.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class TransportMulticastSettingsSeq():
    def __add__(self, arg0: rti.connextdds.TransportMulticastSettingsSeq) -> rti.connextdds.TransportMulticastSettingsSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.TransportMulticastSettings) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.TransportMulticastSettingsSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.TransportMulticastSettingsSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.TransportMulticastSettings: ...
    def __iadd__(self, arg0: rti.connextdds.TransportMulticastSettingsSeq) -> rti.connextdds.TransportMulticastSettingsSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.TransportMulticastSettingsSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TransportMulticastSettingsSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.TransportMulticastSettings]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.TransportMulticastSettingsSeq: ...
    def __ne__(self, arg0: rti.connextdds.TransportMulticastSettingsSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.TransportMulticastSettingsSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.TransportMulticastSettings) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.TransportMulticastSettingsSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.TransportMulticastSettings) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.TransportMulticastSettings) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.TransportMulticastSettingsSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.TransportMulticastSettings) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.TransportMulticastSettings: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.TransportMulticastSettings: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.TransportMulticastSettings) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class TransportPriority():
    def __eq__(self, arg0: rti.connextdds.TransportPriority) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates a policy with priority 0.
        """
    @typing.overload
    def __init__(self, priority: int) -> None: 
        """
        Creates a policy with the specified priority.
        """
    def __ne__(self, arg0: rti.connextdds.TransportPriority) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> int:
        """
        The priority.

        :type: int
        """
    @value.setter
    def value(self, arg1: int) -> None:
        """
        The priority.
        """
    __hash__: NoneType
    pass
class TransportSelection():
    def __eq__(self, arg0: rti.connextdds.TransportSelection) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, enabled_transports: rti.connextdds.StringSeq) -> None: 
        """
        Creates an instance with the specified transport aliases.
        """
    def __ne__(self, arg0: rti.connextdds.TransportSelection) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> StringSeq:
        """
        A sequence of transport aliases that specifies the transport instances available for use by the entity.

        This property's getter returns a deep copy.

        :type: StringSeq
        """
    @value.setter
    def value(self, arg1: StringSeq) -> None:
        """
        A sequence of transport aliases that specifies the transport instances available for use by the entity.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class TransportUnicast():
    def __eq__(self, arg0: rti.connextdds.TransportUnicast) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, settings: rti.connextdds.TransportUnicastSettingsSeq) -> None: 
        """
        Creates an instance with the specified settings.
        """
    def __ne__(self, arg0: rti.connextdds.TransportUnicast) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> TransportUnicastSettingsSeq:
        """
        The unicast settings.

        This property's getter returns a deep copy.

        :type: TransportUnicastSettingsSeq
        """
    @value.setter
    def value(self, arg1: TransportUnicastSettingsSeq) -> None:
        """
        The unicast settings.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class TransportUnicastSettings():
    def __eq__(self, arg0: rti.connextdds.TransportUnicastSettings) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, transports: rti.connextdds.StringSeq, receive_port: int = 0) -> None: 
        """
        Creates the default policy.
        """
    def __ne__(self, arg0: rti.connextdds.TransportUnicastSettings) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def receive_port(self) -> int:
        """
        The unicast port on which the entity can receive data.

        :type: int
        """
    @receive_port.setter
    def receive_port(self, arg1: int) -> None:
        """
        The unicast port on which the entity can receive data.
        """
    @builtins.property
    def transports(self) -> StringSeq:
        """
        A sequence of transport aliases that specifies the unicast interfaces on which to receive unicast traffic for the entity.

        This property's getter returns a deep copy.

        :type: StringSeq
        """
    @transports.setter
    def transports(self, arg1: StringSeq) -> None:
        """
        A sequence of transport aliases that specifies the unicast interfaces on which to receive unicast traffic for the entity.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class TransportUnicastSettingsSeq():
    def __add__(self, arg0: rti.connextdds.TransportUnicastSettingsSeq) -> rti.connextdds.TransportUnicastSettingsSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.TransportUnicastSettings) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.TransportUnicastSettingsSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.TransportUnicastSettingsSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.TransportUnicastSettings: ...
    def __iadd__(self, arg0: rti.connextdds.TransportUnicastSettingsSeq) -> rti.connextdds.TransportUnicastSettingsSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.TransportUnicastSettingsSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TransportUnicastSettingsSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.TransportUnicastSettings]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.TransportUnicastSettingsSeq: ...
    def __ne__(self, arg0: rti.connextdds.TransportUnicastSettingsSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.TransportUnicastSettingsSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.TransportUnicastSettings) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.TransportUnicastSettingsSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.TransportUnicastSettings) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.TransportUnicastSettings) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.TransportUnicastSettingsSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.TransportUnicastSettings) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.TransportUnicastSettings: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.TransportUnicastSettings: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.TransportUnicastSettings) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class TriggeredConditions():
    def __contains__(self, arg0: rti.connextdds.ICondition) -> bool: ...
    def __getitem__(self, arg0: int) -> rti.connextdds.Condition: ...
    def __iter__(self) -> rti.connextdds.TriggeredConditionsIterator: ...
    def __len__(self) -> int: ...
    def __reversed__(self) -> rti.connextdds.TriggeredConditionsIterator: ...
    pass
class TriggeredConditionsIterator():
    def __next__(self) -> rti.connextdds.Condition: 
        """
        Get next triggered condition.
        """
    pass
class TypeConsistencyEnforcement():
    def __eq__(self, arg0: rti.connextdds.TypeConsistencyEnforcement) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, kind: rti.connextdds.TypeConsistencyEnforcementKind) -> None: 
        """
        Creates an instance with a specific enforcement kind.
        """
    def __ne__(self, arg0: rti.connextdds.TypeConsistencyEnforcement) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def force_type_validation(self) -> bool:
        """
        Controls whether type validation is forced.

        :type: bool
        """
    @force_type_validation.setter
    def force_type_validation(self, arg1: bool) -> None:
        """
        Controls whether type validation is forced.
        """
    @builtins.property
    def ignore_enum_literal_names(self) -> bool:
        """
        Controls whether enumeration literal names are ignored.

        :type: bool
        """
    @ignore_enum_literal_names.setter
    def ignore_enum_literal_names(self, arg1: bool) -> None:
        """
        Controls whether enumeration literal names are ignored.
        """
    @builtins.property
    def ignore_member_names(self) -> bool:
        """
        Controls whether member names are ignored.

        :type: bool
        """
    @ignore_member_names.setter
    def ignore_member_names(self, arg1: bool) -> None:
        """
        Controls whether member names are ignored.
        """
    @builtins.property
    def ignore_sequence_bounds(self) -> bool:
        """
        Controls whether sequence bounds are ignored.

        :type: bool
        """
    @ignore_sequence_bounds.setter
    def ignore_sequence_bounds(self, arg1: bool) -> None:
        """
        Controls whether sequence bounds are ignored.
        """
    @builtins.property
    def ignore_string_bounds(self) -> bool:
        """
        Controls whether string bounds are ignored.

        :type: bool
        """
    @ignore_string_bounds.setter
    def ignore_string_bounds(self, arg1: bool) -> None:
        """
        Controls whether string bounds are ignored.
        """
    @builtins.property
    def kind(self) -> TypeConsistencyEnforcementKind:
        """
        The enforcement kind.

        :type: TypeConsistencyEnforcementKind
        """
    @kind.setter
    def kind(self, arg1: TypeConsistencyEnforcementKind) -> None:
        """
        The enforcement kind.
        """
    @builtins.property
    def prevent_type_widening(self) -> bool:
        """
        Controls whether type widening is prevented.

        :type: bool
        """
    @prevent_type_widening.setter
    def prevent_type_widening(self, arg1: bool) -> None:
        """
        Controls whether type widening is prevented.
        """
    __hash__: NoneType
    allow_type_coercion: rti.connextdds.TypeConsistencyEnforcement
    auto_type_coercion: rti.connextdds.TypeConsistencyEnforcement
    disallow_type_coercion: rti.connextdds.TypeConsistencyEnforcement
    pass
class TypeConsistencyEnforcementKind():
    class TypeConsistencyEnforcementKind():
        """
        Members:

          DISALLOW_TYPE_COERCION : The DataWriter and the DataReader must support the same data type in order for them to communicate.

          ALLOW_TYPE_COERCION : The DataWriter and the DataReader need not support the same data type in order for them to communicate as long as the DataReader's type is assignable from the DataWriter's type.

          AUTO_TYPE_COERCION : [default] This AUTO value will be applied as TypeConsistencyKind.DISALLOW_TYPE_COERCION when the data type is annotated with @transfer_mode(SHMEM_REF) while using C, Traditional C++, or Modern C++ APIs. In all other cases, this AUTO value will be applied as TypeConsistencyKind.ALLOW_TYPE_COERCION.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        ALLOW_TYPE_COERCION: rti.connextdds.TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind
        AUTO_TYPE_COERCION: rti.connextdds.TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind
        DISALLOW_TYPE_COERCION: rti.connextdds.TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.TypeConsistencyEnforcementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.TypeConsistencyEnforcementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.TypeConsistencyEnforcementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.TypeConsistencyEnforcementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.TypeConsistencyEnforcementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.TypeConsistencyEnforcementKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind:
        """
        Retrieves the actual enumerated value.

        :type: TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind
        """
    ALLOW_TYPE_COERCION: rti.connextdds.TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind
    AUTO_TYPE_COERCION: rti.connextdds.TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind
    DISALLOW_TYPE_COERCION: rti.connextdds.TypeConsistencyEnforcementKind.TypeConsistencyEnforcementKind
    __hash__: NoneType
    pass
class TypeKind():
    class TypeKind():
        """
        Members:

          NO_TYPE : Sentinel indicating no value.

          PRIMITIVE_TYPE : Primitive type.

          CONSTRUCTED_TYPE : Constructed type.

          COLLECTION_TYPE : Collection type.

          AGGREGATION_TYPE : Aggregation type.

          ANNOTATION_TYPE : Annotation type.

          BOOLEAN_TYPE : Boolean type.

          UINT_8_TYPE : Unsigned 8-bit int type.

          INT_16_TYPE : Signed 16-bit int type.

          UINT_16_TYPE : Unsigned 16-bit int type.

          INT_32_TYPE : Signed 32-bit int type.

          UINT_32_TYPE : Unsigned 32-bit int type.

          INT_64_TYPE : Signed 64-bit int type.

          UINT_64_TYPE : Unsigned 64-bit int type

          FLOAT_32_TYPE : 32-bit floating point type.

          FLOAT_64_TYPE : 64-bit floating point type.

          FLOAT_128_TYPE : 128-bit floating point type.

          CHAR_8_TYPE : 8-bit character type.

          CHAR_16_TYPE : 16-bit character type.

          ENUMERATION_TYPE : Enumeration type.

          BITSET_TYPE : Bitset type.

          ALIAS_TYPE : Alias type.

          ARRAY_TYPE : Array type.

          SEQUENCE_TYPE : Sequence type.

          STRING_TYPE : String type.

          WSTRING_TYPE : Wide character string type.

          MAP_TYPE : Map type

          UNION_TYPE : Union type.

          STRUCTURE_TYPE : Structure type.

          UNION_FWD_DECL_TYPE : Forward declaration of a union type.

          STRUCTURE_FWD_DECL_TYPE : Forward declaration of structure type.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        AGGREGATION_TYPE: rti.connextdds.TypeKind.TypeKind
        ALIAS_TYPE: rti.connextdds.TypeKind.TypeKind
        ANNOTATION_TYPE: rti.connextdds.TypeKind.TypeKind
        ARRAY_TYPE: rti.connextdds.TypeKind.TypeKind
        BITSET_TYPE: rti.connextdds.TypeKind.TypeKind
        BOOLEAN_TYPE: rti.connextdds.TypeKind.TypeKind
        CHAR_16_TYPE: rti.connextdds.TypeKind.TypeKind
        CHAR_8_TYPE: rti.connextdds.TypeKind.TypeKind
        COLLECTION_TYPE: rti.connextdds.TypeKind.TypeKind
        CONSTRUCTED_TYPE: rti.connextdds.TypeKind.TypeKind
        ENUMERATION_TYPE: rti.connextdds.TypeKind.TypeKind
        FLOAT_128_TYPE: rti.connextdds.TypeKind.TypeKind
        FLOAT_32_TYPE: rti.connextdds.TypeKind.TypeKind
        FLOAT_64_TYPE: rti.connextdds.TypeKind.TypeKind
        INT_16_TYPE: rti.connextdds.TypeKind.TypeKind
        INT_32_TYPE: rti.connextdds.TypeKind.TypeKind
        INT_64_TYPE: rti.connextdds.TypeKind.TypeKind
        MAP_TYPE: rti.connextdds.TypeKind.TypeKind
        NO_TYPE: rti.connextdds.TypeKind.TypeKind
        PRIMITIVE_TYPE: rti.connextdds.TypeKind.TypeKind
        SEQUENCE_TYPE: rti.connextdds.TypeKind.TypeKind
        STRING_TYPE: rti.connextdds.TypeKind.TypeKind
        STRUCTURE_FWD_DECL_TYPE: rti.connextdds.TypeKind.TypeKind
        STRUCTURE_TYPE: rti.connextdds.TypeKind.TypeKind
        UINT_16_TYPE: rti.connextdds.TypeKind.TypeKind
        UINT_32_TYPE: rti.connextdds.TypeKind.TypeKind
        UINT_64_TYPE: rti.connextdds.TypeKind.TypeKind
        UINT_8_TYPE: rti.connextdds.TypeKind.TypeKind
        UNION_FWD_DECL_TYPE: rti.connextdds.TypeKind.TypeKind
        UNION_TYPE: rti.connextdds.TypeKind.TypeKind
        WSTRING_TYPE: rti.connextdds.TypeKind.TypeKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.TypeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.TypeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.TypeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.TypeKind.TypeKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.TypeKind.TypeKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.TypeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.TypeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.TypeKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> TypeKind.TypeKind:
        """
        Retrieves the actual enumerated value.

        :type: TypeKind.TypeKind
        """
    AGGREGATION_TYPE: rti.connextdds.TypeKind.TypeKind
    ALIAS_TYPE: rti.connextdds.TypeKind.TypeKind
    ANNOTATION_TYPE: rti.connextdds.TypeKind.TypeKind
    ARRAY_TYPE: rti.connextdds.TypeKind.TypeKind
    BITSET_TYPE: rti.connextdds.TypeKind.TypeKind
    BOOLEAN_TYPE: rti.connextdds.TypeKind.TypeKind
    CHAR_16_TYPE: rti.connextdds.TypeKind.TypeKind
    CHAR_8_TYPE: rti.connextdds.TypeKind.TypeKind
    COLLECTION_TYPE: rti.connextdds.TypeKind.TypeKind
    CONSTRUCTED_TYPE: rti.connextdds.TypeKind.TypeKind
    ENUMERATION_TYPE: rti.connextdds.TypeKind.TypeKind
    FLOAT_128_TYPE: rti.connextdds.TypeKind.TypeKind
    FLOAT_32_TYPE: rti.connextdds.TypeKind.TypeKind
    FLOAT_64_TYPE: rti.connextdds.TypeKind.TypeKind
    INT_16_TYPE: rti.connextdds.TypeKind.TypeKind
    INT_32_TYPE: rti.connextdds.TypeKind.TypeKind
    INT_64_TYPE: rti.connextdds.TypeKind.TypeKind
    MAP_TYPE: rti.connextdds.TypeKind.TypeKind
    NO_TYPE: rti.connextdds.TypeKind.TypeKind
    PRIMITIVE_TYPE: rti.connextdds.TypeKind.TypeKind
    SEQUENCE_TYPE: rti.connextdds.TypeKind.TypeKind
    STRING_TYPE: rti.connextdds.TypeKind.TypeKind
    STRUCTURE_FWD_DECL_TYPE: rti.connextdds.TypeKind.TypeKind
    STRUCTURE_TYPE: rti.connextdds.TypeKind.TypeKind
    UINT_16_TYPE: rti.connextdds.TypeKind.TypeKind
    UINT_32_TYPE: rti.connextdds.TypeKind.TypeKind
    UINT_64_TYPE: rti.connextdds.TypeKind.TypeKind
    UINT_8_TYPE: rti.connextdds.TypeKind.TypeKind
    UNION_FWD_DECL_TYPE: rti.connextdds.TypeKind.TypeKind
    UNION_TYPE: rti.connextdds.TypeKind.TypeKind
    WSTRING_TYPE: rti.connextdds.TypeKind.TypeKind
    __hash__: NoneType
    pass
class TypeSupport():
    def __eq__(self, arg0: rti.connextdds.TypeSupport) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    def __ne__(self, arg0: rti.connextdds.TypeSupport) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def cdr_padding_kind(self) -> CdrPaddingKind:
        """
        Determines whether or not the padding bytes will be set to zero during CDR serialization.

        :type: CdrPaddingKind
        """
    @cdr_padding_kind.setter
    def cdr_padding_kind(self, arg1: CdrPaddingKind) -> None:
        """
        Determines whether or not the padding bytes will be set to zero during CDR serialization.
        """
    __hash__: NoneType
    pass
class Uint64Seq():
    def __add__(self, arg0: rti.connextdds.Uint64Seq) -> rti.connextdds.Uint64Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: int) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Uint64Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Uint64Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> int: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Uint64Seq) -> rti.connextdds.Uint64Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Uint64Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Uint64Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Uint64Seq: ...
    def __ne__(self, arg0: rti.connextdds.Uint64Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Uint64Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Uint64Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: int) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: int) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Uint64Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: int) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> int: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> int: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: int) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Uint64Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Uint64Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Uint64Type
        """
    def __ne__(self, arg0: rti.connextdds.Uint64Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class Uint32Seq():
    def __add__(self, arg0: rti.connextdds.Uint32Seq) -> rti.connextdds.Uint32Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: int) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Uint32Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Uint32Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> int: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Uint32Seq) -> rti.connextdds.Uint32Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Uint32Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Uint32Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Uint32Seq: ...
    def __ne__(self, arg0: rti.connextdds.Uint32Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Uint32Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Uint32Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: int) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: int) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Uint32Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: int) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> int: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> int: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: int) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
class Uint32Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Uint32Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Uint32Type
        """
    def __ne__(self, arg0: rti.connextdds.Uint32Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class Uint16Type(DynamicType):
    def __eq__(self, arg0: rti.connextdds.Uint16Type) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for Uint16Type
        """
    def __ne__(self, arg0: rti.connextdds.Uint16Type) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class Uint16Seq():
    def __add__(self, arg0: rti.connextdds.Uint16Seq) -> rti.connextdds.Uint16Seq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: int) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.Uint16Seq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.Uint16Seq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> int: ...
    def __getstate__(self) -> bytes: ...
    def __iadd__(self, arg0: rti.connextdds.Uint16Seq) -> rti.connextdds.Uint16Seq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.Uint16Seq: ...
    @typing.overload
    def __init__(self, arg0: Buffer) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Uint16Seq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    @typing.overload
    def __init__(self, arg0: int) -> None: ...
    def __iter__(self) -> typing.Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.Uint16Seq: ...
    def __ne__(self, arg0: rti.connextdds.Uint16Seq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.Uint16Seq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.Uint16Seq) -> None: 
        """
        Assign list elements using a slice object
        """
    def __setstate__(self, arg0: bytes) -> None: ...
    def append(self, x: int) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: int) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.Uint16Seq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: int) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> int: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> int: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: int) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    def resize(self, arg0: int) -> None: 
        """
        resizes the vector to the given size
        """
    __hash__: NoneType
    pass
UShortType = Uint16Type
ULongSeq = Uint32Seq
ULongType = Uint32Type
ULongLongSeq = Uint64Seq
ULongLongType = Uint64Type
OctetSeq = Uint8Seq
OctetType = Uint8Type
class SequenceType(UnidimensionalCollectionType, CollectionType, DynamicType):
    def __eq__(self, arg0: rti.connextdds.SequenceType) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, data_type: rti.connextdds.DynamicType) -> None: 
        """
        Creates an unbounded collection with an element type.
        """
    @typing.overload
    def __init__(self, data_type: rti.connextdds.DynamicType, bounds: int) -> None: 
        """
        Creates a bounded collection with an element type.
        """
    def __ne__(self, arg0: rti.connextdds.SequenceType) -> bool: 
        """
        Test for inequality.
        """
    UNBOUNDED: int
    __hash__: NoneType
    pass
class UnionMember():
    def __eq__(self, arg0: rti.connextdds.UnionMember) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, name: str, dynamic_type: rti.connextdds.DynamicType, label: int) -> None: 
        """
        Creates a union member with a name, type, and selected by a single label.
        """
    @typing.overload
    def __init__(self, name: str, dynamic_type: rti.connextdds.DynamicType, labels: rti.connextdds.Int32Seq) -> None: 
        """
        Create a union member with a name, type, and selected by one or more labels.
        """
    def __ne__(self, arg0: rti.connextdds.UnionMember) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def has_id(self) -> bool:
        """
        Indicates if union member has an ID annotation.

        :type: bool
        """
    @builtins.property
    def id(self) -> int:
        """
        Returns the ID annotation of this member, or INVALID_ID if this member has no ID.

        :type: int
        """
    @id.setter
    def id(self, arg1: int) -> None:
        """
        Returns the ID annotation of this member, or INVALID_ID if this member has no ID.
        """
    @builtins.property
    def label_count(self) -> int:
        """
        Gets the number of labels that select this member.

        :type: int
        """
    @builtins.property
    def labels(self) -> Int32Seq:
        """
        The labels that select this member.

        :type: Int32Seq
        """
    @labels.setter
    def labels(self, arg1: Int32Seq) -> None:
        """
        The labels that select this member.
        """
    @builtins.property
    def name(self) -> str:
        """
        The union member's name.

        :type: str
        """
    @name.setter
    def name(self, arg1: str) -> None:
        """
        The union member's name.
        """
    @builtins.property
    def pointer(self) -> bool:
        """
        Boolean flag for pointer status of union member.

        :type: bool
        """
    @pointer.setter
    def pointer(self, arg1: bool) -> None:
        """
        Boolean flag for pointer status of union member.
        """
    @builtins.property
    def type(self) -> object:
        """
        Gets the union member's type.

        :type: object
        """
    DEFAULT_LABEL: int
    INVALID_ID: int
    __hash__: NoneType
    pass
class UnionMemberSeq():
    def __add__(self, arg0: rti.connextdds.UnionMemberSeq) -> rti.connextdds.UnionMemberSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: rti.connextdds.UnionMember) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.UnionMemberSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.UnionMemberSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> rti.connextdds.UnionMember: ...
    def __iadd__(self, arg0: rti.connextdds.UnionMemberSeq) -> rti.connextdds.UnionMemberSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.UnionMemberSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.UnionMemberSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[rti.connextdds.UnionMember]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.UnionMemberSeq: ...
    def __ne__(self, arg0: rti.connextdds.UnionMemberSeq) -> bool: ...
    def __rmul__(self, arg0: int) -> rti.connextdds.UnionMemberSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: rti.connextdds.UnionMember) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.UnionMemberSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: rti.connextdds.UnionMember) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: rti.connextdds.UnionMember) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.UnionMemberSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: rti.connextdds.UnionMember) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> rti.connextdds.UnionMember: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> rti.connextdds.UnionMember: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: rti.connextdds.UnionMember) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class UnionType(ACTUnionMember, DynamicType):
    def __eq__(self, arg0: rti.connextdds.UnionType) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, name: str, discriminator_type: rti.connextdds.DynamicType) -> None: 
        """
        Creates an empty Union.
        """
    @typing.overload
    def __init__(self, name: str, discriminator_type: rti.connextdds.DynamicType, members: rti.connextdds.UnionMemberSeq) -> None: 
        """
        Creates a Union with the specified UnionMembers.
        """
    @typing.overload
    def __init__(self, type: rti.connextdds.DynamicType) -> None: 
        """
        Cast a DynamicType to a UnionType.
        """
    def __ne__(self, arg0: rti.connextdds.UnionType) -> bool: 
        """
        Test for inequality.
        """
    def add_members(self, members: rti.connextdds.UnionMemberSeq) -> rti.connextdds.UnionType: 
        """
        Adds all the members of a container at the end.
        """
    def find_member_by_id(self, id: int) -> int: 
        """
        Gets the index of the member selected by an ID.
        """
    def find_member_by_label(self, label: int) -> int: 
        """
        Gets the index of the member selected by a label.
        """
    @builtins.property
    def discriminator(self) -> DynamicType:
        """
        The union discriminator type.

        :type: DynamicType
        """
    @builtins.property
    def extensibility_kind(self) -> ExtensibilityKind:
        """
        Union's extensibility kind.

        :type: ExtensibilityKind
        """
    @extensibility_kind.setter
    def extensibility_kind(self, arg1: ExtensibilityKind) -> None:
        """
        Union's extensibility kind.
        """
    INVALID_INDEX: int
    __hash__: NoneType
    pass
class UnsupportedError(Exception, Exception, BaseException):
    pass
class UserData():
    def __eq__(self, arg0: rti.connextdds.UserData) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an instance with an empty sequence of bytes.
        """
    @typing.overload
    def __init__(self, data: rti.connextdds.Uint8Seq) -> None: 
        """
        Creates an instance with a sequence of bytes.
        """
    def __iter__(self) -> typing.Iterator[int]: ...
    def __ne__(self, arg0: rti.connextdds.UserData) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> Uint8Seq:
        """
        The user data.

        :type: Uint8Seq
        """
    @value.setter
    def value(self, arg1: Uint8Seq) -> None:
        """
        The user data.
        """
    __hash__: NoneType
    pass
class UserDataSample():
    """
    An alias for a Python ``object`` representing a data sample of an IDL type
    """
    def _get_ptr(self) -> int: ...
    pass
UshortSeq = Uint16Seq
class ValuesView():
    def __iter__(self) -> typing.Iterator: ...
    def __len__(self) -> int: ...
    pass
class VendorId():
    def __eq__(self, arg0: rti.connextdds.VendorId) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates unknown vendor ID.
        """
    def __ne__(self, arg0: rti.connextdds.VendorId) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def value(self) -> Uint8Seq:
        """
        Provides access to the bytes that represent the vendor id.

        :type: Uint8Seq
        """
    __hash__: NoneType
    unknown: rti.connextdds.VendorId
    pass
class Verbosity():
    class Verbosity():
        """
        Members:

          SILENT : No further output will be logged.

          EXCEPTION : Only error messages will be logged.

        An error indicates something wrong in the functioning of RTI Connext. The most common cause of errors is incorrect configuration.

          WARNING : Both error and warning messages will be logged.

        A warning indicates that RTI Connext is taking an action that may or may not be what you intended. Some configuration information is also logged at this verbosity to aid in debugging.

          STATUS_LOCAL : Errors, warnings, and verbose information about the lifecycles of local RTI Connext objects will be logged.

          STATUS_REMOTE : Errors, warnings, and verbose information about the lifecycles of remote RTI Connext objects will be logged.

          STATUS_ALL : Errors, warnings, verbose information about the lifecycles of local and remote RTI Connext objects, and periodic information about RTI Connext threads will be logged.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        EXCEPTION: rti.connextdds.Verbosity.Verbosity
        SILENT: rti.connextdds.Verbosity.Verbosity
        STATUS_ALL: rti.connextdds.Verbosity.Verbosity
        STATUS_LOCAL: rti.connextdds.Verbosity.Verbosity
        STATUS_REMOTE: rti.connextdds.Verbosity.Verbosity
        WARNING: rti.connextdds.Verbosity.Verbosity
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.Verbosity) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.Verbosity) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.Verbosity) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.Verbosity.Verbosity) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.Verbosity.Verbosity: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.Verbosity) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.Verbosity) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.Verbosity) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> Verbosity.Verbosity:
        """
        Retrieves the actual enumerated value.

        :type: Verbosity.Verbosity
        """
    EXCEPTION: rti.connextdds.Verbosity.Verbosity
    SILENT: rti.connextdds.Verbosity.Verbosity
    STATUS_ALL: rti.connextdds.Verbosity.Verbosity
    STATUS_LOCAL: rti.connextdds.Verbosity.Verbosity
    STATUS_REMOTE: rti.connextdds.Verbosity.Verbosity
    WARNING: rti.connextdds.Verbosity.Verbosity
    __hash__: NoneType
    pass
class ViewState():
    def __and__(self, arg0: rti.connextdds.ViewState) -> rti.connextdds.ViewState: 
        """
        Bitwise logical AND of masks.
        """
    def __bool__(self) -> rti.connextdds.ViewState: 
        """
        Test if any bits are set.
        """
    def __contains__(self, arg0: rti.connextdds.ViewState) -> bool: ...
    def __eq__(self, arg0: rti.connextdds.ViewState) -> bool: 
        """
        Compare masks for equality.
        """
    def __getitem__(self, arg0: int) -> bool: 
        """
        Get individual mask bit.
        """
    def __iand__(self, arg0: rti.connextdds.ViewState) -> rti.connextdds.ViewState: 
        """
        Set mask to logical AND with another mask.
        """
    def __ilshift__(self, arg0: int) -> rti.connextdds.ViewState: 
        """
        Left shift bits in mask.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a ViewState with no bits set.
        """
    @typing.overload
    def __init__(self, value: int) -> None: 
        """
        Creates a mask from the bits in an integer.
        """
    def __int__(self) -> int: 
        """
        Convert mask to int.
        """
    def __ior__(self, arg0: rti.connextdds.ViewState) -> rti.connextdds.ViewState: 
        """
        Set mask to logical OR with another mask.
        """
    def __irshift__(self, arg0: int) -> rti.connextdds.ViewState: 
        """
        Right shift bits in mask.
        """
    def __ixor__(self, arg0: rti.connextdds.ViewState) -> rti.connextdds.ViewState: 
        """
        Set mask to logical XOR with another mask.
        """
    def __lshift__(self, arg0: int) -> rti.connextdds.ViewState: 
        """
        Left shift bits in mask.
        """
    def __ne__(self, arg0: rti.connextdds.ViewState) -> bool: 
        """
        Compare masks for inequality.
        """
    def __or__(self, arg0: rti.connextdds.ViewState) -> rti.connextdds.ViewState: 
        """
        Bitwise logical OR of masks.
        """
    def __rshift__(self, arg0: int) -> rti.connextdds.ViewState: 
        """
        Right shift bits in mask.
        """
    def __setitem__(self, arg0: int, arg1: bool) -> None: 
        """
        Set individual mask bit
        """
    def __str__(self) -> str: ...
    def __xor__(self, arg0: rti.connextdds.ViewState) -> rti.connextdds.ViewState: 
        """
        Bitwise logical XOR of masks.
        """
    @typing.overload
    def flip(self) -> rti.connextdds.ViewState: 
        """
        Flip all bits in the mask.
        """
    @typing.overload
    def flip(self, pos: int) -> rti.connextdds.ViewState: 
        """
        Flip the mask bit at the specified position.
        """
    @typing.overload
    def reset(self) -> rti.connextdds.ViewState: 
        """
        Clear all bits in the mask.
        """
    @typing.overload
    def reset(self, pos: int) -> rti.connextdds.ViewState: 
        """
        Clear the mask bit at the specified position.
        """
    @typing.overload
    def set(self) -> rti.connextdds.ViewState: 
        """
        Set all bits in the mask.
        """
    @typing.overload
    def set(self, pos: int, value: bool = True) -> rti.connextdds.ViewState: 
        """
        Set the mask bit at the specified position to the provided value (default: true).
        """
    def test(self, pos: int) -> bool: 
        """
        Test whether the mask bit at position "pos" is set.
        """
    def test_all(self) -> bool: 
        """
        Test if all bits are set.
        """
    def test_any(self) -> bool: 
        """
        Test if any bits are set.
        """
    def test_none(self) -> bool: 
        """
        Test if none of the bits are set.
        """
    @builtins.property
    def count(self) -> int:
        """
        Returns the number of bits set in the mask.

        :type: int
        """
    @builtins.property
    def size(self) -> int:
        """
        Returns the number of bits in the mask type.

        :type: int
        """
    ANY: rti.connextdds.ViewState
    NEW_VIEW: rti.connextdds.ViewState
    NOT_NEW_VIEW: rti.connextdds.ViewState
    __hash__: NoneType
    pass
class WStringType(UnidimensionalCollectionType, CollectionType, DynamicType):
    def __eq__(self, arg0: rti.connextdds.WStringType) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self, bounds: int) -> None: 
        """
        Creates a bounded wide string.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates an unbounded wide string.
        """
    def __ne__(self, arg0: rti.connextdds.WStringType) -> bool: 
        """
        Test for inequality.
        """
    UNBOUNDED: int
    __hash__: NoneType
    pass
class WaitSet():
    def __iadd__(self, arg0: rti.connextdds.ICondition) -> rti.connextdds.WaitSet: 
        """
        Attach a condition to a WaitSet.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Create a WaitSet with no conditions attached.
        """
    @typing.overload
    def __init__(self, property: rti.connextdds.WaitSetProperty) -> None: 
        """
        Create a WaitSet with no conditions attached with the specified WaitSetProperty settings.
        """
    def __isub__(self, arg0: rti.connextdds.ICondition) -> rti.connextdds.WaitSet: 
        """
        Detach a condition from a WaitSet.
        """
    def attach_condition(self, condition: rti.connextdds.ICondition) -> None: 
        """
        Attach a condition to the WaitSet.
        """
    def detach_all(self) -> None: 
        """
        Detach all conditions from the WaitSet.
        """
    def detach_condition(self, condition: rti.connextdds.ICondition) -> bool: 
        """
        Detach a condition from the WaitSet.
        """
    @typing.overload
    def dispatch(self, timeout: rti.connextdds.Duration) -> None: 
        """
        Dispatch handlers for triggered conditions attached to this WaitSet with a timeout.
        """
    @typing.overload
    def dispatch(self) -> None: 
        """
        Dispatch handlers for triggered conditions attached to this WaitSet with no timeout.
        """
    @typing.overload
    def dispatch_async(self, timeout: rti.connextdds.Duration) -> object: 
        """
        Dispatch handlers for triggered conditions attached to this WaitSet with a timeout. This call is awaitable and only for use with asyncio.
        """
    @typing.overload
    def dispatch_async(self) -> object: 
        """
        Dispatch handlers for triggered conditions attached to this WaitSet with no timeout. This call is awaitable and only for use with asyncio.
        """
    @typing.overload
    def wait(self, timeout: rti.connextdds.Duration) -> rti.connextdds.TriggeredConditions: 
        """
        Wait for conditions attached to this WaitSet to trigger with a timeout.
        """
    @typing.overload
    def wait(self) -> rti.connextdds.TriggeredConditions: 
        """
        Wait indefinitely for conditions attached to this WaitSet to trigger.
        """
    @typing.overload
    def wait_async(self, timeout: rti.connextdds.Duration) -> object: 
        """
        Wait for conditions attached to this WaitSet to trigger with a timeout. This call is awaitable and only for use with asyncio.
        """
    @typing.overload
    def wait_async(self) -> object: 
        """
        Wait indefinitely for conditions attached to this WaitSet to trigger. This call is awaitable and only for use with asyncio.
        """
    def wait_one(self, timeout: rti.connextdds.Duration) -> bool: 
        """
        Wait for conditions attached to this WaitSet to trigger. Useful when only one condition is attached. Returns ``true`` if any condition triggered or ``false`` if the timeout expired.
        """
    def wait_one_async(self, timeout: rti.connextdds.Duration) -> object: 
        """
        Wait asynchronously for conditions attached to this WaitSet to trigger. Useful when only one condition is attached. Returns ``true`` if any condition triggered or ``false`` if the timeout expired.
        """
    @builtins.property
    def conditions(self) -> ConditionSeq:
        """
        Get/set the attached conditions for the WaitSet.

        :type: ConditionSeq
        """
    @conditions.setter
    def conditions(self, arg1: IConditionSeq) -> None:
        """
        Get/set the attached conditions for the WaitSet.
        """
    @builtins.property
    def property(self) -> WaitSetProperty:
        """
        Get/set the WaitSetProperty settings for the WaitSet.

        :type: WaitSetProperty
        """
    @property.setter
    def property(self, arg1: WaitSetProperty) -> None:
        """
        Get/set the WaitSetProperty settings for the WaitSet.
        """
    pass
class WaitSetProperty():
    def __eq__(self, arg0: rti.connextdds.WaitSetProperty) -> bool: 
        """
        Compare objects for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Constructs a WaitSetProperty with default values.
        """
    @typing.overload
    def __init__(self, event_count: int, event_delay: rti.connextdds.Duration) -> None: 
        """
        Construct a WaitSetProperty with the given settings.
        """
    def __ne__(self, arg0: rti.connextdds.WaitSetProperty) -> bool: 
        """
        Determine if objects are unequal.
        """
    @builtins.property
    def event_count(self) -> int:
        """
        Get/set the event count that will wake the WaitSet.

        :type: int
        """
    @event_count.setter
    def event_count(self, arg1: int) -> None:
        """
        Get/set the event count that will wake the WaitSet.
        """
    @builtins.property
    def event_delay(self) -> Duration:
        """
        Get/set the delay that will cause the WaitSet to wake even if the event count is not hit.

        :type: Duration
        """
    @event_delay.setter
    def event_delay(self, arg1: Duration) -> None:
        """
        Get/set the delay that will cause the WaitSet to wake even if the event count is not hit.
        """
    __hash__: NoneType
    pass
class WcharSeq():
    def __add__(self, arg0: rti.connextdds.WcharSeq) -> rti.connextdds.WcharSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: str) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.WcharSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.WcharSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> str: ...
    def __iadd__(self, arg0: rti.connextdds.WcharSeq) -> rti.connextdds.WcharSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.WcharSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.WcharSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.WcharSeq: ...
    def __ne__(self, arg0: rti.connextdds.WcharSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.WcharSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: str) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.WcharSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: str) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: str) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.WcharSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: str) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> str: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> str: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: str) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class WcharType(DynamicType):
    def __eq__(self, arg0: rti.connextdds.WcharType) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Get the singleton for WcharType
        """
    def __ne__(self, arg0: rti.connextdds.WcharType) -> bool: 
        """
        Test for inequality.
        """
    __hash__: NoneType
    pass
class WireProtocol():
    def __eq__(self, arg0: rti.connextdds.WireProtocol) -> bool: 
        """
        Test for equality.
        """
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    def __ne__(self, arg0: rti.connextdds.WireProtocol) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def check_crc(self) -> bool:
        """
        Checks if the received RTPS message is valid by comparing the computed CRC with the received RTPS CRC submessage when this field is set to true.

        :type: bool
        """
    @check_crc.setter
    def check_crc(self, arg1: bool) -> None:
        """
        Checks if the received RTPS message is valid by comparing the computed CRC with the received RTPS CRC submessage when this field is set to true.
        """
    @builtins.property
    def compute_crc(self) -> bool:
        """
        Adds RTPS CRC submessage to every message when this field is set to true.

        :type: bool
        """
    @compute_crc.setter
    def compute_crc(self, arg1: bool) -> None:
        """
        Adds RTPS CRC submessage to every message when this field is set to true.
        """
    @builtins.property
    def participant_id(self) -> int:
        """
        A value used to distinguish among different participants belonging to the same domain on the same host.

        :type: int
        """
    @participant_id.setter
    def participant_id(self, arg1: int) -> None:
        """
        A value used to distinguish among different participants belonging to the same domain on the same host.
        """
    @builtins.property
    def rtps_app_id(self) -> int:
        """
        The RTPS App ID of the domain participant.

        :type: int
        """
    @rtps_app_id.setter
    def rtps_app_id(self, arg1: int) -> None:
        """
        The RTPS App ID of the domain participant.
        """
    @builtins.property
    def rtps_auto_id_kind(self) -> WireProtocolAutoKind:
        """
        Kind of auto mechanism used to calculate the GUID prefix.

        :type: WireProtocolAutoKind
        """
    @rtps_auto_id_kind.setter
    def rtps_auto_id_kind(self, arg1: WireProtocolAutoKind) -> None:
        """
        Kind of auto mechanism used to calculate the GUID prefix.
        """
    @builtins.property
    def rtps_host_id(self) -> int:
        """
        The RTPS Host ID of the domain participant.

        :type: int
        """
    @rtps_host_id.setter
    def rtps_host_id(self, arg1: int) -> None:
        """
        The RTPS Host ID of the domain participant.
        """
    @builtins.property
    def rtps_instance_id(self) -> int:
        """
        The RTPS Instance ID of the domain participant.

        :type: int
        """
    @rtps_instance_id.setter
    def rtps_instance_id(self, arg1: int) -> None:
        """
        The RTPS Instance ID of the domain participant.
        """
    @builtins.property
    def rtps_reserved_port_mask(self) -> RtpsReservedPortKindMask:
        """
        Specifies which well-known ports to reserve when enabling the participant.

        This property's getter returns a deep copy.

        :type: RtpsReservedPortKindMask
        """
    @rtps_reserved_port_mask.setter
    def rtps_reserved_port_mask(self, arg1: RtpsReservedPortKindMask) -> None:
        """
        Specifies which well-known ports to reserve when enabling the participant.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def rtps_well_known_ports(self) -> RtpsWellKnownPorts:
        """
        The RTPS well-known port mappings.

        This property's getter returns a deep copy.

        :type: RtpsWellKnownPorts
        """
    @rtps_well_known_ports.setter
    def rtps_well_known_ports(self, arg1: RtpsWellKnownPorts) -> None:
        """
        The RTPS well-known port mappings.

        This property's getter returns a deep copy.
        """
    RTPS_AUTO_ID: int
    __hash__: NoneType
    pass
class WireProtocolAutoKind():
    class WireProtocolAutoKind():
        """
        Members:

          RTPS_AUTO_ID_FROM_IP : Select the IPv4 based algorithm.

          RTPS_AUTO_ID_FROM_MAC : Select the MAC based algorithm.

          RTPS_AUTO_ID_FROM_UUID : Select the UUID based algorithm.
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        def __str__(self) -> str: ...
        @builtins.property
        def name(self) -> str:
            """
            :type: str
            """
        @builtins.property
        def value(self) -> int:
            """
            :type: int
            """
        RTPS_AUTO_ID_FROM_IP: rti.connextdds.WireProtocolAutoKind.WireProtocolAutoKind
        RTPS_AUTO_ID_FROM_MAC: rti.connextdds.WireProtocolAutoKind.WireProtocolAutoKind
        RTPS_AUTO_ID_FROM_UUID: rti.connextdds.WireProtocolAutoKind.WireProtocolAutoKind
        __members__: dict
        pass
    def __eq__(self, arg0: rti.connextdds.WireProtocolAutoKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ge__(self, arg0: rti.connextdds.WireProtocolAutoKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __gt__(self, arg0: rti.connextdds.WireProtocolAutoKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Initializes enum to 0.
        """
    @typing.overload
    def __init__(self, arg0: rti.connextdds.WireProtocolAutoKind.WireProtocolAutoKind) -> None: 
        """
        Copy constructor.
        """
    def __int__(self) -> rti.connextdds.WireProtocolAutoKind.WireProtocolAutoKind: 
        """
        Int conversion.
        """
    def __le__(self, arg0: rti.connextdds.WireProtocolAutoKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __lt__(self, arg0: rti.connextdds.WireProtocolAutoKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __ne__(self, arg0: rti.connextdds.WireProtocolAutoKind) -> bool: 
        """
        Apply operator to underlying enumerated values.
        """
    def __str__(self) -> str: 
        """
        String conversion.
        """
    @builtins.property
    def underlying(self) -> WireProtocolAutoKind.WireProtocolAutoKind:
        """
        Retrieves the actual enumerated value.

        :type: WireProtocolAutoKind.WireProtocolAutoKind
        """
    RTPS_AUTO_ID_FROM_IP: rti.connextdds.WireProtocolAutoKind.WireProtocolAutoKind
    RTPS_AUTO_ID_FROM_MAC: rti.connextdds.WireProtocolAutoKind.WireProtocolAutoKind
    RTPS_AUTO_ID_FROM_UUID: rti.connextdds.WireProtocolAutoKind.WireProtocolAutoKind
    __hash__: NoneType
    pass
class WriteParams():
    def __init__(self) -> None: 
        """
        Create a WriteParams object with default values.
        """
    def reset(self) -> None: 
        """
        Reset all fields to their default values.
        """
    @builtins.property
    def cookie(self) -> Cookie:
        """
        The cookie for writing.

        :type: Cookie
        """
    @cookie.setter
    def cookie(self, arg1: Cookie) -> None:
        """
        The cookie for writing.
        """
    @builtins.property
    def flag(self) -> SampleFlag:
        """
        The sample flag for writing.

        :type: SampleFlag
        """
    @flag.setter
    def flag(self, arg1: SampleFlag) -> None:
        """
        The sample flag for writing.
        """
    @builtins.property
    def handle(self) -> InstanceHandle:
        """
        The instance handle for writing.

        :type: InstanceHandle
        """
    @handle.setter
    def handle(self, arg1: InstanceHandle) -> None:
        """
        The instance handle for writing.
        """
    @builtins.property
    def identity(self) -> SampleIdentity:
        """
        The sample identity.

        :type: SampleIdentity
        """
    @identity.setter
    def identity(self, arg1: SampleIdentity) -> None:
        """
        The sample identity.
        """
    @builtins.property
    def priority(self) -> int:
        """
        The priority for writing.

        :type: int
        """
    @priority.setter
    def priority(self, arg1: int) -> None:
        """
        The priority for writing.
        """
    @builtins.property
    def related_reader_guid(self) -> Guid:
        """
        The related reader GUID for writing.

        :type: Guid
        """
    @related_reader_guid.setter
    def related_reader_guid(self, arg1: Guid) -> None:
        """
        The related reader GUID for writing.
        """
    @builtins.property
    def related_sample_identity(self) -> SampleIdentity:
        """
        The related sample identity.

        :type: SampleIdentity
        """
    @related_sample_identity.setter
    def related_sample_identity(self, arg1: SampleIdentity) -> None:
        """
        The related sample identity.
        """
    @builtins.property
    def related_source_guid(self) -> Guid:
        """
        The related source GUID for writing.

        :type: Guid
        """
    @related_source_guid.setter
    def related_source_guid(self, arg1: Guid) -> None:
        """
        The related source GUID for writing.
        """
    @builtins.property
    def replace_automatic_values(self) -> bool:
        """
        Indicates if the replacement of automatic values has been activated or not.

        :type: bool
        """
    @replace_automatic_values.setter
    def replace_automatic_values(self, arg1: bool) -> None:
        """
        Indicates if the replacement of automatic values has been activated or not.
        """
    @builtins.property
    def source_guid(self) -> Guid:
        """
        The source GUID for writing.

        :type: Guid
        """
    @source_guid.setter
    def source_guid(self, arg1: Guid) -> None:
        """
        The source GUID for writing.
        """
    @builtins.property
    def source_timestamp(self) -> Time:
        """
        The source timestamp for writing.

        :type: Time
        """
    @source_timestamp.setter
    def source_timestamp(self, arg1: Time) -> None:
        """
        The source timestamp for writing.
        """
    pass
class WriterDataLifecycle():
    def __eq__(self, arg0: rti.connextdds.WriterDataLifecycle) -> bool: 
        """
        Test for equality.
        """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates the default policy.
        """
    @typing.overload
    def __init__(self, autodispose: bool) -> None: 
        """
        Creates an instance with a value for auto-dispose unregistered instances and default values for the rest of parameters.
        """
    def __ne__(self, arg0: rti.connextdds.WriterDataLifecycle) -> bool: 
        """
        Test for inequality.
        """
    @builtins.property
    def autodispose_unregistered_instances(self) -> bool:
        """
        Indicates whether the DataWriter should automatically dispose an instance when it unregisters it.

        :type: bool
        """
    @autodispose_unregistered_instances.setter
    def autodispose_unregistered_instances(self, arg1: bool) -> None:
        """
        Indicates whether the DataWriter should automatically dispose an instance when it unregisters it.
        """
    @builtins.property
    def autopurge_disposed_instances_delay(self) -> Duration:
        """
        Maximum duration for which the DataWriter will maintain information regarding an instance once it has disposed the instance.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @autopurge_disposed_instances_delay.setter
    def autopurge_disposed_instances_delay(self, arg1: Duration) -> None:
        """
        Maximum duration for which the DataWriter will maintain information regarding an instance once it has disposed the instance.

        This property's getter returns a deep copy.
        """
    @builtins.property
    def autopurge_unregistered_instances_delay(self) -> Duration:
        """
        Maximum duration for which the DataWriter will maintain information regarding an instance once it has unregistered the instance.

        This property's getter returns a deep copy.

        :type: Duration
        """
    @autopurge_unregistered_instances_delay.setter
    def autopurge_unregistered_instances_delay(self, arg1: Duration) -> None:
        """
        Maximum duration for which the DataWriter will maintain information regarding an instance once it has unregistered the instance.

        This property's getter returns a deep copy.
        """
    __hash__: NoneType
    pass
class WstringSeq():
    def __add__(self, arg0: rti.connextdds.WstringSeq) -> rti.connextdds.WstringSeq: ...
    def __bool__(self) -> bool: 
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: str) -> bool: 
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None: 
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None: 
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: rti.connextdds.WstringSeq) -> bool: ...
    @typing.overload
    def __getitem__(self, s: slice) -> rti.connextdds.WstringSeq: 
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> str: ...
    def __iadd__(self, arg0: rti.connextdds.WstringSeq) -> rti.connextdds.WstringSeq: ...
    def __imul__(self, arg0: int) -> rti.connextdds.WstringSeq: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, arg0: rti.connextdds.WstringSeq) -> None: 
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: int) -> rti.connextdds.WstringSeq: ...
    def __ne__(self, arg0: rti.connextdds.WstringSeq) -> bool: ...
    def __repr__(self) -> str: 
        """
        Return the canonical string representation of this list.
        """
    def __rmul__(self, arg0: int) -> rti.connextdds.WstringSeq: ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: str) -> None: ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: rti.connextdds.WstringSeq) -> None: 
        """
        Assign list elements using a slice object
        """
    def append(self, x: str) -> None: 
        """
        Add an item to the end of the list
        """
    def clear(self) -> None: 
        """
        Clear the contents
        """
    def count(self, x: str) -> int: 
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: rti.connextdds.WstringSeq) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None: 
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: str) -> None: 
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> str: 
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> str: 
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: str) -> None: 
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
    __hash__: NoneType
    pass
class _FastWaitSet():
    def __init__(self) -> None: 
        """
        Create a FastWaitSet.
        """
    def attach_condition(self, condition: rti.connextdds.ICondition) -> None: 
        """
        Attach a condition to the WaitSet.
        """
    def detach_condition(self, condition: rti.connextdds.ICondition) -> bool: 
        """
        Detach a condition from the WaitSet.
        """
    def dispatch(self) -> None: 
        """
        Dispatch the active conditions after a call to wait or wait_async
        """
    def get_waitset(self) -> rti.connextdds.WaitSet: 
        """
        Get the underlying WaitSet object.
        """
    def wait_async(self) -> object: 
        """
        Async wait
        """
    pass
class _GenericTypePluginFactory():
    @staticmethod
    def add_member(*args, **kwargs) -> typing.Any: ...
    @staticmethod
    def add_union_member(*args, **kwargs) -> typing.Any: ...
    @typing.overload
    def create_alias(self, arg0: str, arg1: rti.connextdds.DynamicType, arg2: int) -> rti.connextdds._TypePlugin: ...
    @typing.overload
    def create_alias(self, arg0: str, arg1: rti.connextdds._TypePlugin, arg2: int) -> rti.connextdds._TypePlugin: ...
    @typing.overload
    def create_array(self, arg0: rti.connextdds.DynamicType, arg1: rti.connextdds.Uint32Seq) -> rti.connextdds._TypePlugin: ...
    @typing.overload
    def create_array(self, arg0: rti.connextdds._TypePlugin, arg1: rti.connextdds.Uint32Seq) -> rti.connextdds._TypePlugin: ...
    def create_enum(self, arg0: str, arg1: rti.connextdds.ExtensibilityKind, arg2: rti.connextdds.EnumMemberSeq) -> rti.connextdds._TypePlugin: ...
    def create_sequence(self, arg0: rti.connextdds.DynamicType, arg1: int) -> rti.connextdds._TypePlugin: ...
    @typing.overload
    def create_struct(self, arg0: str, arg1: rti.connextdds.ExtensibilityKind, arg2: int, arg3: rti.connextdds.Uint32Seq) -> rti.connextdds._TypePlugin: ...
    @typing.overload
    def create_struct(self, arg0: str, arg1: rti.connextdds.DynamicType, arg2: rti.connextdds.ExtensibilityKind, arg3: int, arg4: rti.connextdds.Uint32Seq) -> rti.connextdds._TypePlugin: ...
    def create_type_plugin(self, type: rti.connextdds._TypePlugin) -> None: ...
    def create_union(self, arg0: str, arg1: rti.connextdds.DynamicType, arg2: rti.connextdds.ExtensibilityKind, arg3: int, arg4: rti.connextdds.Uint32Seq) -> rti.connextdds._TypePlugin: ...
    @staticmethod
    def delete_instance() -> None: ...
    instance: rti.connextdds._GenericTypePluginFactory
    public_instance: rti.connextdds._GenericTypePluginFactory
    pass
class _TypePlugin():
    def clone_type(self) -> object: ...
    def deserialize(self, c_sample: object, buffer: Buffer) -> None: ...
    def finalize_optional_members(self, c_sample: object) -> None: ...
    def finalize_sample(self, c_sample: object) -> None: ...
    def get_dynamic_type_ref(self) -> rti.connextdds.DynamicType: ...
    def get_instruction_index_from_member_index(self, member_index: int) -> int: ...
    def initialize_member(self, c_sample: object, member_index: int) -> None: ...
    def initialize_sample(self, c_sample: object) -> None: ...
    def max_serialized_sample_size(self) -> int: ...
    def resize_member(self, c_sample: object, member_index: int, new_size: int) -> None: ...
    def serialize(self, c_sample: object) -> rti.connextdds.Uint8Seq: ...
    def serialized_sample_size(self, c_sample: object) -> int: ...
    def set_allowed_data_representation_mask(self, mask: int) -> None: ...
    pass
def enable_automatic_tss_cleanup(enable: bool) -> None:
    """
    Enable automatic thread-specific storage (TSS) cleanup on platforms that support it.
    """
def set_activity_context(attribute_mask: rti.connextdds.ActivityContextMask) -> None:
    """
    Set the activity context mask.
    """
def sleep(duration: rti.connextdds.Duration) -> None:
    """
    Sleep for a specified duration
    """
def spin(spin_count: int) -> None:
    """
    Performs a spin operation (active wait) as many times as indicated.
    """
def spin_per_microsecond() -> int:
    """
    Returns the number of spin operations neededto wait 1 microsecond
    """
def unregister_thread() -> None:
    """
    Unregister a thread with the middleware
    """
LENGTH_AUTO: int
LENGTH_UNLIMITED: int
